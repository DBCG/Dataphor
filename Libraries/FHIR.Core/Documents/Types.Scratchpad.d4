/*
 Types.Scratchpad
*/

create type Resource
{
	id : id,
	meta : Meta,
	implicitRules : uri,
	language : code
};

create type DomainResource : Resource
{
	text : Narrative,
	contained : list(Resource),
	extension : list(Extension),
	modifierExtension : list(Extension)
};

create type PatientContact : Element
{
	relationship : list(CodeableConcept),
	name : HumanName,
	telecom : list(ContactPoint),
	address : Address,
	gender : code,
	organization : Reference,
	period : Period
}

create type PatientAnimal : Element
{
	species : CodeableConcept,
	breed : CodeableConcept,
	genderStatus : CodeableConcept
};

create type PatientCommunication : Element
{
	language : CodeableConcept,
	preferred : boolean
};

create type PatientLink : Element
{
	other : Reference,
	type : code
};

create type Patient : DomainResource
{
	identifier : list(Identifier),
	active : boolean,
	name : list(HumanName),
	telecom : list(ContactPoint),
	gender : code,
	birthDate : date,
	deceasedBoolean : boolean,
	deceasedDateTime : dateTime,
	address : list(Address),
	martialStatus : CodeableConcept,
	multipleBirthBoolean : boolean,
	multipleBirthInteger : integer,
	photo : list(Attachment),
	contact : list(PatientContact),
	animal : PatientAnimal,
	communication : list(PatientCommunication),
	careProvider : list(Reference),
	mangagingOrganization : Reference,
	link : list(PatientLink)
};
	
// With these types defined, you could define the storage at whatever level you wanted
// From a single table for all resources:

create table Resources
{
	ID : Integer,
	Type : String,
	Version : String,
	Resource : String,
	key { ID }
};

create table ResourceVersions
{
	ID : Integer,
	Version : String,
	Resource : String,
	key { ID, Version }
};

// All the way through to completely normalized structures:

create table Resources
{
	ID : Integer,
	Type : String,
	Version : String,
	Resource : String,
	Meta : Meta,
	key { ID }
};

create table ResourceVersions
{
	ID : Integer,
	Type : String,
	Version : String,
	Resource : String,
	Meta : Meta,
	key { ID, Version }
};

create table Patients
{
	ResourceID : Integer,
	...,
	key { ResourceID }
};

create table PatientIdentifiers
{
	ResourceID : Integer,
	Number : Integer,
	identifier : Identifier,
	key { ResourceID, Number }
};

create table PatientTelecoms
{
	ResourceID : Integer,
	Number : Integer,
	...,
	key { ResourceID, Number }
};

create table PatientAddresses
{
	ResourceID : Integer,
	Number : Integer,
	...,
	key { ResourceID, Number }
};

create table PatientPhotos
{
	...
};

...

// Or anywhere in between with some combination of tables and/or views

// The right answer would be to use tables to support searching for each search parameter defined for each resource type

create view PatientAPI
	select Resources where Type = 'Patient'
	
create view PatientAPI
	select
		Patients
		{
			id,
			meta,
			implicitResult,
			language,
			text,
			extensions,
			modifierExtensions,
			(PatientIdentifiers where ResourceID = ID { Number, identifier }) identifier,
			...
		}
		
// This "API" view would be what was exposed to REST as the Patient resource

