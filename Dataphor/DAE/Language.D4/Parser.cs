/*
	Dataphor
	Â© Copyright 2000-2008 Alphora
	This file is licensed under a modified BSD-license which can be found here: http://dataphor.org/dataphor_license.txt
*/
using System;
using System.Text;
using System.Collections;
using System.Collections.Specialized;
using System.IO;

using Alphora.Dataphor;
using Alphora.Dataphor.DAE;
using Alphora.Dataphor.DAE.Language;

namespace Alphora.Dataphor.DAE.Language.D4
{
    /*
		HEADER:
		The following non terminals in the Lexer BNF are referenced by the D4 BNF with equivalent meaning:
			<identifier>
			<literal>
			<string>

		The same conventions found in the The Third Manifesto are used here, namely:
			<XYZ list> ::= {<XYZ>}
			<XYZ commalist> ::= [<XYZ>{,<XYZ>}]
			<XYZ semicolonlist> ::= [<XYZ>{;<XYZ>}]
			<ne XYZ list> ::= <XYZ>{<XYZ>}
			<ne XYZ commalist> ::= <XYZ>{,<XYZ>}
			<ne XYZ semicolonlist> ::= <XYZ>{;<XYZ>}
    */
    
    /// <remarks> Given a Dataphor expression in string form, return a parsed statement.</remarks>
    public class Parser : Object
    {
		public Parser() : base() {}

		// IsInternal indicates that the expression being compiled is a known good expression generated by the compiler, so
		// reserved word references may be safely ignored.
		public Parser(bool AIsInternal) : base()
		{
			FIsInternal = AIsInternal;
		}
		
        protected Lexer FLexer;
        protected ParserMessages FMessages;
        protected bool FIsInternal;
        
		/*
			BNF:
			<script> ::=
				<statement semicolonlist>
		*/
        /// <summary>Parses the given Dataphor script.</summary>
        /// <returns>Returns the script in terms of <see cref="Statement"/> descendents</returns>
        public Statement ParseScript(string AInput, ParserMessages AMessages)
        {
            FLexer = new Lexer(AInput);
            try
            {
				FMessages = AMessages;
				try
				{
					Block LBlock = new Block();
					while (true)
					{
						if (FLexer[1].Type == TokenType.EOF)
							break;

						try
						{
							LBlock.Statements.Add(Statement());
							
							if (FLexer.PeekTokenSymbol(1) == Keywords.StatementTerminator)
								FLexer.NextToken();
							else if (!(FLexer[1].Type == TokenType.EOF))
								throw new ParserException(ParserException.Codes.StatementTerminatorExpected);
						}
						catch (Exception LException)
						{
							if (FMessages != null)
							{
								FMessages.Add(new SyntaxException(FLexer, LException));
								while (true)
								{
									if (FLexer[1].Type == TokenType.EOF)
										break;
									else if (FLexer[1].Type == TokenType.Symbol)
									{
										FLexer.NextToken();
										if (FLexer[0].AsSymbol == Keywords.StatementTerminator)
											break;
									}
									else
										FLexer.NextToken();
								}
							}
							else
								throw LException;
						}
					}

					LBlock.SetEndPosition(FLexer);
					return LBlock;
				}
				finally
				{
					FMessages = null;
				}
			}        
            finally
            {
                FLexer = null;
            }
        }
        
        public Statement ParseStatement(string AInput, ParserMessages AMessages)
        {
			FLexer = new Lexer(AInput);
			try
			{
				FMessages = AMessages;
				try
				{
					try
					{
						return Statement();
					}
					catch (Exception E)
					{
						if (FMessages != null)
						{
							FMessages.Add(new SyntaxException(FLexer, E));
							return new EmptyStatement();
						}
						else
							throw new SyntaxException(FLexer, E);
					}
				}
				finally
				{
					FMessages = null;
				}
			}
			finally
			{
				FLexer = null;
			}
        }
        
        public KeyDefinition ParseKeyDefinition(string AInput)
        {
			FLexer = new Lexer(AInput);
			try
			{
				try
				{
					return KeyDefinition();
				}
				catch (Exception E)
				{
					throw new SyntaxException(FLexer, E);
				}
				
			}
			finally
			{
				FLexer = null;
			}
        }
        
        public OrderDefinition ParseOrderDefinition(string AInput)
        {
			FLexer = new Lexer(AInput);
			try
			{
				try
				{
					return OrderDefinition();
				}
				catch (Exception E)
				{
					throw new SyntaxException(FLexer, E);
				}
			}
			finally
			{
				FLexer = null;
			}
        }

		/// <summary>Parses the given D4 expression.</summary>
        public Expression ParseExpression(string AInput)
        {
			FLexer = new Lexer(AInput);
			try
			{
				try
				{
					return Expression();
				}
				catch (Exception E)
				{
					throw new SyntaxException(FLexer, E);
				}
			}
			finally
			{
				FLexer = null;
			}
        }
        
		/// <summary>Parses the given D4 cursor definition.</summary>
		/// <returns>Returns the parse tree corresponding to the given cursor definition in terms of <see cref="Expression"/> descendents.  Ignores a leading select or cursor selector in the input string.</returns>        
		public Expression ParseCursorDefinition(string AInput)
		{
			FLexer = new Lexer(AInput);
			try
			{
				try
				{
					if (FLexer.PeekTokenSymbol(1) == Keywords.Select)
						FLexer.NextToken();
					else if (FLexer.PeekTokenSymbol(1) == Keywords.Cursor)
					{
						FLexer.NextToken();
						FLexer.NextToken();
					}
					return CursorDefinition();
				}
				catch (Exception E)
				{
					throw new SyntaxException(FLexer, E);
				}
			}
			finally
			{
				FLexer = null;
			}
		}
		
		public TypeSpecifier ParseTypeSpecifier(string AInput)
		{
			FLexer = new Lexer(AInput);
			try
			{
				try
				{
					return TypeSpecifier();
				}
				catch (Exception E)
				{
					throw new SyntaxException(FLexer, E);
				}
			}
			finally
			{
				FLexer = null;
			}
		}
		
		public CatalogObjectSpecifier ParseCatalogObjectSpecifier(string AInput)
		{
			FLexer = new Lexer(AInput);
			try
			{
				try
				{
					return CatalogObjectSpecifier();
				}
				catch (Exception E)
				{
					throw new SyntaxException(FLexer, E);
				}
			}
			finally
			{
				FLexer = null;
			}
		}
		
		public CreateOperatorStatement ParseOperatorDeclaration(string AInput)
		{
			FLexer = new Lexer(AInput);
			try
			{
				try
				{
					FLexer.NextToken().CheckSymbol(Keywords.Create);
					FLexer.NextToken();
					bool LSession = (FLexer[0].AsSymbol == Keywords.Session);
					if (LSession)
						FLexer.NextToken();
					FLexer[0].CheckSymbol(Keywords.Operator);
					return CreateOperatorStatement(1, 1, LSession, true);
				}
				catch (Exception E)
				{
					throw new SyntaxException(FLexer, E);
				}
			}
			finally
			{
				FLexer = null;
			}
		}
		
		public CreateAggregateOperatorStatement ParseAggregateOperatorDeclaration(string AInput)
		{
			FLexer = new Lexer(AInput);
			try
			{
				try
				{
					FLexer.NextToken().CheckSymbol(Keywords.Create);
					FLexer.NextToken();
					bool LSession = (FLexer[0].AsSymbol == Keywords.Session);
					if (LSession)
						FLexer.NextToken();
					FLexer[0].CheckSymbol(Keywords.Aggregate);
					return CreateAggregateOperatorStatement(1, 1, LSession, true);
				}
				catch (Exception E)
				{
					throw new SyntaxException(FLexer, E);
				}
			}
			finally
			{
				FLexer = null;
			}
		}
		
		/*
			BNF:
			<terminated statement> ::=
				[<statement>];
		*/
		protected Statement TerminatedStatement()
		{
			try
			{
				if (FLexer.PeekTokenSymbol(1) == Keywords.StatementTerminator)
				{
					FLexer.NextToken();
					Block LBlock = new Block();
					LBlock.SetPosition(FLexer);
					LBlock.SetEndPosition(FLexer);
					return LBlock;
				}
				else
				{
					Statement LStatement = Statement();
					FLexer.NextToken().CheckSymbol(Keywords.StatementTerminator);
					return LStatement;
				}
			}
			catch (Exception LException)
			{
				if (FMessages != null)
				{
					FMessages.Add(new SyntaxException(FLexer, LException));
					while (true)
					{
						if (FLexer[0].Type == TokenType.EOF)
							break;
						else if (FLexer[0].Type == TokenType.Symbol)
							if (FLexer[0].AsSymbol == Keywords.StatementTerminator)
								break;
							else
								FLexer.NextToken();
						else
							FLexer.NextToken();
					}
					return new EmptyStatement();
				}
				else
					throw LException;
			}
		}
		
		protected bool IsDelimiter(string AToken, string[] ADelimiters)
		{
			foreach (string LString in ADelimiters)
				if (AToken == LString)
					return true;
			return false;
		}
		
		protected Statement DelimitedBlock(string[] ADelimiters)
		{
			Block LBlock = new Block();
			LBlock.SetPosition(FLexer);
			while (FLexer[0].Type != TokenType.EOF)
			{
				if (IsDelimiter(FLexer.PeekTokenSymbol(1), ADelimiters))
					break;
				else if (FLexer.PeekTokenSymbol(1) == Keywords.StatementTerminator)
				{
					FLexer.NextToken();
					continue;
				}
				else
					LBlock.Statements.Add(TerminatedStatement());
			}
			LBlock.SetEndPosition(FLexer);
			return LBlock.Statements.Count == 1 ? LBlock.Statements[0] : LBlock;			
		}

		/*
			BNF:
			<block> ::=
				begin
					<terminated statement list>
				end
		*/        
		protected Statement Block()
        {
			return DelimitedBlock(new string[]{Keywords.End});
		}
        
        /* 
			BNF:
			<statement> ::=
				<dml statement> |
				<ddl statement> |
				<imperative statement>
				
			<dml statement> ::=
				<select statement> |
				<insert statement> |
				<update statement> |
				<delete statement>

			<ddl statement> ::=
				<create statement> |
				<alter statement> |
				<drop statement> |
				<attach statement> |
				<invoke statement> |
				<detach statement> |
				<grant statement> |
				<revoke statement> |
				<revert statement>

			<imperative statement> ::=
				<block> |
				<expression> |
				<variable declaration statement> |
				<assignment statement> |
				<exit statement> |
				<if statement> |
				<while statement> |
				<do while statement> |
				<for statement> |
				<foreach statement> |
				<repeat statement> |
				<break statement> |
				<continue statement> |
				<case statement> |
				<try finally statement> |
				<try except statement> |
				<try commit statement> |
				<raise statement>
        */        
        protected Statement Statement()
        {
			Statement LStatement;
            switch (FLexer.PeekTokenSymbol(1))
            {
                case Keywords.Select: LStatement = SelectStatement(); break;
                case Keywords.Insert: LStatement = InsertStatement(); break;
                case Keywords.Update: LStatement = UpdateStatement(); break;
                case Keywords.Delete: LStatement = DeleteStatement(); break;
                case Keywords.Create: LStatement = CreateStatement(); break;
                case Keywords.Alter: LStatement = AlterStatement(); break;
                case Keywords.Drop: LStatement = DropStatement(); break;
                case Keywords.Attach: LStatement = AttachStatement(); break;
                case Keywords.Invoke: LStatement = InvokeStatement(); break;
                case Keywords.Detach: LStatement = DetachStatement(); break;
                case Keywords.Grant: LStatement = GrantStatement(); break;
                case Keywords.Revoke: LStatement = RevokeStatement(); break;
                case Keywords.Revert: LStatement = RevertStatement(); break;
                case Keywords.Var: LStatement = VariableStatement(); break;
                case Keywords.Exit: LStatement = ExitStatement(); break;
                case Keywords.If: LStatement = IfStatement(); break;
                case Keywords.While: LStatement = WhileStatement(); break;
                case Keywords.Do: LStatement = DoWhileStatement(); break;
                case Keywords.For: LStatement = ForStatement(); break;
                case Keywords.ForEach: LStatement = ForEachStatement(); break;
                case Keywords.Repeat: LStatement = RepeatStatement(); break;
                case Keywords.Break: LStatement = BreakStatement(); break;
                case Keywords.Continue: LStatement = ContinueStatement(); break;
                case Keywords.Case: LStatement = CaseStatement(); break;
                case Keywords.Try: LStatement = TryStatement(); break;
                case Keywords.Raise: LStatement = RaiseStatement(); break;
				case Keywords.StatementTerminator: 
					LStatement = new Block(); 
					LStatement.SetPosition(FLexer);
					LStatement.SetEndPosition(FLexer);
					break;
				case Keywords.Begin:
					FLexer.NextToken();
					LStatement = new DelimitedBlock();
					LStatement.SetPosition(FLexer);
					((DelimitedBlock)LStatement).Statements.Add(Block());
					FLexer.NextToken().CheckSymbol(Keywords.End);
					LStatement.SetEndPosition(FLexer);
					break;
                default: 
					Expression LExpression = Expression();
					if (FLexer.PeekTokenSymbol(1) == Keywords.Assign)
						LStatement = AssignmentStatement(LExpression);
					else
					{
						LStatement = new ExpressionStatement(LExpression);
						LStatement.Line = LExpression.Line;
						LStatement.LinePos = LExpression.LinePos;
						LStatement.EndLine = LExpression.EndLine;
						LStatement.EndLinePos = LExpression.EndLinePos;
					}
		            break;
            }
			return LStatement;
        }

		/* 
			BNF:
            <select statement> ::=
                select <cursor definition>
        */        
        protected SelectStatement SelectStatement()
        {
			FLexer.NextToken();
			SelectStatement LSelectStatement = new SelectStatement();
			LSelectStatement.SetPosition(FLexer);
			LSelectStatement.CursorDefinition = CursorDefinition();
			LSelectStatement.SetEndPosition(FLexer);
            return LSelectStatement;
        }
        
        protected bool IsTableOperator(string ASymbol)
        {
            switch (ASymbol)
            {
                case Keywords.Where:
                case Keywords.Over:
				case Keywords.Add:
				case Keywords.Rename:
				case Keywords.Remove:
                case Keywords.Group:
                case Keywords.Return:
                case Keywords.Explode:
                case Keywords.Adorn:
                case Keywords.Redefine:
                case Keywords.Union:
                case Keywords.Intersect:
                case Keywords.Minus:
                case Keywords.Times:
                case Keywords.Divide:
                case Keywords.Left:
                case Keywords.Right:
                case Keywords.Join: 
                case Keywords.Having:
                case Keywords.Without:
                case Keywords.Lookup: return true;

                case Keywords.On:
					switch (FLexer.PeekTokenSymbol(2))
					{
						case Keywords.Insert:
						case Keywords.Update:
						case Keywords.Delete: return false;
					}
					return true;
					
				case Keywords.BeginList: 
					switch (FLexer.PeekTokenSymbol(2))
					{
						case Keywords.Transition:
						case Keywords.Constraint: 
						case Keywords.Reference: 
						case Keywords.Key: 
						case Keywords.Order: return false;
					}
					return true;
            }
            return false;
        }
        
        protected bool IsUnaryTableOperator(string ASymbol)
        {
            switch (ASymbol)
            {
                case Keywords.Where:
                case Keywords.Over:
				case Keywords.Add:
				case Keywords.Rename:
				case Keywords.Remove:
                case Keywords.Group:
                case Keywords.Return:
                case Keywords.Explode:
                case Keywords.On:
                case Keywords.Adorn:
                case Keywords.Redefine: return true;
            }
            return false;
        }
        
        protected bool IsBinaryTableOperator(string ASymbol)
        {
            switch (ASymbol)
            {
                case Keywords.Union:
                case Keywords.Intersect:
                case Keywords.Minus:
                case Keywords.Times:
                case Keywords.Divide:
                case Keywords.Left:
                case Keywords.Right:
                case Keywords.Join: 
                case Keywords.Having:
                case Keywords.Without:
                case Keywords.Lookup: return true;
            }
            return false;
        }
        
		/* 
			BNF:
            <expression> ::= 
				<modified expression term> <table operator clause list>
				
			<table operator clause> ::=
				<restrict clause> |
				<project clause> |
				<add clause> |
				<rename clause> |
				<remove clause> |
				<specify clause> |
				<aggregate clause> |
				<quota clause> |
				<explode clause> |
				<adorn clause> |
				<redefine clause> |
				<binary table operator clause> |
				<join clause> |
				<having clause> |
				<without clause> |
				<outer join clause> |
				<on clause>
		*/
        protected Expression Expression()
        {
            Expression LExpression = ModifiedExpressionTerm();
            while (IsTableOperator(FLexer.PeekTokenSymbol(1)))
            {
                switch (FLexer.PeekTokenSymbol(1))
                {
                    case Keywords.Where: LExpression = RestrictClause(LExpression); break;
                    case Keywords.Over: LExpression = ProjectClause(LExpression); break;
					case Keywords.Add: LExpression = AddClause(LExpression); break;
					case Keywords.BeginList: LExpression = SpecifyClause(LExpression); break;
					case Keywords.Rename: LExpression = RenameClause(LExpression); break;
					case Keywords.Remove: LExpression = RemoveClause(LExpression); break;
                    case Keywords.Group: LExpression = AggregateClause(LExpression); break;
                    case Keywords.Return: LExpression = QuotaClause(LExpression); break;
                    case Keywords.Explode: LExpression = ExplodeClause(LExpression); break;
                    case Keywords.On: 
						if ((FLexer.PeekTokenSymbol(2) != Keywords.Insert) && (FLexer.PeekTokenSymbol(2) != Keywords.Update) && (FLexer.PeekTokenSymbol(2) != Keywords.Delete))
							LExpression = OnClause(LExpression); 
					break;
                    case Keywords.Adorn: LExpression = AdornClause(LExpression); break;
                    case Keywords.Redefine: LExpression = RedefineClause(LExpression); break;
                    case Keywords.Union: LExpression = UnionClause(LExpression); break;
                    case Keywords.Intersect: LExpression = IntersectClause(LExpression); break;
                    case Keywords.Minus: LExpression = DifferenceClause(LExpression); break;
                    case Keywords.Times: LExpression = ProductClause(LExpression); break;
                    case Keywords.Divide: LExpression = DivideClause(LExpression); break;
                    case Keywords.Join: 
                    case Keywords.Lookup: LExpression = JoinClause(LExpression); break;
                    case Keywords.Having: LExpression = HavingClause(LExpression); break;
                    case Keywords.Without: LExpression = WithoutClause(LExpression); break;
                    case Keywords.Left:
                    case Keywords.Right: LExpression = OuterJoinClause(LExpression); break;
                }
            }
            #if CALCULESQUE
            if ((FLexer.PeekTokenSymbol(1) != String.Empty) && !IsKeyword(FLexer.PeekTokenSymbol(1)))
			{
				// This is a range variable name for the previous expression
				FLexer.NextToken();
			}
            #endif
            return LExpression;
        }
        
        protected bool IsLogicalOrTypeOperator(string AOperator)
        {
            switch (AOperator)
            {
                case Keywords.In: 
                case Keywords.Or:
                case Keywords.Xor:
                case Keywords.Like: 
                case Keywords.Matches:
                case Keywords.Between: 
                case Keywords.Is:
                case Keywords.As: return true;
                default: return false;
            }
        }
        
        /*
			BNF:
			<modified expression term> ::=
				<expression term> [<language modifiers>]
		*/
		protected Expression ModifiedExpressionTerm()
		{
			Expression LExpression = ExpressionTerm();
			LanguageModifiers(LExpression);
			LExpression.SetEndPosition(FLexer);
			return LExpression;
		}			
        
		/* 
			BNF:
            <expression term> ::= 
                <logical and expression> <logical or type operator clause list>
                
            <logical or type operator clause> ::=
				<logical ternary clause> |
				<logical binary clause> |
				<type operator clause>
				
			<logical ternary clause> ::=
				<logical ternary operator> <additive expression> and <additive expression>
				
			<logical ternary operator> ::=
				between
                
            <logical binary clause> ::=
				<logical binary operator> <logical and expression>
                
            <logical binary operator> ::=
                in | or | xor | like | matches
                
            <type operator clause> ::=
				<type operator> <type specifier>
				
			<type operator> ::=
				is | as
        */
        protected Expression ExpressionTerm()
        {
            Expression LExpression = LogicalAndExpression();
			while (IsLogicalOrTypeOperator(FLexer.PeekTokenSymbol(1)))
			{
				if (FLexer.PeekTokenSymbol(1) == Keywords.Between)
				{
					FLexer.NextToken();
					BetweenExpression LBetweenExpression = new BetweenExpression();
					LBetweenExpression.SetPosition(FLexer);
					LBetweenExpression.Expression = LExpression;
					LBetweenExpression.LowerExpression = AdditiveExpression();
					FLexer.NextToken().CheckSymbol(Keywords.And);
					LBetweenExpression.UpperExpression = AdditiveExpression();
					LExpression = LBetweenExpression;
				}
				else if (FLexer.PeekTokenSymbol(1) == Keywords.Is)
					LExpression = IsClause(LExpression);
				else if (FLexer.PeekTokenSymbol(1) == Keywords.As)
					LExpression = AsClause(LExpression);
				else
				{
					BinaryExpression LBinaryExpression = new BinaryExpression();
					LBinaryExpression.LeftExpression = LExpression;
					switch (FLexer.NextToken().AsSymbol)
					{
						case Keywords.In: LBinaryExpression.Instruction = Instructions.In; break;
						case Keywords.Or: LBinaryExpression.Instruction = Instructions.Or; break;
						case Keywords.Xor: LBinaryExpression.Instruction = Instructions.Xor; break;
						case Keywords.Like: LBinaryExpression.Instruction = Instructions.Like; break;
						case Keywords.Matches: LBinaryExpression.Instruction = Instructions.Matches; break;
					}
					LBinaryExpression.SetPosition(FLexer);
					LBinaryExpression.RightExpression = LogicalAndExpression();
					LExpression = LBinaryExpression;
				}
			}
			LExpression.SetEndPosition(FLexer);
			return LExpression;
        }
        
		/* 
			BNF:
            <logical and expression> ::= 
				<bitwise binary expression> {<logical and operator> <bitwise binary expression>}
                
            <logical and operator> ::=
                and
        */
        protected Expression LogicalAndExpression()
        {
            Expression LExpression = BitwiseBinaryExpression();
            while (FLexer.PeekTokenSymbol(1) == Keywords.And)
            {
				FLexer.NextToken();
				BinaryExpression LBinaryExpression = new BinaryExpression();
                LBinaryExpression.SetPosition(FLexer);
                LBinaryExpression.LeftExpression = LExpression;
                LBinaryExpression.Instruction = Instructions.And;
                LBinaryExpression.RightExpression = BitwiseBinaryExpression();
                LExpression = LBinaryExpression;
            }
			LExpression.SetEndPosition(FLexer);
            return LExpression;
        }
        
        protected bool IsBitwiseBinaryOperator(string AOperator)
        {
            switch (AOperator)
            {
                case Keywords.BitwiseOr:
                case Keywords.BitwiseAnd:
                case Keywords.BitwiseXor:
                case Keywords.ShiftLeft:
                case Keywords.ShiftRight: return true;
                default: return false;
            }
        }
        
		/* 
			BNF:
            <bitwise binary expression> ::= 
                <comparison expression> {<bitwise binary operator> <comparison expression>}
                
            <bitwise binary operator> ::=
                ^ | & | "|" | "<<" | ">>"
        */
        protected Expression BitwiseBinaryExpression()
        {
            Expression LExpression = ComparisonExpression();
            while (IsBitwiseBinaryOperator(FLexer.PeekTokenSymbol(1)))
            {
                BinaryExpression LBinaryExpression = new BinaryExpression();
                LBinaryExpression.LeftExpression = LExpression;
                switch (FLexer.NextToken().AsSymbol)
                {
					case Keywords.BitwiseXor: LBinaryExpression.Instruction = Instructions.BitwiseXor; break;
					case Keywords.BitwiseAnd: LBinaryExpression.Instruction = Instructions.BitwiseAnd; break;
					case Keywords.BitwiseOr: LBinaryExpression.Instruction = Instructions.BitwiseOr; break;
					case Keywords.ShiftLeft: LBinaryExpression.Instruction = Instructions.ShiftLeft; break;
					case Keywords.ShiftRight: LBinaryExpression.Instruction = Instructions.ShiftRight; break;
                }
				LBinaryExpression.SetPosition(FLexer);
				LBinaryExpression.RightExpression = ComparisonExpression();
                LExpression = LBinaryExpression;
            }
			LExpression.SetEndPosition(FLexer);
            return LExpression;
        }
        
        protected bool IsComparisonOperator(string AOperator)
        {
            switch (AOperator)
            {
                case Keywords.Equal:
                case Keywords.NotEqual:
                case Keywords.Less:
                case Keywords.Greater:
                case Keywords.InclusiveLess:
                case Keywords.InclusiveGreater: 
                case Keywords.Compare: return true;
                default: return false;
            }
        }
        
		/* 
			BNF:
            <comparison expression> ::= 
                <additive expression> {<comparison operator> <additive expression>}
                
            <comparison operator> ::=
                = | "<>" | "<" | ">" | "<=" | ">=" | ?=
        */
        protected Expression ComparisonExpression()
        {
            Expression LExpression = AdditiveExpression();
            while (IsComparisonOperator(FLexer.PeekTokenSymbol(1)))
            {
                BinaryExpression LBinaryExpression = new BinaryExpression();
                LBinaryExpression.LeftExpression = LExpression;
                switch (FLexer.NextToken().AsSymbol)
                {
					case Keywords.Equal: LBinaryExpression.Instruction = Instructions.Equal; break;
					case Keywords.NotEqual: LBinaryExpression.Instruction = Instructions.NotEqual; break;
					case Keywords.Less: LBinaryExpression.Instruction = Instructions.Less; break;
					case Keywords.Greater: LBinaryExpression.Instruction = Instructions.Greater; break;
					case Keywords.InclusiveLess: LBinaryExpression.Instruction = Instructions.InclusiveLess; break;
					case Keywords.InclusiveGreater: LBinaryExpression.Instruction = Instructions.InclusiveGreater; break;
					case Keywords.Compare: LBinaryExpression.Instruction = Instructions.Compare; break;
                }
				LBinaryExpression.SetPosition(FLexer);
				LBinaryExpression.RightExpression = AdditiveExpression();
                LExpression = LBinaryExpression;
            }
			LExpression.SetEndPosition(FLexer);
            return LExpression;
        }
       
        protected bool IsAdditiveOperator(string AOperator)
        {
            switch (AOperator)
            {
                case Keywords.Addition:
                case Keywords.Subtraction: return true;
                default: return false;
            }
        }
        
		/* 
			BNF:
            <additive expression> ::= 
                <multiplicative expression> {<additive operator> <multiplicative expression>}
                
            <additive operator> ::=
                + | -
        */
        protected Expression AdditiveExpression()
        {
            Expression LExpression = MultiplicativeExpression();
            while (IsAdditiveOperator(FLexer.PeekTokenSymbol(1)))
            {
                BinaryExpression LBinaryExpression = new BinaryExpression();
                LBinaryExpression.LeftExpression = LExpression;
                switch (FLexer.NextToken().AsSymbol)
                {
					case Keywords.Addition: LBinaryExpression.Instruction = Instructions.Addition; break;
					case Keywords.Subtraction: LBinaryExpression.Instruction = Instructions.Subtraction; break;
                }
				LBinaryExpression.SetPosition(FLexer);
				LBinaryExpression.RightExpression = MultiplicativeExpression();
                LExpression = LBinaryExpression;
            }
			LExpression.SetEndPosition(FLexer);
            return LExpression;
        }
        
        protected bool IsMultiplicativeOperator(string AOperator)
        {
            switch (AOperator)
            {
                case Keywords.Multiplication:
                case Keywords.Division:
                case Keywords.Div:
                case Keywords.Mod: return true;
                default: return false;
            }
        }

		/*                 
			BNF:
            <multiplicative expression> ::= 
                <exponent expression> {<multiplicative operator> <exponent expression>}
                
            <multiplicative operator> ::=
                * | / | div | mod
        */
        protected Expression MultiplicativeExpression()
        {
            Expression LExpression = ExponentExpression();
            while (IsMultiplicativeOperator(FLexer.PeekTokenSymbol(1)))
            {
                BinaryExpression LBinaryExpression = new BinaryExpression();
                LBinaryExpression.LeftExpression = LExpression;
                switch (FLexer.NextToken().AsSymbol)
                {
					case Keywords.Multiplication: LBinaryExpression.Instruction = Instructions.Multiplication; break;
					case Keywords.Division: LBinaryExpression.Instruction = Instructions.Division; break;
					case Keywords.Div: LBinaryExpression.Instruction = Instructions.Div; break;
					case Keywords.Mod: LBinaryExpression.Instruction = Instructions.Mod; break;
                }
				LBinaryExpression.SetPosition(FLexer);
				LBinaryExpression.RightExpression = ExponentExpression();
                LExpression = LBinaryExpression;
            }
			LExpression.SetEndPosition(FLexer);
            return LExpression;
        }

		/* 
			BNF:
            <exponent expression> ::= 
                <unary expression> {<exponent operator> <exponent expression>}
                
            <exponent operator> ::=
                **
        */
        protected Expression ExponentExpression()
        {
            Expression LExpression = UnaryExpression();
            while (FLexer.PeekTokenSymbol(1) == Keywords.Power)
            {
				FLexer.NextToken();
				BinaryExpression LBinaryExpression = new BinaryExpression();
                LBinaryExpression.SetPosition(FLexer);
                LBinaryExpression.LeftExpression = LExpression;
                LBinaryExpression.Instruction = Instructions.Power;
                LBinaryExpression.RightExpression = ExponentExpression();
                LExpression = LBinaryExpression;
            }
			LExpression.SetEndPosition(FLexer);
            return LExpression;
        }
        
        protected bool IsUnaryOperator(string AOperator)
        {
            switch (AOperator)
            {
                case Keywords.Addition: 
                case Keywords.Subtraction:
                case Keywords.BitwiseNot: 
                case Keywords.Not:
                case Keywords.Exists: return true;
                default: return false;
            }
        }

		/* 
			BNF:
			<unary expression> ::=
				{<unary operator>} <qualified factor>
				
			<unary operator> ::=
				+ | - | ~ | not | exists

        */
        protected Expression UnaryExpression()
        {
			if (IsUnaryOperator(FLexer.PeekTokenSymbol(1)))
			{
				UnaryExpression LExpression;
				switch (FLexer.NextToken().AsSymbol)
				{
					case Keywords.Addition: return UnaryExpression();
					case Keywords.Subtraction: 
						LExpression = new UnaryExpression(Instructions.Negate, UnaryExpression());
						LExpression.SetPosition(FLexer);
						LExpression.SetEndPosition(FLexer);
						return LExpression;
					case Keywords.BitwiseNot: 
						LExpression = new UnaryExpression(Instructions.BitwiseNot, UnaryExpression());
						LExpression.SetPosition(FLexer);
						LExpression.SetEndPosition(FLexer);
						return LExpression;
					case Keywords.Not: 
						LExpression = new UnaryExpression(Instructions.Not, UnaryExpression());
						LExpression.SetPosition(FLexer);
						LExpression.SetEndPosition(FLexer);
						return LExpression;
					case Keywords.Exists: 
						LExpression = new UnaryExpression(Instructions.Exists, UnaryExpression());
						LExpression.SetPosition(FLexer);
						LExpression.SetEndPosition(FLexer);
						return LExpression;
				}
			}
			return QualifiedFactor();
        }
        
		/* 
			BNF:
			<qualified factor> ::=			
				<factor>[.<qualifier expression>]{<indexer expression>[.<qualifier expression>]}
        */
        protected Expression QualifiedFactor()
        {
			Expression LExpression = Factor();

			if (FLexer.PeekTokenSymbol(1) == Keywords.Qualifier)
			{
				FLexer.NextToken();
				QualifierExpression LQualifierExpression = new QualifierExpression();
				LQualifierExpression.SetPosition(FLexer);
				LQualifierExpression.LeftExpression = LExpression;
				LQualifierExpression.RightExpression = QualifierExpression();
				LExpression = LQualifierExpression;
			}

			while (FLexer.PeekTokenSymbol(1) == Keywords.BeginIndexer)
			{
				IndexerExpression LIndexerExpression = IndexerExpression(LExpression);
				LExpression = LIndexerExpression;
				
				if (FLexer.PeekTokenSymbol(1) == Keywords.Qualifier)
				{
					FLexer.NextToken();
					QualifierExpression LQualifierExpression = new QualifierExpression();
					LQualifierExpression.SetPosition(FLexer);
					LQualifierExpression.LeftExpression = LExpression;
					LQualifierExpression.RightExpression = QualifierExpression();
					LExpression = LQualifierExpression;
				}
			}
			
			LExpression.SetEndPosition(FLexer);
			return LExpression;
        }
        
        /*
			BNF:
			<qualifier expression> ::=
				<identifier>[("("<actual parameter commalist>")") | (from <expression>)][.<qualifier expression>]
		*/
        protected Expression QualifierExpression()
        {
			Expression LExpression;			
			int LLine = FLexer[0, false].Line;
			int LLinePos = FLexer[0, false].LinePos;
			string LIdentifier = Identifier();
				
			switch (FLexer.PeekTokenSymbol(1))
			{
				case Keywords.BeginGroup: LExpression = CallExpression(LIdentifier); break;
				case Keywords.From: LExpression = ColumnExtractor(LIdentifier); break;
				default: LExpression = new IdentifierExpression(LIdentifier); break;
			}
			LExpression.Line = LLine;
			LExpression.LinePos = LLinePos;
			
			if (FLexer.PeekTokenSymbol(1) == Keywords.Qualifier)
			{
				FLexer.NextToken();
				QualifierExpression LQualifierExpression = new QualifierExpression();
				LQualifierExpression.SetPosition(FLexer);
				LQualifierExpression.LeftExpression = LExpression;
				LQualifierExpression.RightExpression = QualifierExpression();
				return LQualifierExpression;
			}

			LExpression.SetEndPosition(FLexer);
			return LExpression;
        }
        
        /*
			BNF:
				
			<indexer expression> ::=
				"["<expression term commalist> [by "{"<column name commalist>"}"]"]"
		*/
		protected IndexerExpression IndexerExpression(Expression AExpression)
		{
			FLexer.NextToken();
			D4IndexerExpression LIndexerExpression = new D4IndexerExpression();
			LIndexerExpression.SetPosition(FLexer);
			LIndexerExpression.Expression = AExpression;

			bool LHasIndexerExpressions = true;
			if (FLexer[1].Type == TokenType.Symbol)
			{
				switch (FLexer.PeekTokenSymbol(1))
				{
					case Keywords.By :
					case Keywords.EndIndexer :
						LHasIndexerExpressions = false;
					break;
				}
			}
			
			if (LHasIndexerExpressions)
			{
				bool LDone = false;
				do
				{
					LIndexerExpression.Expressions.Add(ExpressionTerm());
					
					switch (FLexer.PeekTokenSymbol(1))
					{
						case Keywords.ListSeparator : FLexer.NextToken(); break;
						default : LDone = true; break;
					}
				} while (!LDone);
			}
			
			if (FLexer.PeekTokenSymbol(1) == Keywords.By)
			{
				FLexer.NextToken();
				LIndexerExpression.HasByClause = true;
				KeyColumnList(LIndexerExpression.ByClause);
			}

			FLexer.NextToken().CheckSymbol(Keywords.EndIndexer);
			LIndexerExpression.SetEndPosition(FLexer);
			return LIndexerExpression;
		}
        
		/* 
			BNF:
			<factor> ::=
				<literal> |
				<selector expression> |
				<extractor expression> |
				([.]<identifier>[("("<actual parameter commalist>")") | (from <expression>)]) |
				("("<expression>")") |
				<if expression> |
				<case expression>
				
            <selector expression> ::=
				<table selector> |
				<row selector> |
				<cursor selector> |
				<list selector>
				
			<extractor expression> ::=
				<row extractor> |
				<column extractor> |
				<multiple column extractor>
        */
        protected Expression Factor()
        {
            if (FLexer[1].Type != TokenType.Symbol)
            {
				Expression LExpression;
				switch (FLexer.NextToken().Type)
				{
					case TokenType.Nil:
						LExpression = new ValueExpression(null, TokenType.Nil);
						LExpression.SetPosition(FLexer);
						LExpression.SetEndPosition(FLexer);
						return LExpression;
					case TokenType.Boolean: 
						LExpression = new ValueExpression(FLexer[0].AsBoolean, TokenType.Boolean); 
						LExpression.SetPosition(FLexer);
						LExpression.SetEndPosition(FLexer);
						return LExpression;
					case TokenType.Integer: 
						LExpression = new ValueExpression(FLexer[0].AsInteger, TokenType.Integer); 
						LExpression.SetPosition(FLexer);
						LExpression.SetEndPosition(FLexer);
						return LExpression;
					case TokenType.Hex:
						LExpression = new ValueExpression(FLexer[0].AsHex, TokenType.Hex);
						LExpression.SetPosition(FLexer);
						LExpression.SetEndPosition(FLexer);
						return LExpression;
					case TokenType.Decimal: 
						LExpression = new ValueExpression(FLexer[0].AsDecimal, TokenType.Decimal); 
						LExpression.SetPosition(FLexer);
						LExpression.SetEndPosition(FLexer);
						return LExpression;
					case TokenType.Float:
						LExpression = new ValueExpression(Convert.ToDecimal(FLexer[0].AsFloat), TokenType.Decimal);
						LExpression.SetPosition(FLexer);
						LExpression.SetEndPosition(FLexer);
						return LExpression;
					case TokenType.Money: 
						LExpression = new ValueExpression(FLexer[0].AsMoney, TokenType.Money);
						LExpression.SetPosition(FLexer);
						LExpression.SetEndPosition(FLexer);
						return LExpression;
					case TokenType.String: 
						LExpression = new ValueExpression(FLexer[0].AsString, TokenType.String); 
						LExpression.SetPosition(FLexer);
						LExpression.SetEndPosition(FLexer);
						return LExpression;
					#if USEISTRING
					case LexerToken.IString: 
						LExpression = new ValueExpression(FLexer.TokenIString(), LexerToken.IString);
						LExpression.SetPosition(FLexer);
						LExpression.SetEndPosition(FLexer);
						return LExpression;
					#endif
					default: throw new ParserException(ParserException.Codes.UnknownTokenType, Enum.GetName(typeof(TokenType), FLexer[0].Type));
				}
			}
            else
            {
				Expression LExpression;
                switch (FLexer.PeekTokenSymbol(1))
                {
                    case Keywords.BeginGroup:
                        FLexer.NextToken();
                        LExpression = Expression();
                        FLexer.NextToken().CheckSymbol(Keywords.EndGroup);
                        return LExpression;
                        
                    case Keywords.List: 
                    case Keywords.BeginList: return ListSelector();
                    case Keywords.Table: return TableSelector();
                    case Keywords.Row: return RowExpression();
                    case Keywords.Cursor: return CursorSelector();
                    case Keywords.If: return IfExpression();
                    case Keywords.Case: return CaseExpression();
                    #if VirtualSupport
                    case Keywords.Inherited: return InheritedExpression();
                    #endif

                    case Keywords.Parent: 
					{
						FLexer.NextToken();
						LExpression = new ExplodeColumnExpression();
						LExpression.SetPosition(FLexer);
						if (FLexer.PeekTokenSymbol(1) == Keywords.Qualifier)
							FLexer.NextToken();
						((ExplodeColumnExpression)LExpression).ColumnName = QualifiedIdentifier();
						LExpression.SetEndPosition(FLexer);
						return LExpression;
					}
                        
                    default:
                    {
						bool LIsQualifier = false;
						if (FLexer.PeekTokenSymbol(1) == Keywords.Qualifier)
						{
							LIsQualifier = true;
							FLexer.NextToken();
						}

						string LIdentifier = Identifier();
						int LLine = FLexer[0, false].Line;
						int LLinePos = FLexer[0, false].LinePos;
						if (LIsQualifier)
							LIdentifier = String.Format("{0}{1}", Keywords.Qualifier, LIdentifier);
							
						switch (FLexer.PeekTokenSymbol(1))
						{
							case Keywords.BeginGroup: LExpression = CallExpression(LIdentifier); break;
							case Keywords.From: LExpression = ColumnExtractor(LIdentifier); break;
							default: LExpression = new IdentifierExpression(LIdentifier); break;
						}
						LExpression.Line = LLine;
						LExpression.LinePos = LLinePos;
						LExpression.SetEndPosition(FLexer);
						
						return LExpression;
                    }
                }
            }
        }

        protected Expression CallExpression(string AIdentifier)
        {
			CallExpression LCallExpression = new CallExpression();
			LCallExpression.SetPosition(FLexer);
			LCallExpression.Identifier = AIdentifier;
			FLexer.NextToken().CheckSymbol(Keywords.BeginGroup);
			if (FLexer.PeekTokenSymbol(1) != Keywords.EndGroup)
			{
				bool LDone = false;
				do
				{
					LCallExpression.Expressions.Add(ActualParameter());
					if (FLexer.NextToken().Type == TokenType.Symbol)
					{
						switch (FLexer[0].AsSymbol)
						{
							case Keywords.ListSeparator: break;
							case Keywords.EndGroup: LDone = true; break;
							default: throw new ParserException(ParserException.Codes.GroupTerminatorExpected);
						}
					}
					else
						throw new ParserException(ParserException.Codes.GroupTerminatorExpected);
				}
				while (!LDone);
			}
			else
				FLexer.NextToken();
			LCallExpression.SetEndPosition(FLexer);
			return LCallExpression;
		}
		
		#if VirtualSupport
		protected Expression InheritedExpression()
		{
			FLexer.NextToken().CheckSymbol(Keywords.Inherited);
			return CallExpression(Keywords.Inherited);
		}
		#endif
        
		/* 
			BNF:
			<metadata> ::=
				[<tags>] [<tags>]
				
			<tags> ::=
				[static] tags "{"<ne tag definition commalist>"}"
				
			<tag definition> ::=
				[static | dynamic] <tag name> = <string>
				
			<tag name> ::=
				<qualified identifier>
        */
        protected void MetaData(IMetaData AMetaData)
        {
			AMetaData.MetaData = new MetaData();
			MetaDataTags(AMetaData.MetaData);
			MetaDataTags(AMetaData.MetaData);
		}
		
		public void MetaDataTags(MetaData AMetaData)
		{
			bool LIsStatic = false;
			if (FLexer.PeekTokenSymbol(1) == Keywords.Static)
			{
				LIsStatic = true;
				FLexer.NextToken();
			}
			
			if (LIsStatic || (FLexer.PeekTokenSymbol(1) == Keywords.Tags))
			{
				FLexer.NextToken().CheckSymbol(Keywords.Tags);
				FLexer.NextToken().CheckSymbol(Keywords.BeginList);
				bool LDone = false;
				do
				{
					AMetaData.Tags.Add(MetaDataTag(LIsStatic));
					if (FLexer.NextToken().Type == TokenType.Symbol)
					{
						switch (FLexer[0].AsSymbol)
						{
							case Keywords.ListSeparator: break;
							case Keywords.EndList: LDone = true; break;
							default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
						}
					}
					else
						throw new ParserException(ParserException.Codes.ListTerminatorExpected);
				} while (!LDone);
			}
        }
        
        protected Tag MetaDataTag(bool AIsStatic)
        {
			int LLine = FLexer[0, false].Line;
			int LLinePos = FLexer[0, false].LinePos;
			switch (FLexer.PeekTokenSymbol(1))
			{
				case Keywords.Static :
					AIsStatic = true;
					FLexer.NextToken();
					break;
				case Keywords.Dynamic :
					AIsStatic = false;
					FLexer.NextToken();
					break;
			}
			string LName = QualifiedIdentifier(false);
			FLexer.NextToken().CheckSymbol(Keywords.Equal);
			FLexer.NextToken().CheckType(TokenType.String);
			Tag LTag = new Tag(LName, FLexer[0].AsString, false, AIsStatic);
			return LTag;
        }		

		/* 
			BNF:
			<alter metadata> ::=
				[alter tags "{"<alter tag definition commalist>"}"]
				
			<alter tag definition> ::=
				(create <tag definition>) | 
				(alter <tag definition>) | 
				(drop <tag name>)
		*/        
        protected void AlterMetaData(IAlterMetaData AAlterMetaData, bool AIsAlter)
        {
			// This method must be able to parse from the initial alter, or the metadata keywords !!!
			if (AAlterMetaData.AlterMetaData == null)
				AAlterMetaData.AlterMetaData = new AlterMetaData();
				
			AlterMetaDataTags(AAlterMetaData.AlterMetaData, AIsAlter);
        }
        
        protected void AlterMetaDataTags(AlterMetaData AAlterMetaData, bool AIsAlter)
        {
			if (FLexer.PeekTokenSymbol(1) == Keywords.Alter)
			{
				AIsAlter = true;
				FLexer.NextToken();
			}

			if (!AIsAlter)
				return;
						
			if (AIsAlter || FLexer.PeekTokenSymbol(1) == Keywords.Tags)
			{
				FLexer.NextToken().CheckSymbol(Keywords.Tags);
				FLexer.NextToken().CheckSymbol(Keywords.BeginList);
				bool LDone = false;
				do
				{
					switch (FLexer.NextToken().AsSymbol)
					{
						case Keywords.Create: 
							AAlterMetaData.CreateTags.Add(MetaDataTag(false));
						break;
						case Keywords.Alter: 
							AAlterMetaData.AlterTags.Add(MetaDataTag(false)); 
						break;
						case Keywords.Drop: 
							int LLine = FLexer[0, false].Line;
							int LLinePos = FLexer[0, false].LinePos;
							Tag LTag = new Tag(QualifiedIdentifier(false), String.Empty, false, false);
							AAlterMetaData.DropTags.Add(LTag); 
						break;
						default: throw new ParserException(ParserException.Codes.DDLDirectiveExpected);
					}

					if (FLexer.NextToken().Type == TokenType.Symbol)
					{
						switch (FLexer[0].AsSymbol)
						{
							case Keywords.ListSeparator: break;
							case Keywords.EndList: LDone = true; break;
							default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
						}
					}
					else
						throw new ParserException(ParserException.Codes.ListTerminatorExpected);
				} while (!LDone);
			}
        }
        
        protected string CollapseQualifierExpressionToIdentifier(QualifierExpression AExpression)
        {
			string ALeftIdentifier = String.Empty;
			string ARightIdentifier = String.Empty;
			if (AExpression.LeftExpression is IdentifierExpression)
				ALeftIdentifier = ((IdentifierExpression)AExpression.LeftExpression).Identifier;
			else if (AExpression.LeftExpression is QualifierExpression)
				ALeftIdentifier = CollapseQualifierExpressionToIdentifier((QualifierExpression)AExpression.LeftExpression);
			else
				throw new ParserException(ParserException.Codes.InvalidColumnExtractorExpression);
			if (AExpression.RightExpression is IdentifierExpression)
				ARightIdentifier = ((IdentifierExpression)AExpression.RightExpression).Identifier;
			else if (AExpression.RightExpression is QualifierExpression)
				ARightIdentifier = CollapseQualifierExpressionToIdentifier((QualifierExpression)AExpression.RightExpression);
			else
				throw new ParserException(ParserException.Codes.InvalidColumnExtractorExpression);
			return String.Format("{0}{1}{2}", ALeftIdentifier, Keywords.Qualifier, ARightIdentifier);
        }
        
        protected ColumnExpression ExpressionToColumnExpression(Expression AExpression)
        {
			ColumnExpression LExpression;
			if (AExpression is IdentifierExpression)
				LExpression = new ColumnExpression(((IdentifierExpression)AExpression).Identifier);
			else if (AExpression is QualifierExpression)
				LExpression = new ColumnExpression(CollapseQualifierExpressionToIdentifier(((QualifierExpression)AExpression)));
			else
				throw new ParserException(ParserException.Codes.InvalidColumnExtractorExpression);
				
			LExpression.Line = AExpression.Line;
			LExpression.LinePos = AExpression.LinePos;
			LExpression.EndLine = AExpression.EndLine;
			LExpression.EndLinePos = AExpression.EndLinePos;
			return LExpression;
        }
        
		/* 
			BNF:
            <list selector> ::=
                [<list type specifier>]"{"<expression>"}"

			<multiple column extractor> ::=
				"{"<column name commalist>"}" from <expression> [order by "{"<order column definition commalist>"}"]
        */
        protected Expression ListSelector()
        {
            ListSelectorExpression LExpression = new ListSelectorExpression();
			if (FLexer.PeekTokenSymbol(1) == Keywords.List)
				LExpression.TypeSpecifier = ListTypeSpecifier(false);

            FLexer.NextToken().CheckSymbol(Keywords.BeginList);
			LExpression.SetPosition(FLexer);
			if (FLexer.PeekTokenSymbol(1) == Keywords.EndList)
                FLexer.NextToken();
            else
            {
                bool LDone = false;
                do
                {
                    LExpression.Expressions.Add(Expression());
                    if (FLexer.NextToken().Type == TokenType.Symbol)
                    {
                        switch (FLexer[0].AsSymbol)
                        {
                            case Keywords.ListSeparator: break;
                            case Keywords.EndList: LDone = true; break;
                            default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
                        }
                    }
                    else
                        throw new ParserException(ParserException.Codes.ListTerminatorExpected);
                } while (!LDone);
            }
            
            if (FLexer.PeekTokenSymbol(1) == Keywords.From)
            {
				if (LExpression.TypeSpecifier != null)
					throw new ParserException(ParserException.Codes.InvalidColumnExtractorExpression);
				FLexer.NextToken();
				ColumnExtractorExpression LColumnExtractorExpression = new ColumnExtractorExpression();
				LColumnExtractorExpression.SetPosition(FLexer);
				foreach (Expression LColumnExpression in LExpression.Expressions)
					LColumnExtractorExpression.Columns.Add(ExpressionToColumnExpression(LColumnExpression));
				LColumnExtractorExpression.Expression = Expression();

				if (FLexer.PeekTokenSymbol(1) == Keywords.Order)
				{
					LColumnExtractorExpression.HasByClause = true;
					FLexer.NextToken();
					FLexer.NextToken().CheckSymbol(Keywords.By);
					OrderColumnDefinitionList(LColumnExtractorExpression.OrderColumns);
				}
	            
				return LColumnExtractorExpression;
            }
            
			LExpression.SetEndPosition(FLexer);
            return LExpression;
        }

		/* 
			BNF:
            <if expression> ::=
                if <expression term> then <expression term> else <expression term>
        */        
        protected IfExpression IfExpression()
        {
            IfExpression LExpression = new IfExpression();
            FLexer.NextToken().CheckSymbol(Keywords.If);
			LExpression.SetPosition(FLexer);
			LExpression.Expression = ExpressionTerm();
            FLexer.NextToken().CheckSymbol(Keywords.Then);
            LExpression.TrueExpression = ExpressionTerm();
            FLexer.NextToken().CheckSymbol(Keywords.Else);
            LExpression.FalseExpression = ExpressionTerm();
			LExpression.SetEndPosition(FLexer);
            return LExpression;
        }
        
		/* 
			BNF:
            <case expression> ::=
                case [<expression>]
                    <ne case expression item list>
                    else <expression>
                end
                
            <case expression item> ::=
                when <expression> then <expression>
        */
        protected CaseExpression CaseExpression()
        {
            CaseExpression LCaseExpression = new CaseExpression();
            FLexer.NextToken().CheckSymbol(Keywords.Case);
			LCaseExpression.SetPosition(FLexer);
			if (!(FLexer.PeekTokenSymbol(1) == Keywords.When))
	            LCaseExpression.Expression = Expression();
            bool LDone = false;
            do
            {
                LCaseExpression.CaseItems.Add(CaseItemExpression());
                switch (FLexer.PeekTokenSymbol(1))
                {
                    case Keywords.When: break;
                    case Keywords.Else: 
                        LCaseExpression.ElseExpression = CaseElseExpression();
                        LDone = true;
                        break;
                    default: throw new ParserException(ParserException.Codes.CaseItemExpressionExpected);
                }
            }
            while (!LDone);
            FLexer.NextToken().CheckSymbol(Keywords.End);
			LCaseExpression.SetEndPosition(FLexer);
            return LCaseExpression;
        }
        
        protected CaseItemExpression CaseItemExpression()
        {
            CaseItemExpression LExpression = new CaseItemExpression();
            FLexer.NextToken().CheckSymbol(Keywords.When);
			LExpression.SetPosition(FLexer);
			LExpression.WhenExpression = Expression();
            FLexer.NextToken().CheckSymbol(Keywords.Then);
            LExpression.ThenExpression = Expression();
			LExpression.SetEndPosition(FLexer);
            return LExpression;
        }
        
        protected CaseElseExpression CaseElseExpression()
        {
			CaseElseExpression LExpression = new CaseElseExpression();
            FLexer.NextToken().CheckSymbol(Keywords.Else);
			LExpression.SetPosition(FLexer);
			LExpression.Expression = Expression();
			LExpression.SetEndPosition(FLexer);
            return LExpression;
        }
        
        protected string UnrootedIdentifier()
        {
			return UnrootedIdentifier(true);
        }
        
        protected string UnrootedIdentifier(bool AThrowIfReserved)
        {
			string LString = QualifiedIdentifier(AThrowIfReserved);
			if (LString.IndexOf(Keywords.Qualifier) == 0)	
				return LString.Substring(1);
			return LString;
        }
        
		/* 
			BNF:
            <qualified identifier> ::=
                [.]{<identifier>.}<identifier>
        */        
        protected string QualifiedIdentifier(bool AThrowIfReserved)
        {
			StringBuilder LIdentifier = new StringBuilder();
			if (FLexer.PeekTokenSymbol(1) == Keywords.Qualifier)
				LIdentifier.Append(FLexer.NextToken().AsSymbol);

			LIdentifier.Append(Identifier(AThrowIfReserved));
            while (FLexer.PeekTokenSymbol(1) == Keywords.Qualifier)
				LIdentifier.AppendFormat("{0}{1}", FLexer.NextToken().AsSymbol, Identifier(AThrowIfReserved));

            return LIdentifier.ToString();
        }
        
        protected string QualifiedIdentifier() 
        { 
			return QualifiedIdentifier(true); 
		}

        public static  bool IsKeyword(string AIdentifier)
        {
			return Keywords.Contains(AIdentifier);
        }
        
        public static bool IsReservedWord(string AIdentifier)
        {
			return ReservedWords.Contains(AIdentifier);
        }
        
        public static bool IsValidQualifiedIdentifier(string AIdentifier)
        {
			if (AIdentifier == ".")
				return false;
				
			bool LFirst = true;
			for (int LIndex = 0; LIndex < AIdentifier.Length; LIndex++)
			{
				switch (AIdentifier[LIndex])
				{
					case '.' : 
						LFirst = true;
					break;
						
					case '_' :
						LFirst = false;
					break;
					
					default :
						if ((LFirst && !Char.IsLetter(AIdentifier, LIndex)) || (!LFirst && !Char.IsLetterOrDigit(AIdentifier, LIndex)))
							return false;
						LFirst = false;
					break;
				}
			}
			return true;
        }
        
        public static bool IsValidIdentifier(string AIdentifier)
        {
			for (int LIndex = 0; LIndex < AIdentifier.Length; LIndex++)
			{
				switch (AIdentifier[LIndex])
				{
					case '_' : break;
					
					default :
						if (((LIndex == 0) && !Char.IsLetter(AIdentifier, LIndex)) || ((LIndex != 0) && !Char.IsLetterOrDigit(AIdentifier, LIndex)))
							return false;
					break;
				}
			}
			return true;
        }
        
        protected string ValidIdentifier()
        {
			FLexer.NextToken().CheckType(TokenType.Symbol);
			if (!IsValidIdentifier(FLexer[0].AsSymbol))
				throw new ParserException(ParserException.Codes.InvalidIdentifier, FLexer[0].AsSymbol);

			return FLexer[0].AsSymbol;
        }

		protected string Identifier()
		{
			return Identifier(true);
		}
		        
        protected string Identifier(bool AThrowIfReserved)
        {
			string LIdentifier = ValidIdentifier();
			if (AThrowIfReserved && IsReservedWord(LIdentifier) && !FIsInternal)
				throw new ParserException(ParserException.Codes.ReservedWordIdentifier, LIdentifier);

            return FLexer[0].AsSymbol;
        }
        
		/* 
			BNF:
			<table selector> ::=
				table [of (("{"<named type specifier commalist>"}") | <typeof type specifier>)] "{"<table selector item commalist>"}"
				
			<table selector item> ::=
				<expression> |
				<key definition>
        */
        protected TableSelectorExpression TableSelector()
        {
			TableSelectorExpression LExpression = new TableSelectorExpression();
			FLexer.NextToken().CheckSymbol(Keywords.Table);
			LExpression.SetPosition(FLexer);
			if (FLexer.PeekTokenSymbol(1) == Keywords.Of)
			{
				FLexer.NextToken();
				switch (FLexer.PeekTokenSymbol(1))
				{
					case Keywords.BeginList :
						LExpression.TypeSpecifier = new TableTypeSpecifier();
						LineInfo LLineInfo = NamedTypeSpecifierList(((TableTypeSpecifier)LExpression.TypeSpecifier).Columns);
						LExpression.TypeSpecifier.Line = LLineInfo.Line;
						LExpression.TypeSpecifier.LinePos = LLineInfo.LinePos;
					break;
					
					default : LExpression.TypeSpecifier = TypeOfTypeSpecifier(); break;
				}
			}
				
			FLexer.NextToken().CheckSymbol(Keywords.BeginList);
			if (FLexer.PeekTokenSymbol(1) == Keywords.EndList)
				FLexer.NextToken();
			else
			{
				bool LDone = false;
				do
				{
					switch (FLexer.PeekTokenSymbol(1))
					{
						case Keywords.Key: LExpression.Keys.Add(KeyDefinition()); break;
						default: LExpression.Expressions.Add(Expression()); break;
					}
						
					if (FLexer.NextToken().Type == TokenType.Symbol)
					{
						switch (FLexer[0].AsSymbol)
						{
							case Keywords.ListSeparator: break;
							case Keywords.EndList: LDone = true; break;
							default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
						}
					}
					else 
						throw new ParserException(ParserException.Codes.ListTerminatorExpected);
				} while (!LDone);
			}

			LExpression.SetEndPosition(FLexer);
			return LExpression;
        }
        
		protected Expression RowExpression()
        {
			FLexer.NextToken().CheckSymbol(Keywords.Row);
			if (FLexer.PeekTokenSymbol(1) == Keywords.From)
				return RowExtractor();
			else
				return RowSelector();
        }
        
		/* 
			BNF:
			<row selector> ::=
				row [of (("{"<named type specifier commalist>"}") | <typeof type specifier>)] "{"<named expression term commalist>"}"
				
			<named expression term> ::=
				<expression term> <column name> <metadata>
		*/
		protected RowSelectorExpression RowSelector()
		{
			RowSelectorExpression LExpression = new RowSelectorExpression();

			LineInfo LLineInfo;
			LExpression.SetPosition(FLexer);
			if (FLexer.PeekTokenSymbol(1) == Keywords.Of)
			{
				FLexer.NextToken();
				switch (FLexer.PeekTokenSymbol(1))
				{
					case Keywords.BeginList :
						LExpression.TypeSpecifier = new RowTypeSpecifier();
						LLineInfo = NamedTypeSpecifierList(((RowTypeSpecifier)LExpression.TypeSpecifier).Columns);
						LExpression.TypeSpecifier.Line = LLineInfo.Line;
						LExpression.TypeSpecifier.LinePos = LLineInfo.LinePos;
					break;
					
					default : LExpression.TypeSpecifier = TypeOfTypeSpecifier(); break;
				}
			}
				
			LLineInfo = OptionallyNamedColumnList(LExpression.Expressions);
			LExpression.Line = LLineInfo.Line;
			LExpression.LinePos = LLineInfo.LinePos;
			LExpression.SetEndPosition(FLexer);
			return LExpression;
		}
		
		/* 
			BNF:
			<cursor selector> ::=
				cursor"("<cursor definition>")"
		*/		
		protected CursorSelectorExpression CursorSelector()
		{
			CursorSelectorExpression LExpression = new CursorSelectorExpression();
			FLexer.NextToken().CheckSymbol(Keywords.Cursor);
			LExpression.SetPosition(FLexer);
			FLexer.NextToken().CheckSymbol(Keywords.BeginGroup);
			LExpression.CursorDefinition = CursorDefinition();
			FLexer.NextToken().CheckSymbol(Keywords.EndGroup);
			LExpression.SetEndPosition(FLexer);
			return LExpression;
		}
		
		/* 
			BNF:
			<cursor definition> ::=
				<expression> [<order clause> | <browse clause>] [<cursor capabilities>] [<cursor isolation>] [<cursor type>]
		*/
		// TODO: Should the on clause be put in here too?
		//<expression> [<order clause> | <browse clause>] [<on clause>] [<cursor capabilities>] [<cursor isolation>] [<cursor type>]
		protected CursorDefinition CursorDefinition()
		{
			CursorDefinition LCursorDefinition = new CursorDefinition();
			Expression LExpression = Expression();
			LCursorDefinition.Line = LExpression.Line;
			LCursorDefinition.LinePos = LExpression.LinePos;
			switch (FLexer.PeekTokenSymbol(1))
			{
				case Keywords.Order: LExpression = OrderClause(LExpression); break;
				case Keywords.Browse: LExpression = BrowseClause(LExpression); break;
			}

			/*
			if (FLexer.PeekTokenSymbol(1) == Keywords.On)
				LExpression = OnClause(LExpression);
			*/
				
			LCursorDefinition.Expression = LExpression;

			switch (FLexer.PeekTokenSymbol(1))
			{
				case Keywords.Capabilities:
				case Keywords.Isolation:
				case Keywords.Type:
					CursorCapabilities(LCursorDefinition);
					CursorIsolation(LCursorDefinition);
					CursorType(LCursorDefinition);
				break;
			}

			LCursorDefinition.SetEndPosition(FLexer);
			return LCursorDefinition;
		}
		
		/* 
			BNF:
			<cursor capabilities> ::=
				capabilities "{"<cursor capability commalist>"}"
				
			<cursor capability> ::=
				navigable | 
				backwardsnavigable | 
				bookmarkable | 
				searchable | 
				updateable | 
				truncateable | 
				countable
		*/
		protected void CursorCapabilities(CursorDefinition LExpression)
		{
			if (FLexer.PeekTokenSymbol(1) == Keywords.Capabilities)
			{
				FLexer.NextToken();
				FLexer.NextToken().CheckSymbol(Keywords.BeginList);
				do
				{
					LExpression.Capabilities = LExpression.Capabilities | (CursorCapability)Enum.Parse(typeof(CursorCapability), FLexer.NextToken().AsSymbol, true);
					if (FLexer.NextToken().Type == TokenType.Symbol)
					{
						switch (FLexer[0].AsSymbol)
						{
							case Keywords.ListSeparator: break;
							case Keywords.EndList: return;
							default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
						}
					}
					else
						throw new ParserException(ParserException.Codes.ListTerminatorExpected);
				} while (true);
			}
		}
		
		/* 
			BNF:
			<cursor isolation> ::=
				isolation (none | chaos | browse | stability | isolated)
		*/
		protected void CursorIsolation(CursorDefinition LExpression)
		{
			if (FLexer.PeekTokenSymbol(1) == Keywords.Isolation)
			{
				FLexer.NextToken();
				LExpression.Isolation = (CursorIsolation)Enum.Parse(typeof(CursorIsolation), FLexer.NextToken().AsSymbol, true);
			}
		}
		
		/*
			BNF:
			<cursor type> ::=
				type (static | dynamic)
		*/
		protected void CursorType(CursorDefinition LExpression)
		{
			if (FLexer.PeekTokenSymbol(1) == Keywords.Type)
			{
				FLexer.NextToken();
				LExpression.SpecifiesType = true;
				LExpression.CursorType = (CursorType)Enum.Parse(typeof(CursorType), FLexer.NextToken().AsSymbol, true);
			}
		}
		
		/* 
			BNF:
			<row extractor> ::=
				row from <expression>
		*/
		protected RowExtractorExpression RowExtractor()
		{
			RowExtractorExpression LExpression = new RowExtractorExpression();
			FLexer.NextToken().CheckSymbol(Keywords.From);
			LExpression.SetPosition(FLexer);
			LExpression.Expression = Expression();
			LExpression.SetEndPosition(FLexer);
			return LExpression;
		}
		
		/* 
			BNF:
			<column extractor> ::=
				<column name> from <expression> [order by "{"<order column definition commalist>"}"]
		*/
		protected Expression ColumnExtractor(string AColumnName)
		{
			ColumnExtractorExpression LExpression = new ColumnExtractorExpression();
			FLexer.NextToken().CheckSymbol(Keywords.From);
			LExpression.SetPosition(FLexer);
			LExpression.Expression = Expression();
			
			if (FLexer.PeekTokenSymbol(1) == Keywords.Order)
			{
				FLexer.NextToken();
				FLexer.NextToken().CheckSymbol(Keywords.By);
				LExpression.HasByClause = true;
				OrderColumnDefinitionList(LExpression.OrderColumns);
			}
			
			LExpression.Columns.Add(new ColumnExpression(AColumnName));
			LExpression.SetEndPosition(FLexer);
			return LExpression;
		}

		/* 
			BNF:
            <restrict clause> ::=
                where <expression term> [by <expression term>] [<language modifiers>]
        */        
        protected Expression RestrictClause(Expression AExpression)
        {
            RestrictExpression LExpression = new RestrictExpression();
            FLexer.NextToken().CheckSymbol(Keywords.Where);
			LExpression.SetPosition(FLexer);
			LExpression.Expression = AExpression;
            LExpression.Condition = ExpressionTerm();
            LanguageModifiers(LExpression);
			LExpression.SetEndPosition(FLexer);
            return LExpression;
        }

		/* 
			BNF:
            <project clause> ::=
                over "{"<column name commalist>"}" [<language modifiers>]
        */        
        protected ProjectExpression ProjectClause(Expression AExpression)
        {
            ProjectExpression LProjectExpression = new ProjectExpression();
			FLexer.NextToken().CheckSymbol(Keywords.Over);
			LProjectExpression.SetPosition(FLexer);
			LProjectExpression.Expression = AExpression;
			ColumnList(LProjectExpression.Columns);
			LanguageModifiers(LProjectExpression);
			LProjectExpression.SetEndPosition(FLexer);
            return LProjectExpression;
        }
        
        protected ColumnExpression Column()
        {
			ColumnExpression LExpression = new ColumnExpression();
			LExpression.ColumnName = QualifiedIdentifier();
			LExpression.SetPosition(FLexer);
			LExpression.SetEndPosition(FLexer);
			return LExpression;
        }

		protected void ColumnList(ColumnExpressions AColumns)
		{
		    FLexer.NextToken().CheckSymbol(Keywords.BeginList);
		    if (FLexer.PeekTokenSymbol(1) == Keywords.EndList)
		    {
				FLexer.NextToken();
				return;
		    }
		    else
		    {
				bool LDone = false;
				do
				{
					AColumns.Add(Column());
					if (FLexer.NextToken().Type == TokenType.Symbol)
					{
						switch (FLexer[0].AsSymbol)
						{
				    		case Keywords.ListSeparator: break;
				    		case Keywords.EndList: LDone = true; break;
				    		default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
						}
					}
					else
						throw new ParserException(ParserException.Codes.ListTerminatorExpected);
				} while (!LDone); 
			}
		}
		
		protected NamedColumnExpression NamedColumn()
		{
			NamedColumnExpression LExpression = new NamedColumnExpression();
			LExpression.Expression = ExpressionTerm();
			LExpression.Line = LExpression.Expression.Line;
			LExpression.LinePos = LExpression.Expression.LinePos;
			LExpression.ColumnAlias = UnrootedIdentifier();
			MetaData(LExpression);
			LExpression.SetEndPosition(FLexer);
			return LExpression;
		}
		
		protected NamedColumnExpression OptionallyNamedColumn()
		{
			NamedColumnExpression LExpression = new NamedColumnExpression();
			LExpression.Expression = ExpressionTerm();
			LExpression.Line = LExpression.Expression.Line;
			LExpression.LinePos = LExpression.Expression.LinePos;
			switch (FLexer.PeekTokenSymbol(1))
			{
				case Keywords.ListSeparator:
				case Keywords.EndList: break;
				case Keywords.Static:
				case Keywords.Dynamic:
				case Keywords.Tags: MetaData(LExpression); break;
				default: LExpression.ColumnAlias = UnrootedIdentifier(); break;
			}
			MetaData(LExpression);
			LExpression.SetEndPosition(FLexer);
			return LExpression;
		}
		
		protected void NonEmptyNamedColumnList(NamedColumnExpressions AColumns)
		{
		    FLexer.NextToken().CheckSymbol(Keywords.BeginList);
			bool LDone = false;
			do
			{
				AColumns.Add(NamedColumn());
				if (FLexer.NextToken().Type == TokenType.Symbol)
				{		
				    switch (FLexer[0].AsSymbol)
				    {
				    	case Keywords.ListSeparator: break;
				    	case Keywords.EndList: LDone = true; break;
						default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
				    }
				}
				else
				    throw new ParserException(ParserException.Codes.ListTerminatorExpected);
			} while (!LDone);
		}
		
		protected LineInfo OptionallyNamedColumnList(NamedColumnExpressions AColumns)
		{
		    FLexer.NextToken().CheckSymbol(Keywords.BeginList);
			LineInfo LResult = new LineInfo(FLexer[0, false].LinePos, FLexer[0, false].Line, -1, -1);
			if (FLexer.PeekTokenSymbol(1) == Keywords.EndList)
				FLexer.NextToken();
			else
		    {
				bool LDone = false;
				do
				{
					AColumns.Add(OptionallyNamedColumn());
					if (FLexer.NextToken().Type == TokenType.Symbol)
					{		
					    switch (FLexer[0].AsSymbol)
					    {
					    	case Keywords.ListSeparator: break;
					    	case Keywords.EndList: LDone = true; break;
							default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
					    }
					}
					else
					    throw new ParserException(ParserException.Codes.ListTerminatorExpected);
				} while (!LDone);
			}
			return LResult;
		}
		
		protected RenameColumnExpression RenameColumn()
		{
			RenameColumnExpression LExpression = new RenameColumnExpression();
			LExpression.ColumnName = QualifiedIdentifier();
			LExpression.SetPosition(FLexer);
			LExpression.ColumnAlias = UnrootedIdentifier();
			MetaData(LExpression);
			LExpression.SetEndPosition(FLexer);
			return LExpression;
		}

		protected void RenameColumnList(RenameColumnExpressions AColumns)
		{
		    FLexer.NextToken().CheckSymbol(Keywords.BeginList);
			bool LDone = false;
			do
			{
				AColumns.Add(RenameColumn());
				if (FLexer.NextToken().Type == TokenType.Symbol)
				{
				    switch (FLexer[0].AsSymbol)
				    {
				    	case Keywords.ListSeparator: break;
				    	case Keywords.EndList: LDone = true; break;
				    	default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
				    }
				}
				else
				    throw new ParserException(ParserException.Codes.ListTerminatorExpected);
			} while (!LDone); 
		}

		/* 
			BNF:
            <remove clause> ::=
                remove "{"<column name commalist>"}" [<language modifiers>]
		*/
		protected RemoveExpression RemoveClause(Expression AExpression)
		{
			RemoveExpression LRemoveExpression = new RemoveExpression();
			FLexer.NextToken().CheckSymbol(Keywords.Remove);
			LRemoveExpression.SetPosition(FLexer);
			LRemoveExpression.Expression = AExpression;
			ColumnList(LRemoveExpression.Columns);
			LanguageModifiers(LRemoveExpression);
			LRemoveExpression.SetEndPosition(FLexer);
			return LRemoveExpression;
		}

		/* 
			BNF:
			<add clause> ::=
				add "{"<ne named expression term commalist>"}" [<language modifiers>]
		*/
		protected ExtendExpression AddClause(Expression AExpression)
		{
			ExtendExpression LExpression = new ExtendExpression();
			FLexer.NextToken().CheckSymbol(Keywords.Add);
			LExpression.SetPosition(FLexer);
			LExpression.Expression = AExpression;
			NonEmptyNamedColumnList(LExpression.Expressions);
			LanguageModifiers(LExpression);
			LExpression.SetEndPosition(FLexer);
			return LExpression;
		}
		
		/*
			BNF:
			<specify clause> ::=
				"{"<optionally named expression term commalist>"}" [<language modifiers>]
				
			<optionally named expression term> ::=
				<expression term> [<column name>] <metadata>
		*/
		protected SpecifyExpression SpecifyClause(Expression AExpression)
		{
			SpecifyExpression LExpression = new SpecifyExpression();
			LExpression.Line = AExpression.Line;
			LExpression.LinePos = AExpression.LinePos;
			LExpression.Expression = AExpression;
			OptionallyNamedColumnList(LExpression.Expressions);
			LanguageModifiers(LExpression);
			LExpression.SetEndPosition(FLexer);
			return LExpression;
		}

		/* 
			BNF:
			<rename clause> ::=
				rename (("{"<ne named column name commalist>"}") | (<qualified identifier> <metadata>)) [<language modifiers>]

			<named column name> ::=
				<column name> <column name>
		*/
		protected Expression RenameClause(Expression AExpression)
		{
			int LLine = FLexer[0, false].Line;
			int LLinePos = FLexer[0, false].LinePos;
			Expression LExpression;
			FLexer.NextToken().CheckSymbol(Keywords.Rename);
			if (FLexer.PeekTokenSymbol(1) == Keywords.BeginList)
			{
				RenameExpression LRenameExpression = new RenameExpression();
				LRenameExpression.Expression = AExpression;
				RenameColumnList(LRenameExpression.Expressions);
				LExpression = LRenameExpression;
			}
			else
			{
				RenameAllExpression LRenameExpression = new RenameAllExpression();
				LRenameExpression.Expression = AExpression;
				LRenameExpression.Identifier = UnrootedIdentifier();
				MetaData(LRenameExpression);
				LExpression = LRenameExpression;
			}
			LExpression.Line = LLine;
			LExpression.LinePos = LLinePos;
			LanguageModifiers(LExpression);
			LExpression.SetEndPosition(FLexer);
			return LExpression;
		}

		/* 
			BNF:
            <aggregate clause> ::=
                group [by "{"<ne column name commalist>"}"] add "{"<ne named aggregate expression commalist>"}" [<language modifiers>]
        */        
        protected AggregateExpression AggregateClause(Expression AExpression)
        {
            AggregateExpression LAggregateExpression = new AggregateExpression();
            FLexer.NextToken().CheckSymbol(Keywords.Group);
			LAggregateExpression.SetPosition(FLexer);
			LAggregateExpression.Expression = AExpression;

            if (FLexer.PeekTokenSymbol(1) == Keywords.By)
            {
                FLexer.NextToken();
				ColumnList(LAggregateExpression.ByColumns);
			}
        
            FLexer.NextToken().CheckSymbol(Keywords.Add);
            AggregateColumnList(LAggregateExpression.ComputeColumns);
            LanguageModifiers(LAggregateExpression);
			LAggregateExpression.SetEndPosition(FLexer);
            return LAggregateExpression;
        }
        
        protected void AggregateColumnList(AggregateColumnExpressions AColumns)
        {
            FLexer.NextToken().CheckSymbol(Keywords.BeginList);
            
            do
            {
                AColumns.Add(AggregateColumn());
                if (FLexer.NextToken().Type == TokenType.Symbol)
                {
                    switch (FLexer[0].AsSymbol)
                    {
                        case Keywords.ListSeparator: break;
                        case Keywords.EndList: return;
                        default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
                    }
                }
                else
                    throw new ParserException(ParserException.Codes.ListTerminatorExpected);
            } while (true);
        }
        
		/* 
			BNF:
			<named aggregate expression> ::=
				<aggregate expression> <column name> <metadata>

            <aggregate expression> ::=
                <operator name>"("[distinct] [<column name commalist>] [order by "{"<order column definition commalist>"}"]")" [<language modifiers>]
        */        
        protected AggregateColumnExpression AggregateColumn()
        {
            AggregateColumnExpression LAggregateColumnExpression = new AggregateColumnExpression();
            LAggregateColumnExpression.AggregateOperator = QualifiedIdentifier();
			LAggregateColumnExpression.SetPosition(FLexer);
			FLexer.NextToken().CheckSymbol(Keywords.BeginGroup);
            if (FLexer.PeekTokenSymbol(1) == Keywords.Distinct)
            {
				FLexer.NextToken();
            	LAggregateColumnExpression.Distinct = true;
            }

			if (FLexer.PeekTokenSymbol(1) != Keywords.EndGroup)
			{            
				bool LDone = false;
				while (!LDone)
				{
					ColumnExpression LExpression = new ColumnExpression();
					LExpression.ColumnName = QualifiedIdentifier();
					LExpression.SetPosition(FLexer);
					LAggregateColumnExpression.Columns.Add(LExpression);
					
					switch (FLexer.NextToken().AsSymbol)
					{
						case Keywords.ListSeparator : break;
						case Keywords.Order : 
							LDone = true;
							LAggregateColumnExpression.HasByClause = true;
							FLexer.NextToken().CheckSymbol(Keywords.By);
							OrderColumnDefinitionList(LAggregateColumnExpression.OrderColumns);
							FLexer.NextToken().CheckSymbol(Keywords.EndGroup);
						break;
						case Keywords.EndGroup : LDone = true; break;
						default : throw new ParserException(ParserException.Codes.GroupTerminatorExpected);
					}
				}
			}
			else
				FLexer.NextToken();
				
			LanguageModifiers(LAggregateColumnExpression);
            LAggregateColumnExpression.ColumnAlias = UnrootedIdentifier();
            MetaData(LAggregateColumnExpression);
			LAggregateColumnExpression.SetEndPosition(FLexer);
            return LAggregateColumnExpression;
        }

		/* 
			BNF:
            <order clause> ::=
                order by 
					"{"<order column definition commalist>"}" 
					[include sequence [<column name>] <metadata>] 
					[<language modifiers>]
        */        
        protected OrderExpression OrderClause(Expression AExpression)
        {
            OrderExpression LOrderExpression = new OrderExpression();
            FLexer.NextToken().CheckSymbol(Keywords.Order);
			LOrderExpression.SetPosition(FLexer);
			LOrderExpression.Expression = AExpression;
            FLexer.NextToken().CheckSymbol(Keywords.By);
            OrderColumnDefinitionList(LOrderExpression.Columns);
			if (FLexer.PeekTokenSymbol(1) == Keywords.Include)
			{
				LOrderExpression.SequenceColumn = new IncludeColumnExpression(String.Empty);
				FLexer.NextToken();
				LOrderExpression.SequenceColumn.SetPosition(FLexer);
				FLexer.NextToken().CheckSymbol(Keywords.Sequence);
				if ((FLexer[1].Type == TokenType.Symbol) && ((FLexer.PeekTokenSymbol(1) == Keywords.Qualifier) || IsValidIdentifier(FLexer.PeekTokenSymbol(1))) && !ReservedWords.Contains(FLexer.PeekTokenSymbol(1)))
					LOrderExpression.SequenceColumn.ColumnAlias = UnrootedIdentifier();
				MetaData(LOrderExpression.SequenceColumn);
			}
			LanguageModifiers(LOrderExpression);
			LOrderExpression.SetEndPosition(FLexer);
            return LOrderExpression;
        }

		/* 
			BNF:
            <browse clause> ::=
                browse by 
					"{"<order column definition commalist>"}"
					[<language modifiers>]
        */        
        protected BrowseExpression BrowseClause(Expression AExpression)
        {
            BrowseExpression LBrowseExpression = new BrowseExpression();
            FLexer.NextToken().CheckSymbol(Keywords.Browse);
			LBrowseExpression.SetPosition(FLexer);
			LBrowseExpression.Expression = AExpression;
            FLexer.NextToken().CheckSymbol(Keywords.By);
            OrderColumnDefinitionList(LBrowseExpression.Columns);
            LanguageModifiers(LBrowseExpression);
			LBrowseExpression.SetEndPosition(FLexer);
            return LBrowseExpression;
        }

		/* 
			BNF:
            <quota clause> ::=
                return <expression term> [by "{"<order column definition commalist>"}"] [<language modifiers>]
        */        
        protected QuotaExpression QuotaClause(Expression AExpression)
        {
            QuotaExpression LQuotaExpression = new QuotaExpression();
            FLexer.NextToken().CheckSymbol(Keywords.Return);
			LQuotaExpression.SetPosition(FLexer);
			LQuotaExpression.Expression = AExpression;
			LQuotaExpression.Quota = ExpressionTerm();
			if (FLexer.PeekTokenSymbol(1) == Keywords.By)
			{
				FLexer.NextToken();
				LQuotaExpression.HasByClause = true;
				OrderColumnDefinitionList(LQuotaExpression.Columns);
			}
			LanguageModifiers(LQuotaExpression);
			LQuotaExpression.SetEndPosition(FLexer);
            return LQuotaExpression;
        }

		/* 
			BNF:
            <explode clause> ::=
                explode by <expression term> where <expression term> 
				[order by "{"<order column definition commalist>"}"]
                [include level [<column name>] <metadata>]
                [include sequence [<column name>] <metadata>]
                [<language modifiers>]
        */        
        protected ExplodeExpression ExplodeClause(Expression AExpression)
        {
            ExplodeExpression LExplodeExpression = new ExplodeExpression();
            FLexer.NextToken().CheckSymbol(Keywords.Explode);
			LExplodeExpression.SetPosition(FLexer);
			LExplodeExpression.Expression = AExpression;
            FLexer.NextToken().CheckSymbol(Keywords.By);
            LExplodeExpression.ByExpression = ExpressionTerm();
            FLexer.NextToken().CheckSymbol(Keywords.Where);
            LExplodeExpression.RootExpression = ExpressionTerm();

			if (FLexer.PeekTokenSymbol(1) == Keywords.Order)
			{
				LExplodeExpression.HasOrderByClause = true;
				FLexer.NextToken();
				FLexer.NextToken().CheckSymbol(Keywords.By);
				OrderColumnDefinitionList(LExplodeExpression.OrderColumns);
			}

            for (int LIndex = 0; LIndex < 2; LIndex++)
            {
                if (FLexer.PeekTokenSymbol(1) == Keywords.Include)
                {
                    FLexer.NextToken();
                    switch (FLexer.PeekTokenSymbol(1))
                    {
                        case Keywords.Level:
							FLexer.NextToken();
							LExplodeExpression.LevelColumn = new IncludeColumnExpression(String.Empty);
                            LExplodeExpression.LevelColumn.SetPosition(FLexer);
                            if ((FLexer[1].Type == TokenType.Symbol) && ((FLexer.PeekTokenSymbol(1) == Keywords.Qualifier) || IsValidIdentifier(FLexer.PeekTokenSymbol(1))) && !ReservedWords.Contains(FLexer.PeekTokenSymbol(1)))
								LExplodeExpression.LevelColumn.ColumnAlias = UnrootedIdentifier();
                            MetaData(LExplodeExpression.LevelColumn);
                        break;
                        
                        case Keywords.Sequence:
							FLexer.NextToken();
							LExplodeExpression.SequenceColumn = new IncludeColumnExpression(String.Empty);
                            LExplodeExpression.SequenceColumn.SetPosition(FLexer);
                            if ((FLexer[1].Type == TokenType.Symbol) && ((FLexer.PeekTokenSymbol(1) == Keywords.Qualifier) || IsValidIdentifier(FLexer.PeekTokenSymbol(1))) && !ReservedWords.Contains(FLexer.PeekTokenSymbol(1)))
								LExplodeExpression.SequenceColumn.ColumnAlias = UnrootedIdentifier();
                            MetaData(LExplodeExpression.SequenceColumn);
                        break;
                    }
                }
            }
            LanguageModifiers(LExplodeExpression);
			LExplodeExpression.SetEndPosition(FLexer);
            return LExplodeExpression;
        }

		/* 
			BNF:
            <on clause> ::=
                on <server link name>
        */        
        protected OnExpression OnClause(Expression AExpression)
        {
            OnExpression LOnExpression = new OnExpression();
            FLexer.NextToken().CheckSymbol(Keywords.On);
            LOnExpression.SetPosition(FLexer);
            LOnExpression.Expression = AExpression;
            LOnExpression.ServerName = QualifiedIdentifier();
			LOnExpression.SetEndPosition(FLexer);
            return LOnExpression;
        }

		protected IsExpression IsClause(Expression AExpression)
        {
			IsExpression LExpression = new IsExpression();
			FLexer.NextToken().CheckSymbol(Keywords.Is);
			LExpression.SetPosition(FLexer);
			LExpression.Expression = AExpression;
			LExpression.TypeSpecifier = TypeSpecifier();
			LExpression.SetEndPosition(FLexer);
			return LExpression;
        }
        
        protected AsExpression AsClause(Expression AExpression)
        {	
			AsExpression LExpression = new AsExpression();
			FLexer.NextToken().CheckSymbol(Keywords.As);
			LExpression.SetPosition(FLexer);
			LExpression.Expression = AExpression;
			LExpression.TypeSpecifier = TypeSpecifier();
			LExpression.SetEndPosition(FLexer);
			return LExpression;
        }
        
		/* 
			BNF:
			<adorn clause> ::=
				adorn ["{"<ne adorn item definition commalist>"}"] <metadata> <alter metadata> [<language modifiers>]
			
			<adorn item definition> ::=
				<adorn column> |
				<key definition> |
				(alter key "{"<column name commalist>"}" <alter metadata>) |
				(drop key "{"<column name commalist>"}") |
				<order definition> |
				(alter order "{"<order column definition commalist>"}" <alter metadata>) |
				(drop order "{"<order column definition commalist>"}") |
				<row constraint definition> |
				<reference definition> |
				(alter reference <reference name> <alter metadata>) |
				(drop <reference name>)
				
			<adorn column> ::=
				<column name> 
					<nilable definition>
					["{"<ne column definition item commalist>"}"] 
					<metadata> 
					<alter metadata>
		*/
		protected AdornExpression AdornClause(Expression AExpression)
		{
			AdornExpression LAdornExpression = new AdornExpression();
			FLexer.NextToken().CheckSymbol(Keywords.Adorn);
			LAdornExpression.SetPosition(FLexer);
			LAdornExpression.Expression = AExpression;
			if (FLexer.PeekTokenSymbol(1) == Keywords.BeginList)
			{
				FLexer.NextToken();
				bool LDone = false;
				do
				{
					switch (FLexer.PeekTokenSymbol(1))
					{
						case Keywords.Key : LAdornExpression.Keys.Add(KeyDefinition()); break;
						case Keywords.Order : LAdornExpression.Orders.Add(OrderDefinition()); break;
						case Keywords.Reference : LAdornExpression.References.Add(ReferenceDefinition()); break;

						case Keywords.Alter : 
							FLexer.NextToken(); 
							switch (FLexer.NextToken().AsSymbol)
							{
								case Keywords.Reference : LAdornExpression.AlterReferences.Add(AlterReferenceDefinition()); break;
								case Keywords.Order : LAdornExpression.AlterOrders.Add(AlterOrderDefinition()); break;
								case Keywords.Key : LAdornExpression.AlterKeys.Add(AlterKeyDefinition()); break;
								default : throw new ParserException(ParserException.Codes.UnknownAlterDirective, FLexer[0].AsSymbol);
							}
						break;

						case Keywords.Drop :
							FLexer.NextToken();
							switch (FLexer.NextToken().AsSymbol)
							{
								case Keywords.Reference : LAdornExpression.DropReferences.Add(DropReferenceDefinition()); break;
								case Keywords.Order : LAdornExpression.DropOrders.Add(DropOrderDefinition()); break;
								case Keywords.Key : LAdornExpression.DropKeys.Add(DropKeyDefinition()); break;
							}
						break;

						case Keywords.Transition :
						case Keywords.Constraint : LAdornExpression.Constraints.Add(RowConstraintDefinition()); break;
						default : LAdornExpression.Expressions.Add(AdornColumn()); break;
					}
					
					switch (FLexer.NextToken().AsSymbol)
					{
						case Keywords.ListSeparator : break;
						case Keywords.EndList : LDone = true; break;
						default : throw new ParserException(ParserException.Codes.ListTerminatorExpected);
					}
				} while (!LDone);
			}
			MetaData(LAdornExpression);
			AlterMetaData(LAdornExpression, false);
			LanguageModifiers(LAdornExpression);
			LAdornExpression.SetEndPosition(FLexer);
			return LAdornExpression;
		}
		
		protected AdornColumnExpression AdornColumn()
		{
			AdornColumnExpression LExpression = new AdornColumnExpression();
			LExpression.ColumnName = QualifiedIdentifier();
			LExpression.SetPosition(FLexer);

			if (FLexer.PeekTokenSymbol(1) == Keywords.Not)
			{
				FLexer.NextToken();
				FLexer.NextToken().CheckType(TokenType.Nil);
				LExpression.ChangeNilable = true;
				LExpression.IsNilable = false;
			}
			else if (FLexer[1].Type == TokenType.Nil)
			{
				FLexer.NextToken();
				LExpression.ChangeNilable = true;
				LExpression.IsNilable = true;
			}
			
			if (FLexer.PeekTokenSymbol(1) == Keywords.BeginList)
			{
				FLexer.NextToken();
				bool LDone = false;
				do
				{
					switch (FLexer.PeekTokenSymbol(1))
					{
						case Keywords.Default: 
							if (LExpression.Default != null)
								throw new ParserException(ParserException.Codes.DefaultDefinitionExists);
							LExpression.Default = DefaultDefinition();
						break;
						
						case Keywords.Constraint: LExpression.Constraints.Add(ConstraintDefinition()); break;
						
						default : throw new ParserException(ParserException.Codes.UnknownCreateDirective, FLexer.PeekTokenSymbol(1));
					}
					
					switch (FLexer.NextToken().AsSymbol)
					{
						case Keywords.ListSeparator : break;
						case Keywords.EndList : LDone = true; break;
						default : throw new ParserException(ParserException.Codes.ListTerminatorExpected);
					}
				} while (!LDone);
			}
			MetaData(LExpression);
			AlterMetaData(LExpression, false);
			LExpression.SetEndPosition(FLexer);
			return LExpression;
		}
		
		/* 
			BNF:
			<redefine clause> ::=
				redefine "{"<redefine column commalist>"}" [<language modifiers>]
				
			<redefine column> ::=
				<column name> := <expression term>
		*/
		protected Expression RedefineClause(Expression AExpression)
		{
			RedefineExpression LExpression = new RedefineExpression();
			FLexer.NextToken().CheckSymbol(Keywords.Redefine);
			LExpression.SetPosition(FLexer);
			LExpression.Expression = AExpression;
			FLexer.NextToken().CheckSymbol(Keywords.BeginList);
			bool LDone = false;
			do
			{
				LExpression.Expressions.Add(RedefineColumn());
				switch (FLexer.NextToken().AsSymbol)
				{
					case Keywords.ListSeparator: break;
					case Keywords.EndList: LDone = true; break;
					default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
				}
			} while (!LDone);

			LanguageModifiers(LExpression);			
			LExpression.SetEndPosition(FLexer);
			return LExpression;
		}
		
		protected NamedColumnExpression RedefineColumn()
		{
			NamedColumnExpression LExpression = new NamedColumnExpression();
			LExpression.ColumnAlias = UnrootedIdentifier();
			LExpression.SetPosition(FLexer);
			FLexer.NextToken().CheckSymbol(Keywords.Assign);
			LExpression.Expression = ExpressionTerm();
			LExpression.SetEndPosition(FLexer);
			return LExpression;
		}

		/*
			BNF:
			<language modifiers> ::=
				with "{"<ne language modifier commalist>"}"
		
			<language modifier> ::=
				<language modifier name> = <language modifier value>
				
			<language modifier name> ::=
				<qualified identifier>
				
			<language modifier value> ::=
				<string>
		*/
        protected void LanguageModifiers(Statement AStatement)
        {
			if (FLexer.PeekTokenSymbol(1) == Keywords.With)
			{
				FLexer.NextToken();
				FLexer.NextToken().CheckSymbol(Keywords.BeginList);
				AStatement.Modifiers = new LanguageModifiers();
				bool LDone = false;
				do
				{
					AStatement.Modifiers.Add(LanguageModifier());
					
					if (FLexer.NextToken().Type == TokenType.Symbol)
					{
						switch (FLexer[0].AsSymbol)
						{
							case Keywords.ListSeparator: break;
							case Keywords.EndList: LDone = true; break;
							default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
						}
					}
					else
						throw new ParserException(ParserException.Codes.ListTerminatorExpected);
				} while (!LDone);
			}
        }
        
        protected LanguageModifier LanguageModifier()
        {
			string LName = QualifiedIdentifier(false);
			FLexer.NextToken().CheckSymbol(Keywords.Equal);
			FLexer.NextToken().CheckType(TokenType.String);
			return new LanguageModifier(LName, FLexer[0].AsString);
        }
        
		/* 
			BNF:
            <binary table operator clause> ::=
                <binary table operator> <expression term> [<language modifiers>]
                
            <binary table operator> ::=
                union | intersect | minus | times | divide
        */
        protected UnionExpression UnionClause(Expression AExpression)
        {
            UnionExpression LUnionExpression = new UnionExpression();
            FLexer.NextToken().CheckSymbol(Keywords.Union);
			LUnionExpression.SetPosition(FLexer);
			LUnionExpression.LeftExpression = AExpression;
            LUnionExpression.RightExpression = ExpressionTerm();
            LanguageModifiers(LUnionExpression);
			LUnionExpression.SetEndPosition(FLexer);
            return LUnionExpression;
        }
        
        protected IntersectExpression IntersectClause(Expression AExpression)
        {
            IntersectExpression LIntersectExpression = new IntersectExpression();
            FLexer.NextToken().CheckSymbol(Keywords.Intersect);
			LIntersectExpression.SetPosition(FLexer);
			LIntersectExpression.LeftExpression = AExpression;
            LIntersectExpression.RightExpression = ExpressionTerm();
            LanguageModifiers(LIntersectExpression);
			LIntersectExpression.SetEndPosition(FLexer);
            return LIntersectExpression;
        }

        protected DifferenceExpression DifferenceClause(Expression AExpression)
        {
            DifferenceExpression LDifferenceExpression = new DifferenceExpression();
            FLexer.NextToken().CheckSymbol(Keywords.Minus);
			LDifferenceExpression.SetPosition(FLexer);
			LDifferenceExpression.LeftExpression = AExpression;
            LDifferenceExpression.RightExpression = ExpressionTerm();
            LanguageModifiers(LDifferenceExpression);
			LDifferenceExpression.SetEndPosition(FLexer);
            return LDifferenceExpression;
        }

        protected ProductExpression ProductClause(Expression AExpression)
        {
            ProductExpression LProductExpression = new ProductExpression();
			FLexer.NextToken().CheckSymbol(Keywords.Times);
			LProductExpression.SetPosition(FLexer);
            LProductExpression.LeftExpression = AExpression;
            LProductExpression.RightExpression = ExpressionTerm();
            LanguageModifiers(LProductExpression);
			LProductExpression.SetEndPosition(FLexer);
            return LProductExpression;
        }

        protected DivideExpression DivideClause(Expression AExpression)
        {
            DivideExpression LDivideExpression = new DivideExpression();
            FLexer.NextToken().CheckSymbol(Keywords.Divide);
			LDivideExpression.SetPosition(FLexer);
			LDivideExpression.LeftExpression = AExpression;
            LDivideExpression.RightExpression = ExpressionTerm();
            LanguageModifiers(LDivideExpression);
			LDivideExpression.SetEndPosition(FLexer);
            return LDivideExpression;
        }

		/* 
			BNF:
			<join clause> ::=
				(join | lookup) <conditioned expression term> [<language modifiers>]
		*/
		protected JoinExpression JoinClause(Expression AExpression)
		{
			JoinExpression LJoinExpression = new InnerJoinExpression();
			FLexer.NextToken();
			LJoinExpression.SetPosition(FLexer);
			LJoinExpression.IsLookup = (FLexer[0].AsSymbol == Keywords.Lookup);
			LJoinExpression.LeftExpression = AExpression;
			ConditionedExpressionTerm(LJoinExpression);
			LanguageModifiers(LJoinExpression);
			LJoinExpression.SetEndPosition(FLexer);
			return LJoinExpression;
		}
		
		/*
			BNF:
			<having clause> ::=
				having <conditioned expression term> [<language modifiers>]
		*/
		protected HavingExpression HavingClause(Expression AExpression)
		{
			HavingExpression LHavingExpression = new HavingExpression();
			FLexer.NextToken();
			LHavingExpression.SetPosition(FLexer);
			LHavingExpression.LeftExpression = AExpression;
			ConditionedExpressionTerm(LHavingExpression);
			LanguageModifiers(LHavingExpression);
			LHavingExpression.SetEndPosition(FLexer);
			return LHavingExpression;
		}
		
		/*
			BNF:
			<without clause> ::=
				without <conditioned expression term> [<language modifiers>]
		*/
		protected WithoutExpression WithoutClause(Expression AExpression)
		{
			WithoutExpression LWithoutExpression = new WithoutExpression();
			FLexer.NextToken();
			LWithoutExpression.SetPosition(FLexer);
			LWithoutExpression.LeftExpression = AExpression;
			ConditionedExpressionTerm(LWithoutExpression);
			LanguageModifiers(LWithoutExpression);
			LWithoutExpression.SetEndPosition(FLexer);
			return LWithoutExpression;
		}

		/*				 
			BNF:
            <outer join clause> ::=
				(left | right) (join | lookup) <conditioned expression term>
					[include rowexists [<column name>] <metadata>]
					[<language modifiers>]
        */
        protected JoinExpression OuterJoinClause(Expression AExpression)
        {
			int LLine = FLexer[0, false].Line;
			int LLinePos = FLexer[0, false].LinePos;
            FLexer.NextToken();
            OuterJoinExpression LOuterJoinExpression = null;
            switch (FLexer[0].AsSymbol)
            {
                case Keywords.Left: LOuterJoinExpression = new LeftOuterJoinExpression(); break;
                case Keywords.Right: LOuterJoinExpression = new RightOuterJoinExpression(); break;
            }
            LOuterJoinExpression.Line = LLine;
            LOuterJoinExpression.LinePos = LLinePos;
            FLexer.NextToken();
            switch (FLexer[0].AsSymbol)
            {
				case Keywords.Join: break;
				case Keywords.Lookup: LOuterJoinExpression.IsLookup = true;	break;
            }
            LOuterJoinExpression.LeftExpression = AExpression;
            ConditionedExpressionTerm(LOuterJoinExpression);
            if (FLexer.PeekTokenSymbol(1) == Keywords.Include)
            {
				FLexer.NextToken();
				LOuterJoinExpression.RowExistsColumn = new IncludeColumnExpression(String.Empty);
                LOuterJoinExpression.RowExistsColumn.SetPosition(FLexer);
                FLexer.NextToken().CheckSymbol(Keywords.RowExists);
                if ((FLexer[1].Type == TokenType.Symbol) && ((FLexer.PeekTokenSymbol(1) == Keywords.Qualifier) || IsValidIdentifier(FLexer.PeekTokenSymbol(1))) && !ReservedWords.Contains(FLexer.PeekTokenSymbol(1)))
					LOuterJoinExpression.RowExistsColumn.ColumnAlias = UnrootedIdentifier();
                MetaData(LOuterJoinExpression.RowExistsColumn);
            }
            LanguageModifiers(LOuterJoinExpression);
			LOuterJoinExpression.SetEndPosition(FLexer);
            return LOuterJoinExpression;
        }

		/* 
			BNF:
            <conditioned expression term> ::=
                <expression term> [by <expression term>]
        */        
        protected void ConditionedExpressionTerm(ConditionedBinaryTableExpression AConditionedExpression)
        {
            AConditionedExpression.RightExpression = ExpressionTerm();
            if (FLexer.PeekTokenSymbol(1) == Keywords.By)
			{
				FLexer.NextToken();
				AConditionedExpression.Condition = ExpressionTerm();
			}
        }

		/* 
			BNF:
            <insert statement> ::=
                insert [<language modifiers>] <expression> into <expression>
        */
        protected InsertStatement InsertStatement()
        {
            InsertStatement LStatement = new InsertStatement();
			FLexer.NextToken();
			LStatement.SetPosition(FLexer);
			LanguageModifiers(LStatement);
            LStatement.SourceExpression = Expression();
            FLexer.NextToken().CheckSymbol(Keywords.Into);
            LStatement.Target = Expression();
			LStatement.SetEndPosition(FLexer);
            return LStatement;
        }

		/* 
			BNF:
            <update statement> ::=
                update [<language modifiers>] <expression> 
					set "{"<ne update column commalist>"}" 
					[where <expression term>]
        */        
        protected UpdateStatement UpdateStatement()
        {
            UpdateStatement LStatement = new UpdateStatement();
			FLexer.NextToken();
			LStatement.SetPosition(FLexer);
			LanguageModifiers(LStatement);
            LStatement.Target = Expression();
            FLexer.NextToken().CheckSymbol(Keywords.Set);
            UpdateColumnList(LStatement.Columns);
            if (FLexer.PeekTokenSymbol(1) == Keywords.Where)
            {
				FLexer.NextToken();
				LStatement.Condition = ExpressionTerm();
            }
			LStatement.SetEndPosition(FLexer);
            return LStatement;
        }
        
        protected void UpdateColumnList(UpdateColumnExpressions AColumns)
        {	
			FLexer.NextToken().CheckSymbol(Keywords.BeginList);
			bool LDone = false;
			do
			{
				AColumns.Add(UpdateColumn());
				if (FLexer.NextToken().Type == TokenType.Symbol)
				{
					switch (FLexer[0].AsSymbol)
					{
						case Keywords.ListSeparator: break;
						case Keywords.EndList: return;
						default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
					}
				}
				else
					throw new ParserException(ParserException.Codes.ListTerminatorExpected);
			} while (!LDone);
        }
        
		/* 
			BNF:
            <update column> ::=
				<target> := <expression term>

			<target> ::=
				<expression>
        */
        protected UpdateColumnExpression UpdateColumn()
        {
			UpdateColumnExpression LExpression = new UpdateColumnExpression();
			LExpression.Target = Expression();
			FLexer.NextToken().CheckSymbol(Keywords.Assign);
			LExpression.SetPosition(FLexer);
			LExpression.Expression = ExpressionTerm();
			LExpression.SetEndPosition(FLexer);
			return LExpression;
        }
        
		/* 
			BNF:
            <delete statement> ::=
                delete [<language modifiers>] <expression>
        */        
        protected DeleteStatement DeleteStatement()
        {
			DeleteStatement LStatement = new DeleteStatement();
			FLexer.NextToken();
			LStatement.SetPosition(FLexer);
			LanguageModifiers(LStatement);
            LStatement.Target = Expression();
			LStatement.SetEndPosition(FLexer);
            return LStatement;
        }
 
		/* 
			BNF:
			<variable declaration statement> ::=
				var <ne variable definition commalist>
				
			<variable definition> ::=
				<qualified identifier> [: <type specifier>] [:= <expression>]
		*/
		protected Statement VariableStatement()
		{
			Block LBlock = new Block();
			FLexer.NextToken();
			LBlock.SetPosition(FLexer);
			while (true)
			{
				VariableStatement LStatement = new VariableStatement();
				LStatement.VariableName = new IdentifierExpression();
				LStatement.VariableName.Identifier = UnrootedIdentifier();
				LStatement.VariableName.SetPosition(FLexer);
				LStatement.SetPosition(FLexer);
				if (FLexer.PeekTokenSymbol(1) == Keywords.TypeSpecifier)
				{
					FLexer.NextToken();
					LStatement.TypeSpecifier = TypeSpecifier();
				}
				if (FLexer.PeekTokenSymbol(1) == Keywords.Assign)
				{
					FLexer.NextToken();
					LStatement.Expression = Expression();
				}
				LStatement.SetEndPosition(FLexer);
				LBlock.Statements.Add(LStatement);
				if (FLexer.PeekTokenSymbol(1) == Keywords.ListSeparator)
					FLexer.NextToken();
				else
				  break;
			}
			LBlock.SetEndPosition(FLexer);
			if (LBlock.Statements.Count == 1)
				return LBlock.Statements[0];
			else
				return LBlock;
		}
		
		/* 
			BNF:
			<assignment statement> ::=
				<target> := <expression>
		*/
		protected Statement AssignmentStatement(Expression AExpression)
		{
			AssignmentStatement LStatement = new AssignmentStatement();
			LStatement.Target = AExpression;
			FLexer.NextToken().CheckSymbol(Keywords.Assign);
			LStatement.SetPosition(FLexer);
			LStatement.Expression = Expression();
			LStatement.SetEndPosition(FLexer);
			return LStatement;
		}
		
		/* 
			BNF:
			<exit statement> ::=
				exit
		*/
		protected Statement ExitStatement()
		{
			Statement LStatement = new ExitStatement();
			FLexer.NextToken();
			LStatement.SetPosition(FLexer);
			LStatement.SetEndPosition(FLexer);
			return LStatement;
		}
		
		/* 
			BNF:
			<if statement> ::=
				if <expression> then
					<statement>
				[else <statement>]
		*/
		protected IfStatement IfStatement()
		{
			IfStatement LStatement = new IfStatement();
			FLexer.NextToken();
			LStatement.SetPosition(FLexer);
			LStatement.Expression = Expression();
			FLexer.NextToken().CheckSymbol(Keywords.Then);
			LStatement.TrueStatement = Statement();
			if (FLexer.PeekTokenSymbol(1) == Keywords.Else)
			{
				FLexer.NextToken();
				LStatement.FalseStatement = Statement();
			}
			LStatement.SetEndPosition(FLexer);
			return LStatement;
		}
		
		/* 
			BNF:
			<while statement> ::=
				while <expression> do <statement>
		*/
		protected WhileStatement WhileStatement()
		{
			WhileStatement LStatement = new WhileStatement();
			FLexer.NextToken();
			LStatement.SetPosition(FLexer);
			LStatement.Condition = Expression();
			FLexer.NextToken().CheckSymbol(Keywords.Do);
			LStatement.Statement = Statement();
			LStatement.SetEndPosition(FLexer);
			return LStatement;
		}
		
		/*
			BNF:
			<do while statement> ::=
				do <terminated statement list> while <expression>
		*/
		protected DoWhileStatement DoWhileStatement()
		{
			DoWhileStatement LStatement = new DoWhileStatement();
			FLexer.NextToken();
			LStatement.SetPosition(FLexer);
			LStatement.Statement = DelimitedBlock(new string[] { Keywords.While });
			FLexer.NextToken();
			LStatement.Condition = Expression();
			LStatement.SetEndPosition(FLexer);
			return LStatement;
		}
		
		/*
			BNF:
			<for statement> ::=
				for 
					[var] <qualified identifier> [: <type specifier>] 
					:= <expression> (to | downto)
					<expression> 
					[step <expression>] 
					do <statement>
		*/
		protected Statement ForStatement()
		{
			Block LBlock = new DelimitedBlock();
			FLexer.NextToken();
			LBlock.SetPosition(FLexer);
			bool LIsAllocation = false;
			if (FLexer.PeekTokenSymbol(1) == Keywords.Var)
			{
				FLexer.NextToken();
				LIsAllocation = true;
			}
			string LVariableName = UnrootedIdentifier();
			Expression LVariableExpression = new IdentifierExpression(LVariableName);
			LVariableExpression.SetPosition(FLexer);
			VariableStatement LVariableStatement = null;
			if (LIsAllocation || (FLexer.PeekTokenSymbol(1) == Keywords.TypeSpecifier))
			{
				LVariableStatement = new VariableStatement();
				LVariableStatement.SetPosition(FLexer);
				LVariableStatement.VariableName = new IdentifierExpression(LVariableName);
				LVariableStatement.VariableName.SetPosition(FLexer);
				if (FLexer.PeekTokenSymbol(1) == Keywords.TypeSpecifier)
				{
					FLexer.NextToken();
					LVariableStatement.TypeSpecifier = TypeSpecifier();
				}
				LVariableStatement.SetEndPosition(FLexer);
				LBlock.Statements.Add(LVariableStatement);
			}

			FLexer.NextToken().CheckSymbol(Keywords.Assign);
			AssignmentStatement LAssignmentStatement = new AssignmentStatement();
			LAssignmentStatement.SetPosition(FLexer);
			LAssignmentStatement.Target = LVariableExpression;
			LAssignmentStatement.Expression = Expression();
			if ((LVariableStatement != null) && (LVariableStatement.TypeSpecifier == null))
				LVariableStatement.TypeSpecifier = new TypeOfTypeSpecifier(LAssignmentStatement.Expression);
			LAssignmentStatement.SetEndPosition(FLexer);
			LBlock.Statements.Add(LAssignmentStatement);
			
			bool LIsPositive;
			switch (FLexer.NextToken().AsSymbol)
			{
				case Keywords.To: LIsPositive = true; break;
				case Keywords.Downto: LIsPositive = false; break;
				default : throw new LexerException(LexerException.Codes.SymbolExpected, String.Format("{0} or {1}", Keywords.To, Keywords.Downto));
			}
			Expression LFinalExpression = Expression();
			Expression LStepExpression = null;
			if (FLexer.PeekTokenSymbol(1) == Keywords.Step)
			{
				FLexer.NextToken();
				LStepExpression = Expression();
			}
			else
				LStepExpression = new ValueExpression(1, TokenType.Integer);
			FLexer.NextToken().CheckSymbol(Keywords.Do);
			WhileStatement LWhileStatement = new WhileStatement();
			LWhileStatement.Condition = new BinaryExpression(new IdentifierExpression(LVariableName), LIsPositive ? Instructions.InclusiveLess : Instructions.InclusiveGreater, LFinalExpression);
			Statement LIterationStatement = Statement();
			Statement LIncrementStatement = new AssignmentStatement(new IdentifierExpression(LVariableName), new BinaryExpression(new IdentifierExpression(LVariableName), LIsPositive ? Instructions.Addition : Instructions.Subtraction, LStepExpression));
			TryFinallyStatement LIterationBlock = new TryFinallyStatement();
			LIterationBlock.TryStatement = LIterationStatement;
			LIterationBlock.FinallyStatement = LIncrementStatement;
			LIterationStatement = LIterationBlock;
			LWhileStatement.Statement = LIterationStatement;
			LBlock.Statements.Add(LWhileStatement);
			LBlock.SetEndPosition(FLexer);
			return LBlock;
		}
		
		/*
			BNF:
			<foreach statement> ::=
				foreach row | ([var] <qualified identifier>)
					in <cursor definition> 
					do <statement>
		*/
		
		/*
			#if <cursor definition> is cursor valued ::=	
				begin
					var LCursor := <expression>;
					try
						#if var is specified
						var <qualified identifier> : typeof(LCursor.Select());
						#end
						while LCursor.Next() do
						begin
							#if <qualified identifier> is specified
							<qualified identifier> := LCursor.Select();
							#else
							#stackpush LCursor.Select()
							#end
							<statement>;
							#if <qualified identifier> is not specified
							#stackpop
							#end
						end;
					finally
						LCursor.Close();
					end;
				end;
			#else
				begin
					#if var is specified
					var <qualified identifier> : typeof(<expression>[0]);
					#end
					for var LIndex := 1 to <expression>.Count() do
					begin
						<qualified identifier> := <expression>[LIndex];
						<statement>;
					end;
				end;
			#end
		*/
		protected Statement ForEachStatement()
		{
			ForEachStatement LStatement = new ForEachStatement();
			FLexer.NextToken();
			LStatement.SetPosition(FLexer);
			switch (FLexer.PeekTokenSymbol(1))
			{
				case Keywords.Row : FLexer.NextToken(); break;
				case Keywords.Var :
					FLexer.NextToken();
					LStatement.VariableName = UnrootedIdentifier();
					LStatement.IsAllocation = true;
				break;
				
				default: LStatement.VariableName = UnrootedIdentifier(); break;
			}
			
			FLexer.NextToken().CheckSymbol(Keywords.In);
			LStatement.Expression = CursorDefinition();
			FLexer.NextToken().CheckSymbol(Keywords.Do);
			LStatement.Statement = Statement();
			LStatement.SetEndPosition(FLexer);
			return LStatement;
		}
		
		/*
			BNF:
			<repeat statement> ::=
				repeat <terminated statement list> until <condition>
				
			<condition> ::=
				<expression>
		*/
		protected DoWhileStatement RepeatStatement()
		{
			DoWhileStatement LDoWhileStatement = new DoWhileStatement();
			FLexer.NextToken();
			LDoWhileStatement.SetPosition(FLexer);
			LDoWhileStatement.Statement = DelimitedBlock(new string[] { Keywords.Until });
			FLexer.NextToken();
			LDoWhileStatement.Condition = new UnaryExpression(Instructions.Not, Expression());
			LDoWhileStatement.SetEndPosition(FLexer);
			return LDoWhileStatement;
		}
		
		/* 
			BNF:
			<break statement> ::=
				break
		*/
		protected BreakStatement BreakStatement()
		{
			BreakStatement LStatement = new BreakStatement();
			FLexer.NextToken();
			LStatement.SetPosition(FLexer);
			LStatement.SetEndPosition(FLexer);
			return LStatement;
		}
		
		/* 
			BNF:
			<continue statement> ::=
				continue
		*/
		protected ContinueStatement ContinueStatement()
		{
			ContinueStatement LStatement = new ContinueStatement();
			FLexer.NextToken();
			LStatement.SetPosition(FLexer);
			LStatement.SetEndPosition(FLexer);
			return LStatement;
		}
		
		/*
			BNF:
			<case statement> ::=
				case [<expression>]
					<ne case statement item list>
					[else <terminated statement>]
				end
				
			<case statement item> ::=
				when <expression> then <terminated statement>
		*/
        protected CaseStatement CaseStatement()
        {
            CaseStatement LCaseStatement = new CaseStatement();
            FLexer.NextToken().CheckSymbol(Keywords.Case);
			LCaseStatement.SetPosition(FLexer);
			if (!(FLexer.PeekTokenSymbol(1) == Keywords.When))
	            LCaseStatement.Expression = Expression();
            bool LDone = false;
            do
            {
                LCaseStatement.CaseItems.Add(CaseItemStatement());
                switch (FLexer.PeekTokenSymbol(1))
                {
                    case Keywords.When: break;
                    case Keywords.Else:
						FLexer.NextToken();
						LCaseStatement.ElseStatement = TerminatedStatement(); 
                        LDone = true;
                    break;
                    case Keywords.End:
						LDone = true;
					break;
                    default: throw new ParserException(ParserException.Codes.CaseItemExpressionExpected);
                }
            }
            while (!LDone);
            FLexer.NextToken().CheckSymbol(Keywords.End);
			LCaseStatement.SetEndPosition(FLexer);
            return LCaseStatement;
        }
        
        protected CaseItemStatement CaseItemStatement()
        {
            CaseItemStatement LStatement = new CaseItemStatement();
            FLexer.NextToken().CheckSymbol(Keywords.When);
			LStatement.SetPosition(FLexer);
			LStatement.WhenExpression = Expression();
            FLexer.NextToken().CheckSymbol(Keywords.Then);
            LStatement.ThenStatement = TerminatedStatement();
			LStatement.SetEndPosition(FLexer);
            return LStatement;
        }
		
		/* 
			BNF:
			<try finally statement> ::=
				try
					<terminated statement list>
				finally
					<terminated statement list>
				end
			
			<try except statement> ::=
				try
					<terminated statement list>
				except
					<terminated statement list> | <exception handler list>
				end
				
			<exception handler> ::=
				on [<exception variable> :] <type specifier> do 
					<terminated statement>

			<exception variable> ::=
				<qualified identifier>
				
			<try commit statement> ::=
				try
					<terminated statement list>
				commit
		*/
		protected Statement TryStatement()
		{
			FLexer.NextToken();
			int LLine = FLexer[0, false].Line;
			int LLinePos = FLexer[0, false].LinePos;
			Statement LTryStatement = DelimitedBlock(new string[] { Keywords.Finally, Keywords.Except, Keywords.Commit });
			switch (FLexer.NextToken().AsSymbol)
			{
				case Keywords.Finally:
					TryFinallyStatement LFinallyStatement = new TryFinallyStatement();
					LFinallyStatement.Line = LLine;
					LFinallyStatement.LinePos = LLinePos;
					LFinallyStatement.TryStatement = LTryStatement;
					LFinallyStatement.FinallyStatement = Block();
					FLexer.NextToken().CheckSymbol(Keywords.End);
					LFinallyStatement.SetEndPosition(FLexer);
					return LFinallyStatement;

				case Keywords.Except:
					TryExceptStatement LExceptStatement = new TryExceptStatement();
					LExceptStatement.Line = LLine;
					LExceptStatement.LinePos = LLinePos;
					LExceptStatement.TryStatement = LTryStatement;
						
					if (FLexer.PeekTokenSymbol(1) == Keywords.On)
					{
						string LIdentifier;
						while (true)
						{
							FLexer.NextToken().CheckSymbol(Keywords.On);
							LLine = FLexer[0, false].Line;
							LLinePos = FLexer[0, false].LinePos;
							LIdentifier = UnrootedIdentifier();
							GenericErrorHandler LErrorHandler;
							if (FLexer.PeekTokenSymbol(1) == Keywords.TypeSpecifier)
							{
								FLexer.NextToken();
								LErrorHandler = new ParameterizedErrorHandler(QualifiedIdentifier(), LIdentifier);
							}
							else
								LErrorHandler = new SpecificErrorHandler(LIdentifier);
							LErrorHandler.Line = LLine;
							LErrorHandler.LinePos = LLinePos;
							FLexer.NextToken().CheckSymbol(Keywords.Do);
							
							LErrorHandler.Statement = TerminatedStatement();
							LExceptStatement.ErrorHandlers.Add(LErrorHandler);
							
							if (FLexer.PeekTokenSymbol(1) == Keywords.End)
								break;
						}
						FLexer.NextToken();
					}
					else if (FLexer.PeekTokenSymbol(1) == Keywords.End)
					{
						FLexer.NextToken();
					}
					else
					{
						LExceptStatement.ErrorHandlers.Add(new GenericErrorHandler(Block()));
						FLexer.NextToken();
					}

					LExceptStatement.SetEndPosition(FLexer);
					return LExceptStatement;
					
				case Keywords.Commit:
					DelimitedBlock LBlock = new DelimitedBlock();
					LBlock.Line = LLine;
					LBlock.LinePos = LLinePos;
					LBlock.Statements.Add(new ExpressionStatement(new CallExpression("BeginTransaction", new Expression[]{})));
					TryExceptStatement LCommitStatement = new TryExceptStatement();
					LCommitStatement.Line = LLine;
					LCommitStatement.LinePos = LLinePos;
					Block LTryBlock = new Block();
					LTryBlock.SetPosition(FLexer);
					LTryBlock.Statements.Add(LTryStatement);
					LTryBlock.Statements.Add(new ExpressionStatement(new CallExpression("CommitTransaction", new Expression[]{})));
					LCommitStatement.TryStatement = LTryBlock;
					DelimitedBlock LErrorBlock = new DelimitedBlock();
					LErrorBlock.SetPosition(FLexer);
					LErrorBlock.Statements.Add(new ExpressionStatement(new CallExpression("RollbackTransaction", new Expression[]{})));
					LErrorBlock.Statements.Add(new RaiseStatement());
					LCommitStatement.ErrorHandlers.Add(new GenericErrorHandler(LErrorBlock));
					LBlock.Statements.Add(LCommitStatement);
					LBlock.SetEndPosition(FLexer);
					return LBlock;
					
				default: throw new ParserException(ParserException.Codes.TryStatementExpected);
			}
		}
		
		/* 
			BNF:
			<raise statement> ::=
				raise [<expression>]
		*/
		protected Statement RaiseStatement()
		{
			RaiseStatement LStatement = new RaiseStatement();
			FLexer.NextToken();
			LStatement.SetPosition(FLexer);
			if (FLexer.PeekTokenSymbol(1) != Keywords.StatementTerminator)
				LStatement.Expression = Expression();
			LStatement.SetEndPosition(FLexer);
			return LStatement;
		}

		/*
			BNF:
			<actual parameter> ::=
				[var] <expression>
		*/		
		protected Expression ActualParameter()
		{
			Expression LExpression;
			switch (FLexer.PeekTokenSymbol(1))
			{
				case Keywords.Var:
					FLexer.NextToken();
					LExpression = new ParameterExpression();
					LExpression.SetPosition(FLexer);
					((ParameterExpression)LExpression).Modifier = Modifier.Var;
					((ParameterExpression)LExpression).Expression = Expression();
				break;
					
				default:
					LExpression = Expression();
				break;
			}

			LExpression.SetEndPosition(FLexer);
			return LExpression;
		}
		
		/* 
			BNF:
            <create statement> ::=
                <create table statement> |
                <create view statement> |
                <create constraint statement> |
                <create reference statement> |
                <create scalar type statement> |
                <create operator statement> |
                <create aggregate operator statement> |
                <create device statement> |
				<create server link statement> |
                <create sort statement> |
                <create conversion statement> |
                <create role statement> |
                <create right statement>
		*/
        protected Statement CreateStatement()
        {
			FLexer.NextToken();
			int LLine = FLexer[0, false].Line;
			int LLinePos = FLexer[0, false].LinePos;
			switch (FLexer.NextToken().AsSymbol)
			{
				case Keywords.Table: return CreateTableStatement(LLine, LLinePos, false);
				case Keywords.View: return CreateViewStatement(LLine, LLinePos, false);
				case Keywords.Constraint: return CreateConstraintStatement(LLine, LLinePos, false);
				case Keywords.Reference: return CreateReferenceStatement(LLine, LLinePos, false);
				case Keywords.Operator: return CreateOperatorStatement(LLine, LLinePos, false, false);
				case Keywords.Aggregate: return CreateAggregateOperatorStatement(LLine, LLinePos, false, false);
				case Keywords.Session:
					switch (FLexer.NextToken().AsSymbol)
					{
						case Keywords.Table: return CreateTableStatement(LLine, LLinePos, true);
						case Keywords.View: return CreateViewStatement(LLine, LLinePos, true);
						case Keywords.Constraint: return CreateConstraintStatement(LLine, LLinePos, true);
						case Keywords.Reference: return CreateReferenceStatement(LLine, LLinePos, true);
						case Keywords.Operator: return CreateOperatorStatement(LLine, LLinePos, true, false);
						case Keywords.Aggregate: return CreateAggregateOperatorStatement(LLine, LLinePos, true, false);
						default : throw new ParserException(ParserException.Codes.UnknownCreateDirective, FLexer[0].AsSymbol);
					}
				case Keywords.Type: return CreateScalarTypeStatement(LLine, LLinePos);
				case Keywords.Server: return CreateServerStatement(LLine, LLinePos);
				case Keywords.Device: return CreateDeviceStatement(LLine, LLinePos);
				case Keywords.Sort: return CreateSortStatement(LLine, LLinePos);
				case Keywords.Conversion: return CreateConversionStatement(LLine, LLinePos);
				case Keywords.Role: return CreateRoleStatement(LLine, LLinePos);
				case Keywords.Right: return CreateRightStatement(LLine, LLinePos);
				default: throw new ParserException(ParserException.Codes.UnknownCreateDirective, FLexer[0].AsSymbol);
			}
        }
        
		/* 
			BNF:
            <create table statement> ::=
                create [session] table <table name> 
					[in <device name>]
					(
						(from <expression>) |
						("{"<table definition item commalist>"}")
					)
					<metadata>
                
            <table name> ::=
				<qualified identifier>
				
			<device name> ::=
				<qualified identifier>
        */
        protected CreateTableStatement CreateTableStatement(int ALine, int ALinePos, bool AIsSession)
        {
			CreateTableStatement LStatement = new CreateTableStatement();
			LStatement.Line = ALine;
			LStatement.LinePos = ALinePos;
			LStatement.IsSession = AIsSession;
			LStatement.TableVarName = QualifiedIdentifier();
			if (FLexer.PeekTokenSymbol(1) == Keywords.In)
			{
				FLexer.NextToken().CheckSymbol(Keywords.In);
				LStatement.DeviceName = new IdentifierExpression(QualifiedIdentifier());
			}
			if (FLexer.PeekTokenSymbol(1) == Keywords.From)
			{
				FLexer.NextToken();
				LStatement.FromExpression = Expression();
			}
			else
				CreateTableDefinitionList(LStatement);
			MetaData(LStatement);
			LStatement.SetEndPosition(FLexer);
			return LStatement;
        }

		/* 
			BNF:
            <table definition item> ::=
                <column definition> |
                <row constraint definition> |
                <key definition> |
                <reference definition> |
                <order definition>
		*/        
        protected void CreateTableDefinitionList(CreateTableStatement AStatement)
        {
			FLexer.NextToken().CheckSymbol(Keywords.BeginList);
			if (FLexer.PeekTokenSymbol(1) == Keywords.EndList)
			{
				FLexer.NextToken();
				return;
			}
			
			do
			{
				switch (FLexer.PeekTokenSymbol(1))
				{
					case Keywords.Transition :
					case Keywords.Constraint : AStatement.Constraints.Add(RowConstraintDefinition()); break;
					case Keywords.Reference : AStatement.References.Add(ReferenceDefinition()); break;
					case Keywords.Key : AStatement.Keys.Add(KeyDefinition()); break;
					case Keywords.Order : AStatement.Orders.Add(OrderDefinition()); break;
					default: AStatement.Columns.Add(ColumnDefinition()); break;
				}
				
				switch (FLexer.NextToken().AsSymbol)
				{
					case Keywords.ListSeparator: break;
					case Keywords.EndList: return;
					default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
				}
			} while (true);
        }

		/*         
			BNF:
            <column definition> ::=
                <column name> : <type specifier>
					<nilable definition>
					["{"<ne column definition item commalist>"}"]
					<metadata>
					
			<column definition item> ::=
				<default definition> |
				<constraint definition> |
				<nilable definition>
				
            <column name> ::=
				<qualified identifier>
				
			<nilable definition> ::=
				[[not] nil]                
		*/
		protected ColumnDefinition ColumnDefinition()
		{
			ColumnDefinition LDefinition = new ColumnDefinition();
			LDefinition.ColumnName = UnrootedIdentifier();
			LDefinition.SetPosition(FLexer);
			FLexer.NextToken().CheckSymbol(Keywords.TypeSpecifier);
			LDefinition.TypeSpecifier = TypeSpecifier();
			
			if (FLexer.PeekTokenSymbol(1) == Keywords.Not)
			{
				FLexer.NextToken();
				FLexer.NextToken().CheckType(TokenType.Nil);
				LDefinition.IsNilable = false;
			}
			else if (FLexer[1].Type == TokenType.Nil)
			{
				FLexer.NextToken();
				LDefinition.IsNilable = true;
			}
			
			if (FLexer.PeekTokenSymbol(1) == Keywords.BeginList)
			{
				FLexer.NextToken();
				bool LDone = false;
				do
				{
					if (FLexer[1].Type == TokenType.Nil)
					{
						FLexer.NextToken();
						LDefinition.IsNilable = true;
					}
					else
					{
						switch (FLexer.PeekTokenSymbol(1))
						{
							case Keywords.Default:
								if (LDefinition.Default != null)
									throw new ParserException(ParserException.Codes.DefaultDefinitionExists);
								LDefinition.Default = DefaultDefinition();
							break;

							case Keywords.Constraint: 
								LDefinition.Constraints.Add(ConstraintDefinition()); 
							break;

							case Keywords.Not :
								FLexer.NextToken();
								FLexer.NextToken().CheckType(TokenType.Nil);
								LDefinition.IsNilable = false;
							break;

							default: throw new ParserException(ParserException.Codes.UnknownCreateDirective, FLexer.PeekTokenSymbol(1));
						}
					}
					
					switch (FLexer.NextToken().AsSymbol)
					{
						case Keywords.ListSeparator: break;
						case Keywords.EndList: LDone = true; break;
						default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
					}
				} while (!LDone);
			}

			MetaData(LDefinition);
			LDefinition.SetEndPosition(FLexer);
			return LDefinition;
		}
		
		/* 
			BNF:
            <key definition> ::=
                key "{"<column name commalist>"}" <metadata>
		*/
		protected KeyDefinition KeyDefinition()
		{
			KeyDefinition LDefinition = new KeyDefinition();
			FLexer.NextToken().CheckSymbol(Keywords.Key);
			LDefinition.SetPosition(FLexer);
			KeyColumnList(LDefinition.Columns);
			MetaData(LDefinition);
			LDefinition.SetEndPosition(FLexer);
			return LDefinition;
		}
		
		protected void KeyColumnList(KeyColumnDefinitions AColumns)
		{
			FLexer.NextToken().CheckSymbol(Keywords.BeginList);
			if (FLexer.PeekTokenSymbol(1) == Keywords.EndList)
				FLexer.NextToken();
			else
			{
				KeyColumnDefinition LDefinition;
				do
				{
					LDefinition = new KeyColumnDefinition();
					LDefinition.ColumnName = QualifiedIdentifier();
					LDefinition.SetPosition(FLexer);
					AColumns.Add(LDefinition);
					switch (FLexer.NextToken().AsSymbol)
					{
						case Keywords.ListSeparator: break;
						case Keywords.EndList: return;
						default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
					}
				} while (true);
			}
		}
		
		/* 
			BNF:
			<reference definition> ::=
			    reference <reference name> 
			    "{"<column name commalist>"}" 
			    <references definition>
			    <metadata>
			    
			<reference name> ::=
				<qualified identifier>
		*/
		protected ReferenceDefinition ReferenceDefinition()
		{
			ReferenceDefinition LDefinition = new ReferenceDefinition();
			FLexer.NextToken().CheckSymbol(Keywords.Reference);
			LDefinition.SetPosition(FLexer);
			LDefinition.ReferenceName = QualifiedIdentifier();
			ReferenceColumnList(LDefinition.Columns);
			LDefinition.ReferencesDefinition = ReferencesDefinition();
			MetaData(LDefinition);
			LDefinition.SetEndPosition(FLexer);
			return LDefinition;
		}
		
		protected void UpdateReferenceAction(ReferencesDefinition ADefinition)
		{
			if (FLexer.PeekTokenSymbol(1) == Keywords.Update)
			{
				FLexer.NextToken();
				switch (FLexer.NextToken().AsSymbol)
				{
					case Keywords.Require: ADefinition.UpdateReferenceAction = ReferenceAction.Require; break;
					case Keywords.Cascade: ADefinition.UpdateReferenceAction = ReferenceAction.Cascade; break;
					case Keywords.Clear: ADefinition.UpdateReferenceAction = ReferenceAction.Clear; break;
					case Keywords.Set: 
						ADefinition.UpdateReferenceAction = ReferenceAction.Set;
						FLexer.NextToken().CheckSymbol(Keywords.BeginList);
						if (FLexer.PeekTokenSymbol(1) == Keywords.EndList)
							FLexer.NextToken();
						else
						{
							bool LDone = false;
							while (!LDone)
							{
								ADefinition.UpdateReferenceExpressions.Add(Expression());
								switch (FLexer.NextToken().AsSymbol)
								{
									case Keywords.ListSeparator: break;
									case Keywords.EndList: LDone = true; break;
									default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
								}
							}
						}
					break;
					default: throw new ParserException(ParserException.Codes.UnknownReferenceAction, FLexer[0].AsSymbol);
				}
			}
		}
		
		protected void DeleteReferenceAction(ReferencesDefinition ADefinition)
		{
			if (FLexer.PeekTokenSymbol(1) == Keywords.Delete)
			{
				FLexer.NextToken();
				switch (FLexer.NextToken().AsSymbol)
				{
					case Keywords.Require: ADefinition.DeleteReferenceAction = ReferenceAction.Require; break;
					case Keywords.Cascade: ADefinition.DeleteReferenceAction = ReferenceAction.Cascade; break;
					case Keywords.Clear: ADefinition.DeleteReferenceAction = ReferenceAction.Clear; break;
					case Keywords.Set:
						ADefinition.DeleteReferenceAction = ReferenceAction.Set;
						FLexer.NextToken().CheckSymbol(Keywords.BeginList);
						if (FLexer.PeekTokenSymbol(1) == Keywords.EndList)
							FLexer.NextToken();
						else
						{
							bool LDone = false;
							while (!LDone)
							{
								ADefinition.DeleteReferenceExpressions.Add(Expression());
								switch (FLexer.NextToken().AsSymbol)
								{
									case Keywords.ListSeparator: break;
									case Keywords.EndList: LDone = true; break;
									default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
								}
							}
						}
					break;
					default: throw new ParserException(ParserException.Codes.UnknownReferenceAction, FLexer[0].AsSymbol);
				}
			}
		}

		/* 
			BNF:
			<references definition> ::=
			    references <tablevar name> "{"<column name commalist>"}" 
			    [update (require | cascade | clear | set "{"<expression commalist>"}")] 
			    [delete (require | cascade | clear | set "{"<expression commalist>"}")]
			    
			<tablevar name> ::=
				<qualified identifier>
		*/		
		protected ReferencesDefinition ReferencesDefinition()
		{
			ReferencesDefinition LDefinition = new ReferencesDefinition();
			FLexer.NextToken().CheckSymbol(Keywords.References);
			LDefinition.SetPosition(FLexer);
			LDefinition.TableVarName = QualifiedIdentifier();
			ReferenceColumnList(LDefinition.Columns);
			UpdateReferenceAction(LDefinition);
			DeleteReferenceAction(LDefinition);
			LDefinition.SetEndPosition(FLexer);
			return LDefinition;
		}
		
		protected void ReferenceColumnList(ReferenceColumnDefinitions AColumns)
		{
			FLexer.NextToken().CheckSymbol(Keywords.BeginList);
			if (FLexer.PeekTokenSymbol(1) == Keywords.EndList)
				FLexer.NextToken();
			else
			{
				ReferenceColumnDefinition LDefinition;
				do
				{
					LDefinition = new ReferenceColumnDefinition();
					LDefinition.ColumnName = QualifiedIdentifier();
					LDefinition.SetPosition(FLexer);
					AColumns.Add(LDefinition);
					switch (FLexer.NextToken().AsSymbol)
					{
						case Keywords.ListSeparator: break;
						case Keywords.EndList: return;
						default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
					}
				} while (true);
			}
		}

		/* 
			BNF:
			<create constraint statement> ::=
				create [session] <constraint definition>

            <constraint definition> ::=
                constraint <constraint name> <expression> <metadata>
				
			<constraint name> ::=
				<qualified identifier>
		*/        
        protected CreateConstraintStatement CreateConstraintStatement(int ALine, int ALinePos, bool AIsSession)
        {
			CreateConstraintStatement LStatement = new CreateConstraintStatement();
			LStatement.Line = ALine;
			LStatement.LinePos = ALinePos;
			LStatement.IsSession = AIsSession;
			LStatement.ConstraintName = QualifiedIdentifier();
			LStatement.Expression = Expression();
			MetaData(LStatement);
			LStatement.SetEndPosition(FLexer);
			return LStatement;
        }
        
		/* 
			BNF:
            <create view statement> ::=
                create [session] view <view name> 
					<expression> 
					["{"<ne view definition item commalist>"}"] 
					<metadata>
                
            <view name> ::=
				<qualified identifier>
		*/        
        protected CreateViewStatement CreateViewStatement(int ALine, int ALinePos, bool AIsSession)
        {
			CreateViewStatement LStatement = new CreateViewStatement();
			LStatement.Line = ALine;
			LStatement.LinePos = ALinePos;
			LStatement.IsSession = AIsSession;
			LStatement.TableVarName = QualifiedIdentifier();
			LStatement.Expression = Expression();
			if (FLexer.PeekTokenSymbol(1) == Keywords.BeginList)
				CreateViewDefinitionList(LStatement);
			MetaData(LStatement);
			LStatement.SetEndPosition(FLexer);
			return LStatement;
        }
        
		/* 
			BNF:
			<view definition item> ::=
				<row constraint definition> |
				<key definition> |
				<reference definition> |
				<order definition>
		*/        
        protected void CreateViewDefinitionList(CreateViewStatement AStatement)
        {
			FLexer.NextToken().CheckSymbol(Keywords.BeginList);
			if (FLexer.PeekTokenSymbol(1) == Keywords.EndList)
			{
				FLexer.NextToken();
				return;
			}
			
			do
			{
				switch (FLexer.PeekTokenSymbol(1))
				{
					case Keywords.Transition:
					case Keywords.Constraint: AStatement.Constraints.Add(RowConstraintDefinition()); break;
					case Keywords.Reference: AStatement.References.Add(ReferenceDefinition()); break;
					case Keywords.Key: AStatement.Keys.Add(KeyDefinition()); break;
					case Keywords.Order: AStatement.Orders.Add(OrderDefinition()); break;
					default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
				}
				
				switch (FLexer.NextToken().AsSymbol)
				{
					case Keywords.ListSeparator: break;
					case Keywords.EndList: return;
					default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
				}
			} while (true);
        }

		/*                     
			BNF:
            <order definition> ::=
                order "{"<order column definition commalist>"}" <metadata>
        */
        protected OrderDefinition OrderDefinition()
        {
			OrderDefinition LDefinition = new OrderDefinition();
			FLexer.NextToken().CheckSymbol(Keywords.Order);
			LDefinition.SetPosition(FLexer);
			OrderColumnDefinitionList(LDefinition.Columns);
			MetaData(LDefinition);
			LDefinition.SetEndPosition(FLexer);
			return LDefinition;
        }
        
        protected void OrderColumnDefinitionList(OrderColumnDefinitions AColumns)
        {
			FLexer.NextToken().CheckSymbol(Keywords.BeginList);
			if (FLexer.PeekTokenSymbol(1) == Keywords.EndList)
				FLexer.NextToken();
			else
				do
				{
					AColumns.Add(OrderColumnDefinition());
					switch (FLexer.NextToken().AsSymbol)
					{
						case Keywords.ListSeparator: break;
						case Keywords.EndList: return;
						default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
					}
				} while (true);
        }

		/*        
			BNF:
            <order column definition> ::=
				<column name> [sort <expression>] [asc | desc] [(include | exclude) nil]
		*/
        protected OrderColumnDefinition OrderColumnDefinition()
        {
			OrderColumnDefinition LColumn = new OrderColumnDefinition();
			LColumn.ColumnName = QualifiedIdentifier();
			LColumn.SetPosition(FLexer);

			if (FLexer.PeekTokenSymbol(1) == Keywords.Sort)
				LColumn.Sort = SortDefinition();

			LColumn.Ascending = true;
			switch (FLexer.PeekTokenSymbol(1))
			{
				case Keywords.Desc: LColumn.Ascending = false; goto case Keywords.Asc;
				case Keywords.Asc: FLexer.NextToken(); break;
			}
			
			LColumn.IncludeNils = false;
			switch (FLexer.PeekTokenSymbol(1))
			{
				case Keywords.Include: LColumn.IncludeNils = true; goto case Keywords.Exclude;
				case Keywords.Exclude: FLexer.NextToken(); FLexer.NextToken().CheckType(TokenType.Nil); break;
			}
			
			return LColumn;
        }
        
		/* 
			BNF:
            <class definition> ::=
				class <class name> [<attributes>]

			<class name> ::=
				<string>
        */
        protected ClassDefinition ClassDefinition()
        {
			ClassDefinition LDefinition = new ClassDefinition();
			FLexer.NextToken().CheckSymbol(Keywords.Class);
			LDefinition.SetPosition(FLexer);
			FLexer.NextToken();
			LDefinition.ClassName = FLexer[0].AsString;
			if (FLexer.PeekTokenSymbol(1) == Keywords.Attributes)
			{
				FLexer.NextToken();
				ClassAttributeDefinitionList(LDefinition.Attributes);
			}
			LDefinition.SetEndPosition(FLexer);
			return LDefinition;
        }
        
        protected void ClassAttributeDefinitionList(ClassAttributeDefinitions AAttributes)
        {
			FLexer.NextToken().CheckSymbol(Keywords.BeginList);
			do
			{
				AAttributes.Add(ClassAttributeDefinition());
				switch (FLexer.NextToken().AsSymbol)
				{
					case Keywords.ListSeparator: break;
					case Keywords.EndList: return;
					default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
				}
			} while (true);
        }
        
		/* 
			BNF:
			<attributes> ::=
				attributes "{"<ne attribute definition commalist>"}"
				
			<attribute definition> ::=
				<attribute name> = <attribute value>

			<attribute name> ::=
				<string>

			<attribute value> ::=
				<string>
        */
        protected ClassAttributeDefinition ClassAttributeDefinition()
        {
			ClassAttributeDefinition LDefinition = new ClassAttributeDefinition();
			FLexer.NextToken();
			LDefinition.SetPosition(FLexer);
			LDefinition.AttributeName = FLexer[0].AsString;
			FLexer.NextToken().CheckSymbol(Keywords.Equal);
			FLexer.NextToken();
			LDefinition.AttributeValue = FLexer[0].AsString;
			LDefinition.SetEndPosition(FLexer);
			return LDefinition;
        }

		/* 
			BNF:
			<alter class definition> ::=
				alter class [<class name>] ["{"<alter attribute definition commalist>"}"]
				
			<alter attribute definition> ::=
				(create <attribute definition>) | 
				(alter <attribute definition>) | 
				(drop <attribute name>)
        */
        protected AlterClassDefinition AlterClassDefinition()
        {
			// This must be able to parse from the alter or class keywords of the construct
			if (FLexer.PeekTokenSymbol(1) == Keywords.Alter)
				FLexer.NextToken();

			FLexer.NextToken().CheckSymbol(Keywords.Class);

			AlterClassDefinition LDefinition = new AlterClassDefinition();
			LDefinition.SetPosition(FLexer);
			if (FLexer.PeekTokenSymbol(1) != Keywords.BeginList)
			{
				FLexer.NextToken();
				LDefinition.ClassName = FLexer[0].AsString;
			}

			if (FLexer.PeekTokenSymbol(1) == Keywords.BeginList)
			{
				FLexer.NextToken();
				bool LDone = false;
				do
				{
					switch (FLexer.NextToken().AsSymbol)
					{
						case Keywords.Create: LDefinition.CreateAttributes.Add(ClassAttributeDefinition()); break;
						case Keywords.Alter: LDefinition.AlterAttributes.Add(ClassAttributeDefinition()); break;
						case Keywords.Drop:
							ClassAttributeDefinition LAttributeDefinition = new ClassAttributeDefinition();
							LAttributeDefinition.SetPosition(FLexer);
							FLexer.NextToken();
							LAttributeDefinition.AttributeName = FLexer[0].AsString;
							LDefinition.DropAttributes.Add(LAttributeDefinition); 
						break;
						default: throw new ParserException(ParserException.Codes.DDLDirectiveExpected);
					}

					if (FLexer.NextToken().Type == TokenType.Symbol)
					{
						switch (FLexer[0].AsSymbol)
						{
							case Keywords.ListSeparator: break;
							case Keywords.EndList: LDone = true; break;
							default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
						}
					}
					else
						throw new ParserException(ParserException.Codes.ListTerminatorExpected);
				} while (!LDone);
			}
			
			LDefinition.SetEndPosition(FLexer);
			return LDefinition;
        }
        
		/* 
			BNF:
			<create scalar type statement> ::=
				create type <scalar type name> 
					[like <scalar type name>]
					["{"<scalar type definition item commalist>"}"]
					[<class definition>]
					<metadata>
				
			<scalar type definition item> ::=
				<representation definition> |
				<constraint definition> |
				<default definition> |
				<special definition>
		*/

		/*
			!BNF:
			<create scalar type statement> ::=
				create type <scalar type name>
					[is "{"<ne scalar type name commalist>"}"]
					[like <scalar type name>]
					["{"<scalar type definition item commalist>"}"]
					[<class definition>]
					<metadata>
		*/		
        protected CreateScalarTypeStatement CreateScalarTypeStatement(int ALine, int ALinePos)
        {
			CreateScalarTypeStatement LStatement = new CreateScalarTypeStatement();
			LStatement.Line = ALine;
			LStatement.LinePos = ALinePos;
			LStatement.ScalarTypeName = QualifiedIdentifier();
			
			#if ALLOWSUBTYPES
			if (FLexer.PeekTokenSymbol(1) == Keywords.Is)
			{
				FLexer.NextToken();
				ScalarTypeNameList(LStatement.ParentScalarTypes);
			}
			#endif

			if (FLexer.PeekTokenSymbol(1) == Keywords.Like)
			{
				FLexer.NextToken();
				LStatement.LikeScalarTypeName = QualifiedIdentifier();
			}

			if (FLexer.PeekTokenSymbol(1) == Keywords.BeginList)
			{
				FLexer.NextToken();
				bool LDone = false;
				do
				{
					switch (FLexer.PeekTokenSymbol(1))
					{
						case Keywords.Representation: LStatement.Representations.Add(RepresentationDefinition()); break;
						case Keywords.Constraint: LStatement.Constraints.Add(ConstraintDefinition()); break;
						case Keywords.Special: LStatement.Specials.Add(SpecialDefinition()); break;
						case Keywords.Default: 
							if (LStatement.Default != null)
								throw new ParserException(ParserException.Codes.DefaultDefinitionExists);
							LStatement.Default = DefaultDefinition();
						break;
						default: throw new ParserException(ParserException.Codes.UnknownCreateScalarTypeDirective, FLexer.PeekTokenSymbol(1));
					}
					
					if (FLexer.NextToken().Type == TokenType.Symbol)
					{
						switch (FLexer[0].AsSymbol)
						{
				    		case Keywords.ListSeparator: break;
				    		case Keywords.EndList: LDone = true; break;
				    		default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
						}
					}
					else
						throw new ParserException(ParserException.Codes.ListTerminatorExpected);
				} while (!LDone);
			}

			if (FLexer.PeekTokenSymbol(1) == Keywords.Class)
				LStatement.ClassDefinition = ClassDefinition();
			MetaData(LStatement);
			LStatement.SetEndPosition(FLexer);
			return LStatement;
        }
        
        protected ScalarTypeNameDefinition ScalarTypeName()
        {
			ScalarTypeNameDefinition LDefinition = new ScalarTypeNameDefinition();
			LDefinition.ScalarTypeName = QualifiedIdentifier();
			LDefinition.SetPosition(FLexer);
			LDefinition.SetEndPosition(FLexer);
			return LDefinition;
        }

		protected void ScalarTypeNameList(ScalarTypeNameDefinitions AScalarTypeNames)
		{
		    FLexer.NextToken().CheckSymbol(Keywords.BeginList);
			bool LDone = false;
			do
			{
				AScalarTypeNames.Add(ScalarTypeName());
				if (FLexer.NextToken().Type == TokenType.Symbol)
				{
				    switch (FLexer[0].AsSymbol)
				    {
				    	case Keywords.ListSeparator: break;
				    	case Keywords.EndList: LDone = true; break;
				    	default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
				    }
				}
				else
				    throw new ParserException(ParserException.Codes.ListTerminatorExpected);
			} while (!LDone); 
		}
		
		/*         
			BNF:
			<representation definition> ::=
				representation <representation name>
					"{"<ne property definition commalist>"}"
					[<class definition> | (selector <accessor block>)]
					<metadata>

			<representation name> ::=
				<qualified identifier>
				
			<accessor block> ::=
				<class definition> | <expression> | <block>
		*/
		protected RepresentationDefinition RepresentationDefinition()
		{
			RepresentationDefinition LDefinition = new RepresentationDefinition();
			FLexer.NextToken().CheckSymbol(Keywords.Representation);
			LDefinition.SetPosition(FLexer);
			LDefinition.RepresentationName = UnrootedIdentifier();
			
			FLexer.NextToken().CheckSymbol(Keywords.BeginList);

			bool LDone = false;
			do
			{
				LDefinition.Properties.Add(PropertyDefinition());
				
				switch (FLexer.NextToken().AsSymbol)
				{
					case Keywords.ListSeparator: break;
					case Keywords.EndList: LDone = true; break;
					default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
				}
			} while (!LDone);		
			
			switch (FLexer.PeekTokenSymbol(1))
			{
				case Keywords.Class : 
					LDefinition.SelectorAccessorBlock = new AccessorBlock();
					LDefinition.SelectorAccessorBlock.ClassDefinition = ClassDefinition(); 
				break;
				
				case Keywords.Selector :
					FLexer.NextToken();
					LDefinition.SelectorAccessorBlock = new AccessorBlock();
					AccessorBlock(LDefinition.SelectorAccessorBlock);
				break;
			}

			MetaData(LDefinition);
			LDefinition.SetEndPosition(FLexer);
			return LDefinition;
		}
		
		protected void AccessorBlock(AccessorBlock AAccessorBlock)
		{
			switch (FLexer.PeekTokenSymbol(1))
			{
				case Keywords.Class : AAccessorBlock.ClassDefinition = ClassDefinition(); break;
				case Keywords.Begin :
					FLexer.NextToken();
					AAccessorBlock.Block = Block();
					FLexer.NextToken().CheckSymbol(Keywords.End);
				break;
				default : AAccessorBlock.Expression = Expression(); break;
			}
		}
		
		/* 
			BNF:
			<property definition> ::=
				<property name> : <type specifier> 
					[read <accessor block>] 
					[write <accessor block>] 
					<metadata>
					
			<property name> ::=
				<qualified identifier>
		*/
		protected PropertyDefinition PropertyDefinition()
		{
			PropertyDefinition LDefinition = new PropertyDefinition();
			LDefinition.PropertyName = UnrootedIdentifier();
			LDefinition.SetPosition(FLexer);
			FLexer.NextToken().CheckSymbol(Keywords.TypeSpecifier);
			LDefinition.PropertyType = TypeSpecifier();
			
			if (FLexer.PeekTokenSymbol(1) == Keywords.Read)
			{
				FLexer.NextToken();
				LDefinition.ReadAccessorBlock = new AccessorBlock();
				AccessorBlock(LDefinition.ReadAccessorBlock);
			}
			
			if (FLexer.PeekTokenSymbol(1) == Keywords.Write)
			{
				FLexer.NextToken();
				LDefinition.WriteAccessorBlock = new AccessorBlock();
				AccessorBlock(LDefinition.WriteAccessorBlock);
			}

			MetaData(LDefinition);
			LDefinition.SetEndPosition(FLexer);
			return LDefinition;
		}
	    
	    /*
			BNF:
			<default definition> ::=
				default <expression> <metadata>
	    */                    
        protected DefaultDefinition DefaultDefinition()
        {
			DefaultDefinition LDefinition = new DefaultDefinition();
			FLexer.NextToken().CheckSymbol(Keywords.Default);
			LDefinition.SetPosition(FLexer);
			LDefinition.Expression = Expression();
			MetaData(LDefinition);
			LDefinition.SetEndPosition(FLexer);
			return LDefinition;
        }
        
        protected ConstraintDefinition ConstraintDefinition()
        {
			ConstraintDefinition LDefinition = new ConstraintDefinition();
			FLexer.NextToken().CheckSymbol(Keywords.Constraint);
			LDefinition.SetPosition(FLexer);
			LDefinition.ConstraintName = UnrootedIdentifier();
			LDefinition.Expression = Expression();
			MetaData(LDefinition);
			LDefinition.SetEndPosition(FLexer);
			return LDefinition;
        }

		/*
			BNF:
            <row constraint definition> ::=
				<constraint definition> |
				<transition constraint definition>
				
			<transition constraint definition> ::=
				transition constraint <constraint name>
					[on insert <expression>]
					[on update <expression>]
					[on delete <expression>]
					<metadata>
		*/        
        protected CreateConstraintDefinition RowConstraintDefinition()
        {
			if (FLexer.PeekTokenSymbol(1) == Keywords.Transition)
			{
				FLexer.NextToken();
				TransitionConstraintDefinition LDefinition = new TransitionConstraintDefinition();
				LDefinition.SetPosition(FLexer);
				FLexer.NextToken().CheckSymbol(Keywords.Constraint);
				LDefinition.ConstraintName = UnrootedIdentifier();
				while (FLexer.PeekTokenSymbol(1) == Keywords.On)
				{
					FLexer.NextToken();
					switch (FLexer.NextToken().AsSymbol)
					{
						case Keywords.Insert : LDefinition.OnInsertExpression = Expression(); break;
						case Keywords.Update : LDefinition.OnUpdateExpression = Expression(); break;
						case Keywords.Delete : LDefinition.OnDeleteExpression = Expression(); break;
						default : throw new ParserException(ParserException.Codes.UnknownConstraintTarget);
					}
				}
				MetaData(LDefinition);
				LDefinition.SetEndPosition(FLexer);
				return LDefinition;
			}
			else
			{
				ConstraintDefinition LDefinition = new ConstraintDefinition();
				FLexer.NextToken().CheckSymbol(Keywords.Constraint);
				LDefinition.SetPosition(FLexer);
				LDefinition.ConstraintName = UnrootedIdentifier();
				LDefinition.Expression = Expression();
				MetaData(LDefinition);
				LDefinition.SetEndPosition(FLexer);
				return LDefinition;
			}
        }
        
		/* 
			BNF:
			<special definition> ::=
				special <special name> <expression> <metadata>

			<special name> ::=
				<qualified identifier>
        */
        protected SpecialDefinition SpecialDefinition()
        {
			SpecialDefinition LDefinition = new SpecialDefinition();
			FLexer.NextToken().CheckSymbol(Keywords.Special);
			LDefinition.SetPosition(FLexer);
			LDefinition.Name = UnrootedIdentifier();
			LDefinition.Value = Expression();
			MetaData(LDefinition);
			LDefinition.SetEndPosition(FLexer);
			return LDefinition;
        }
        
        /*
			<sort definition> ::=
				sort <expression>
        */
        protected SortDefinition SortDefinition()
        {
			SortDefinition LDefinition = new SortDefinition();
			FLexer.NextToken().CheckSymbol(Keywords.Sort);
			LDefinition.SetPosition(FLexer);
			LDefinition.Expression = Expression();
			LDefinition.SetEndPosition(FLexer);
			return LDefinition;
        }
        
		/* 
			BNF:
			<create reference statement> ::=
				create [session] reference <reference name>
					<tablevar name> "{"<column name commalist>"}" 
					<references definition>
					<metadata>
		*/        
        protected CreateReferenceStatement CreateReferenceStatement(int ALine, int ALinePos, bool AIsSession)
        {
			CreateReferenceStatement LStatement = new CreateReferenceStatement();
			LStatement.Line = ALine;
			LStatement.LinePos = ALinePos;
			LStatement.IsSession = AIsSession;
			LStatement.ReferenceName = QualifiedIdentifier();
			LStatement.TableVarName = QualifiedIdentifier();
			ReferenceColumnList(LStatement.Columns);
			LStatement.ReferencesDefinition = ReferencesDefinition();
			MetaData(LStatement);
			LStatement.SetEndPosition(FLexer);
			return LStatement;
        }
        
		/* 
			BNF:
			<create operator statement> ::=
				create [session] operator
					<operator name>
					"("<formal parameter commalist>")"
					[: <type specifier>]
					(<class definition> | <block>)
					<metadata>
					
			<operator name> ::=
				<qualified identifier>
        */
        protected CreateOperatorStatement CreateOperatorStatement(int ALine, int ALinePos, bool AIsSession, bool AIsDeclarationOnly)
        {
			CreateOperatorStatement LStatement = new CreateOperatorStatement();
			LStatement.Line = ALine;
			LStatement.LinePos = ALinePos;
			LStatement.OperatorName = QualifiedIdentifier();
			LStatement.IsSession = AIsSession;
			FormalParameterList(LStatement.FormalParameters);
			if (FLexer.PeekTokenSymbol(1) == Keywords.TypeSpecifier)
			{
				FLexer.NextToken();
				LStatement.ReturnType = TypeSpecifier();
			}
			
			if (!AIsDeclarationOnly)
			{
				#if USETYPEINHERITANCE
				// [reintroduce] [abstract | virtual | override]
				// Virtual invocation has been removed until we have a better solution for casting physical representations and specialization by constraint
				switch (FLexer.PeekTokenSymbol(1))
				{
					case Keywords.Reintroduce:
						FLexer.NextToken();
						LStatement.IsReintroduced = true;
						switch (FLexer.PeekTokenSymbol(1))
						{
							case Keywords.Abstract:
								FLexer.NextToken();
								LStatement.IsAbstract = true;
							break;
							
							case Keywords.Virtual:
								FLexer.NextToken();
								LStatement.IsVirtual = true;
							break;
							
							case Keywords.Override:
								throw new ParserException(ParserException.Codes.InvalidOverrideDirective);
						}
					break;
					
					case Keywords.Abstract:
						FLexer.NextToken();
						LStatement.IsAbstract = true;
					break;
					
					case Keywords.Virtual:
						FLexer.NextToken();
						LStatement.IsVirtual = true;
					break;
					
					case Keywords.Override:
						FLexer.NextToken();
						LStatement.IsOverride = true;
					break;
				}
				#endif

				bool LHasBody = false;
				switch (FLexer.PeekTokenSymbol(1))
				{
					case Keywords.Class:
						#if USETYPEINHERITANCE
						if (LStatement.IsAbstract)
							throw new ParserException(ParserException.Codes.InvalidAbstractDirective);
						#endif
						LStatement.Block.ClassDefinition = ClassDefinition();
						LStatement.Block.Line = LStatement.Block.ClassDefinition.Line;
						LStatement.Block.LinePos = LStatement.Block.ClassDefinition.LinePos;
						LStatement.Block.SetEndPosition(FLexer);
						LHasBody = true;
					break;
					
					case Keywords.Begin:
						#if USETYPEINHERITANCE
						if (LStatement.IsAbstract)
							throw new ParserException(ParserException.Codes.InvalidAbstractDirective);
						#endif
						FLexer.NextToken();
						ALine = FLexer[0].Line;
						ALinePos = FLexer[0].LinePos;
						LStatement.Block.Block = Block();
						FLexer.NextToken().CheckSymbol(Keywords.End);
						LStatement.Block.Line = ALine;
						LStatement.Block.LinePos = ALinePos;
						LStatement.Block.SetEndPosition(FLexer);
						LHasBody = true;
					break;
				}

				#if USETYPEINHERITANCE			
				if (!LStatement.IsAbstract && !LHasBody)
					throw new ParserException(ParserException.Codes.InvalidOperatorDefinition);
				#endif
				
				if (!LHasBody)
					throw new ParserException(ParserException.Codes.InvalidOperatorDefinition);

				MetaData(LStatement);
				LStatement.SetEndPosition(FLexer);
			}

			return LStatement;
        }
        
		protected void FormalParameterList(FormalParameters AFormalParameters)
		{
			FLexer.NextToken().CheckSymbol(Keywords.BeginGroup);
			if (FLexer.PeekTokenSymbol(1) == Keywords.EndGroup)
				FLexer.NextToken();
			else
				do
				{
					AFormalParameters.Add(FormalParameter());
					switch (FLexer.NextToken().AsSymbol)
					{
						case Keywords.ListSeparator: break;
						case Keywords.EndGroup: return;
						default: throw new ParserException(ParserException.Codes.GroupTerminatorExpected);
					}
				} while (true);
		}
		
		/* 
			BNF:
			<formal parameter> ::=
				[<modifier>] <named type specifier>

			<modifier> ::=
				[var | const]
		*/
		protected FormalParameter FormalParameter()
		{
			FormalParameter LFormalParameter = new FormalParameter();
			switch (FLexer.PeekTokenSymbol(1))
			{
				case Keywords.Var: 
					FLexer.NextToken();
					LFormalParameter.Modifier = Modifier.Var;
				break;
					
				case Keywords.Const:
					FLexer.NextToken();
					LFormalParameter.Modifier = Modifier.Const;
				break;
			}
			
			LFormalParameter.Identifier = UnrootedIdentifier();
			LFormalParameter.SetPosition(FLexer);
			FLexer.NextToken().CheckSymbol(Keywords.TypeSpecifier);
			LFormalParameter.TypeSpecifier = TypeSpecifier();
			LFormalParameter.SetEndPosition(FLexer);
			return LFormalParameter;
		}

		protected LineInfo NamedTypeSpecifierList(NamedTypeSpecifiers ATypeSpecifiers)
        {
			FLexer.NextToken().CheckSymbol(Keywords.BeginList);
			LineInfo LResult = new LineInfo(FLexer[0, false].LinePos, FLexer[0, false].Line, -1, -1);
			if (FLexer.PeekTokenSymbol(1) == Keywords.EndList)
			{
				FLexer.NextToken();
				return LResult;
			}
			else
				do
				{
					ATypeSpecifiers.Add(NamedTypeSpecifier());
					switch (FLexer.NextToken().AsSymbol)
					{
						case Keywords.ListSeparator: break;
						case Keywords.EndList: return LResult;
						default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
					}
				} while (true);
        }

		/* 
			BNF:
			<named type specifier> ::=
				<qualified identifier> : <type specifier>
		*/        
        protected NamedTypeSpecifier NamedTypeSpecifier()
        {
			NamedTypeSpecifier LSpecifier = new NamedTypeSpecifier();
			LSpecifier.Identifier = UnrootedIdentifier();
			LSpecifier.SetPosition(FLexer);
			FLexer.NextToken().CheckSymbol(Keywords.TypeSpecifier);
			LSpecifier.TypeSpecifier = TypeSpecifier();
			LSpecifier.SetEndPosition(FLexer);
			return LSpecifier;
        }

		/* 
			BNF:
			<type specifier> ::=
				<generic type specifier> |
				<scalar type specifier> |
				<row type specifier> |
				<table type specifier> |
				<list type specifier> |
				<cursor type specifier> |
				<typeof type specifier>
		*/        
        protected TypeSpecifier TypeSpecifier()
        {
			switch (FLexer.PeekTokenSymbol(1))
			{
				case Keywords.Generic: 
					FLexer.NextToken();
					switch (FLexer.PeekTokenSymbol(1))
					{
						case Keywords.Type: return ScalarTypeSpecifier(true);
						case Keywords.Row: return RowTypeSpecifier(true);
						case Keywords.Table: return TableTypeSpecifier(true);
						case Keywords.List: return ListTypeSpecifier(true);
						case Keywords.Cursor: return CursorTypeSpecifier(true);
						default: return GenericTypeSpecifier();
					}
										
				case Keywords.Row: return RowTypeSpecifier(false);
				case Keywords.Table: return TableTypeSpecifier(false);
				case Keywords.List: return ListTypeSpecifier(false);
				case Keywords.Cursor: return CursorTypeSpecifier(false);
				//case Keywords.Operator: return OperatorTypeSpecifier();
				case Keywords.TypeOf: return TypeOfTypeSpecifier();
				default: return ScalarTypeSpecifier(false);
			}
        }
        
        /*
			BNF:
			<generic type specifier> ::=
				generic
        */
        protected GenericTypeSpecifier GenericTypeSpecifier()
        {
			GenericTypeSpecifier LSpecifier = new GenericTypeSpecifier();
			LSpecifier.SetPosition(FLexer);
			LSpecifier.SetEndPosition(FLexer);
			return LSpecifier;
        }

		/*         
			BNF:
			<scalar type specifier> ::=
				[generic] scalar | <scalar type name>
		*/
        protected ScalarTypeSpecifier ScalarTypeSpecifier(bool AIsGeneric)
        {
			ScalarTypeSpecifier LSpecifier = new ScalarTypeSpecifier();
			if (FLexer.PeekTokenSymbol(1) == Keywords.Scalar)
			{
				FLexer.NextToken();
				LSpecifier.IsGeneric = true;
			}
			else
				LSpecifier.ScalarTypeName = QualifiedIdentifier();
			LSpecifier.SetPosition(FLexer);
			LSpecifier.SetEndPosition(FLexer);
			return LSpecifier;
        }

		/* 
			BNF:
			<list type specifier> ::=
				[generic] list["("<type specifier>")"]
		*/
        protected ListTypeSpecifier ListTypeSpecifier(bool AIsGeneric)
        {
			ListTypeSpecifier LSpecifier = new ListTypeSpecifier();
			FLexer.NextToken();
			LSpecifier.SetPosition(FLexer);
			if (AIsGeneric)
				LSpecifier.IsGeneric = true;
			else
			{
				if (FLexer.PeekTokenSymbol(1) == Keywords.BeginGroup)
				{
					FLexer.NextToken();
					LSpecifier.TypeSpecifier = TypeSpecifier();
					FLexer.NextToken().CheckSymbol(Keywords.EndGroup);
				}
				else
					LSpecifier.IsGeneric = true;
			}
			LSpecifier.SetEndPosition(FLexer);
			return LSpecifier;
        }

		/* 
			BNF:
			<row type specifier> ::=
				[generic] row["{"<named type specifier commalist>"}"]
		*/        
        protected RowTypeSpecifier RowTypeSpecifier(bool AIsGeneric)
        {
			RowTypeSpecifier LSpecifier = new RowTypeSpecifier();
			FLexer.NextToken();
			LSpecifier.SetPosition(FLexer);
			if (AIsGeneric)
				LSpecifier.IsGeneric = true;
			else
			{
				if (FLexer.PeekTokenSymbol(1) == Keywords.BeginList)
					NamedTypeSpecifierList(LSpecifier.Columns);
				else
					LSpecifier.IsGeneric = true;	
			}
			LSpecifier.SetEndPosition(FLexer);
			return LSpecifier;
        }
        
		/* 
			BNF:
			<table type specifier> ::=
				[generic] table["{"<named type specifier commalist>"}"]
		*/        
        protected TableTypeSpecifier TableTypeSpecifier(bool AIsGeneric)        
        {
			TableTypeSpecifier LSpecifier = new TableTypeSpecifier();
			FLexer.NextToken();
			LSpecifier.SetPosition(FLexer);
			if (AIsGeneric)
				LSpecifier.IsGeneric = true;
			else
			{
				if (FLexer.PeekTokenSymbol(1) == Keywords.BeginList)
				{
					FLexer.NextToken();
					bool LDone = false;
					do
					{
						switch (FLexer.PeekTokenSymbol(1))
						{
							case Keywords.EndList: break;
							default: LSpecifier.Columns.Add(NamedTypeSpecifier()); break;
						}
						switch (FLexer.NextToken().AsSymbol)
						{
							case Keywords.ListSeparator: break;
							case Keywords.EndList: LDone = true; break;
							default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
						}
					} while (!LDone);
				}
				else
					LSpecifier.IsGeneric = true;
			}
			LSpecifier.SetEndPosition(FLexer);
			return LSpecifier;
        }
        
		/*         
			BNF:
			<cursor type specifier> ::=
				[generic] cursor["("<type specifier>")"]
		*/
        protected CursorTypeSpecifier CursorTypeSpecifier(bool AIsGeneric)
        {
			CursorTypeSpecifier LSpecifier = new CursorTypeSpecifier();
			FLexer.NextToken();
			LSpecifier.SetPosition(FLexer);
			if (AIsGeneric)
				LSpecifier.IsGeneric = true;
			else
			{
				if (FLexer.PeekTokenSymbol(1) == Keywords.BeginGroup)
				{
					FLexer.NextToken();
					LSpecifier.TypeSpecifier = TypeSpecifier();
					FLexer.NextToken().CheckSymbol(Keywords.EndGroup);
				}
				else
					LSpecifier.IsGeneric = true;
			}
			LSpecifier.SetEndPosition(FLexer);
			return LSpecifier;
        }
        
		/* 
			!BNF:
			<operator type specifier> ::=
				operator["("<formal parameter specifier commalist>")"]
        */
		/*
		protected OperatorTypeSpecifier OperatorTypeSpecifier()
		{
			OperatorTypeSpecifier LSpecifier = new OperatorTypeSpecifer();
			FLexer.NextToken();
			LSpecifier.SetPosition(FLexer);
			if (FLexer.PeekTokenSymbol(1) == Keywords.BeginGroup)
				FormalParameterSpecifiers(LSpecifier.TypeSpecifiers);
			else
				LSpecifier.IsGeneric = true;
			return LSpecifier;
		}
		*/

		/* 
			BNF:
			<typeof type specifier> ::=
				typeof"("<expression>")"
		*/        
        protected TypeOfTypeSpecifier TypeOfTypeSpecifier()
        {
			TypeOfTypeSpecifier LTypeSpecifier = new TypeOfTypeSpecifier();
			FLexer.NextToken();
			LTypeSpecifier.SetPosition(FLexer);
			FLexer.NextToken().CheckSymbol(Keywords.BeginGroup);
			LTypeSpecifier.Expression = Expression();
			FLexer.NextToken().CheckSymbol(Keywords.EndGroup);
			LTypeSpecifier.SetEndPosition(FLexer);
			return LTypeSpecifier;
        }
        
		/* 
			BNF:
			<formal parameter specifier> ::=
				[<modifier>] <type specifier>
        */
        protected FormalParameterSpecifier FormalParameterSpecifier()
        {
			FormalParameterSpecifier LTypeSpecifier = new FormalParameterSpecifier();
			switch (FLexer.PeekTokenSymbol(1))
			{
				case Keywords.Var: 
					FLexer.NextToken(); 
					LTypeSpecifier.Modifier = Modifier.Var;
					LTypeSpecifier.SetPosition(FLexer);
					break;
				case Keywords.Const: 
					FLexer.NextToken(); 
					LTypeSpecifier.Modifier = Modifier.Const;
					LTypeSpecifier.SetPosition(FLexer);
					break;
				default: break;
			}
			
			LTypeSpecifier.TypeSpecifier = TypeSpecifier();
			if (LTypeSpecifier.Line == -1)
			{
				LTypeSpecifier.Line = LTypeSpecifier.TypeSpecifier.Line;
				LTypeSpecifier.LinePos = LTypeSpecifier.TypeSpecifier.LinePos;
			}
			LTypeSpecifier.SetEndPosition(FLexer);
			return LTypeSpecifier;
        }
        
        protected void FormalParameterSpecifiers(FormalParameterSpecifiers ATypeSpecifiers)
        {
			FLexer.NextToken().CheckSymbol(Keywords.BeginGroup);
			if (FLexer.PeekTokenSymbol(1) == Keywords.EndGroup)
				FLexer.NextToken();
			else
			{
				bool LDone = false;
				do
				{
					ATypeSpecifiers.Add(FormalParameterSpecifier());
					switch (FLexer.NextToken().AsSymbol)
					{
						case Keywords.ListSeparator: break;
						case Keywords.EndGroup: LDone = true; break;
						default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
					}
				} while (!LDone);
			}
        }

		/* 
			BNF:
			<create aggregate operator statement> ::=
				create [session] aggregate operator
					<operator name>
					"("<formal parameter commalist>")"
					: <type specifier>
					initialization (<class definition> | <block>)
					aggregation (<class definition> | <block>)
					finalization (<class definition> | <block>)
					<metadata>
        */
        protected CreateAggregateOperatorStatement CreateAggregateOperatorStatement(int ALine, int ALinePos, bool AIsSession, bool AIsDeclarationOnly)
        {
			CreateAggregateOperatorStatement LStatement = new CreateAggregateOperatorStatement();
			LStatement.Line = ALine;
			LStatement.LinePos = ALinePos;
			LStatement.IsSession = AIsSession;
			FLexer.NextToken().CheckSymbol(Keywords.Operator);
			LStatement.OperatorName = QualifiedIdentifier();
			FormalParameterList(LStatement.FormalParameters);
			FLexer.NextToken().CheckSymbol(Keywords.TypeSpecifier);
			LStatement.ReturnType = TypeSpecifier();
			
			if (!AIsDeclarationOnly)
			{
				#if USETYPEINHERITANCE			
				// [reintroduce] [abstract | virtual | override]
				switch (FLexer.PeekTokenSymbol(1))
				{
					case Keywords.Reintroduce:
						FLexer.NextToken();
						LStatement.IsReintroduced = true;
						switch (FLexer.PeekTokenSymbol(1))
						{
							case Keywords.Abstract:
								FLexer.NextToken();
								LStatement.IsAbstract = true;
							break;
							
							case Keywords.Virtual:
								FLexer.NextToken();
								LStatement.IsVirtual = true;
							break;
							
							case Keywords.Override:
								throw new ParserException(ParserException.Codes.InvalidOverrideDirective);
						}
					break;

					case Keywords.Abstract:
						FLexer.NextToken();
						LStatement.IsAbstract = true;
					break;
					
					case Keywords.Virtual:
						FLexer.NextToken();
						LStatement.IsVirtual = true;
					break;
					
					case Keywords.Override:
						FLexer.NextToken();
						LStatement.IsOverride = true;
					break;
				}

				if (!LStatement.IsAbstract)
				{
				#endif
					FLexer.NextToken().CheckSymbol(Keywords.Initialization);
					LStatement.Initialization.SetPosition(FLexer);
					if (FLexer.PeekTokenSymbol(1) == Keywords.Class)
						LStatement.Initialization.ClassDefinition = ClassDefinition();
					else
					{
						FLexer.NextToken().CheckSymbol(Keywords.Begin);
						LStatement.Initialization.Block = Block();
						FLexer.NextToken().CheckSymbol(Keywords.End);
					}
					LStatement.Initialization.SetEndPosition(FLexer);
						
					FLexer.NextToken().CheckSymbol(Keywords.Aggregation);
					LStatement.Aggregation.SetPosition(FLexer);
					if (FLexer.PeekTokenSymbol(1) == Keywords.Class)
						LStatement.Aggregation.ClassDefinition = ClassDefinition();
					else
					{
						FLexer.NextToken().CheckSymbol(Keywords.Begin);
						LStatement.Aggregation.Block = Block();
						FLexer.NextToken().CheckSymbol(Keywords.End);
					}
					LStatement.Aggregation.SetEndPosition(FLexer);
						
					FLexer.NextToken().CheckSymbol(Keywords.Finalization);
					LStatement.Finalization.SetPosition(FLexer);
					if (FLexer.PeekTokenSymbol(1) == Keywords.Class)
						LStatement.Finalization.ClassDefinition = ClassDefinition();
					else
					{
						FLexer.NextToken().CheckSymbol(Keywords.Begin);
						LStatement.Finalization.Block = Block();
						FLexer.NextToken().CheckSymbol(Keywords.End);
					}
					LStatement.Finalization.SetEndPosition(FLexer);

				#if USETYPEINHERITANCE
				}
				else
					if (FLexer.PeekTokenSymbol(1) == Keywords.Initialization)
						throw new ParserException(ParserException.Codes.InvalidAbstractDirective);
				#endif

				MetaData(LStatement);
				LStatement.SetEndPosition(FLexer);
			}
				
			return LStatement;
        }
		
		/* 
			BNF:
            <create server link statement> ::=
                create server <server link name> <metadata>

			<server link name> ::=
				<qualified identifier>
		*/        
        protected CreateServerStatement CreateServerStatement(int ALine, int ALinePos)
        {
			CreateServerStatement LStatement = new CreateServerStatement();
			LStatement.Line = ALine;
			LStatement.LinePos = ALinePos;
			LStatement.ServerName = QualifiedIdentifier();
			MetaData(LStatement);
			LStatement.SetEndPosition(FLexer);
			return LStatement;
        }
		
		/* 
			BNF:
			<create device statement> ::=
				create device <device name>
					<reconciliation settings>
					<class definition>
					<metadata>
					
			<device map item> ::=
				<device scalar type map> |
				<device operator map> |
				<device store definition>
		*/        

/*
	BTR 5/30/2006 ->
		Removed the create device maps capability from the create device statement.
		1) It would never have actually worked, because of the way device mapping worked internally
		2) Nobody actually did it, because it didn't actually work
		3) It makes things easier to implement overall if you can only create device maps as part of an alter statement
		4) We should maybe even consider a create device map statement, because device maps are, after all, catalog objects
		
		This is the BNF line that was removed (was right after <device name>):
					["{"<device map item commalist>"}"]
*/
        protected CreateDeviceStatement CreateDeviceStatement(int ALine, int ALinePos)
        {
			CreateDeviceStatement LStatement = new CreateDeviceStatement();
			LStatement.Line = ALine;
			LStatement.LinePos = ALinePos;
			LStatement.DeviceName = QualifiedIdentifier();
/*
			if (FLexer.PeekTokenSymbol() == Keywords.BeginList)
			{
				FLexer.NextToken();
				bool LDone = false;
				do
				{
					switch (FLexer.NextToken().AsSymbol)
					{
						case Keywords.Type: LStatement.DeviceScalarTypeMaps.Add(DeviceScalarTypeMap()); break;
						case Keywords.Operator: LStatement.DeviceOperatorMaps.Add(DeviceOperatorMap()); break;
						case Keywords.Store: LStatement.DeviceStoreDefinitions.Add(DeviceStoreDefinition()); break;
						default: throw new ParserException(ParserException.Codes.UnknownCreateDirective, FLexer[0].AsSymbol);
					}
					
					switch (FLexer.NextToken().AsSymbol)
					{
						case Keywords.ListSeparator: break;
						case Keywords.EndList: LDone = true; break;
						default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
					}
				} while (!LDone);
			}
*/
			LStatement.ReconciliationSettings = ReconciliationSettings();
			LStatement.ClassDefinition = ClassDefinition();
			MetaData(LStatement);
			LStatement.SetEndPosition(FLexer);
			return LStatement;
        }
        
		/* 
			BNF:
			<device scalar type map> ::=
				type <scalar type name> [<class definition>] <metadata>
        */
        protected DeviceScalarTypeMap DeviceScalarTypeMap()
        {
			DeviceScalarTypeMap LDeviceScalarTypeMap = new DeviceScalarTypeMap();
			LDeviceScalarTypeMap.SetPosition(FLexer);
			LDeviceScalarTypeMap.ScalarTypeName = QualifiedIdentifier();
			if (FLexer.PeekTokenSymbol(1) == Keywords.Class)
				LDeviceScalarTypeMap.ClassDefinition = ClassDefinition();
			MetaData(LDeviceScalarTypeMap);
			LDeviceScalarTypeMap.SetEndPosition(FLexer);
			return LDeviceScalarTypeMap;
        }
        
		/* 
			BNF:
			<device operator map> ::=
				operator <operator specifier> [<class definition>] <metadata>
        */
        protected DeviceOperatorMap DeviceOperatorMap()
        {
			DeviceOperatorMap LDeviceOperatorMap = new DeviceOperatorMap();
			LDeviceOperatorMap.SetPosition(FLexer);
			LDeviceOperatorMap.OperatorSpecifier = OperatorSpecifier();
			if (FLexer.PeekTokenSymbol(1) == Keywords.Class)
				LDeviceOperatorMap.ClassDefinition = ClassDefinition();
			MetaData(LDeviceOperatorMap);
			LDeviceOperatorMap.SetEndPosition(FLexer);
			return LDeviceOperatorMap;
        }
        
        /*
			BNF:
			<operator specifier> ::=
				<operator name>"("<formal parameter specifier commalist>")"
		*/
		protected OperatorSpecifier OperatorSpecifier()
		{
			OperatorSpecifier LOperatorSpecifier = new OperatorSpecifier();
			LOperatorSpecifier.SetPosition(FLexer);
			LOperatorSpecifier.OperatorName = QualifiedIdentifier();
			FormalParameterSpecifiers(LOperatorSpecifier.FormalParameterSpecifiers);
			LOperatorSpecifier.SetEndPosition(FLexer);
			return LOperatorSpecifier;
		}
		
		/*
			BNF:
			<device store definition> ::=
				store <store name> 
					[<expression>] 
					by (default | ("{"<index column definition commalist>"}" <metadata>))
					[indexes (default | "{"<ne index definition commalist>"}")]
					<metadata>
				
			<store name> ::=
				<qualified identifier>
		*/
		protected DeviceStoreDefinition DeviceStoreDefinition()
		{
			DeviceStoreDefinition LDefinition = new DeviceStoreDefinition();
			LDefinition.SetPosition(FLexer);
			LDefinition.StoreName = QualifiedIdentifier();
			if (FLexer.PeekTokenSymbol(1) != Keywords.By)
				LDefinition.Expression = Expression();
			FLexer.NextToken().CheckSymbol(Keywords.By);
			if (FLexer.PeekTokenSymbol(1) == Keywords.Default)
			{
				FLexer.NextToken();
				LDefinition.ClusteredDefault = true;
			}
			else
			{
				LDefinition.ClusteredIndexDefinition = new IndexDefinition();
				LDefinition.SetPosition(FLexer);
				IndexColumnDefinitionList(LDefinition.ClusteredIndexDefinition.Columns);
				MetaData(LDefinition.ClusteredIndexDefinition);
			}

			if (FLexer.PeekTokenSymbol(1) == Keywords.Indexes)
			{
				if (FLexer.PeekTokenSymbol(1) == Keywords.Default)
				{
					FLexer.NextToken();
					LDefinition.IndexesDefault = true;
				}
				else
				{
					FLexer.NextToken().CheckSymbol(Keywords.BeginList);
					bool LDone = false;
					while (!LDone)
					{
						LDefinition.IndexDefinitions.Add(IndexDefinition());
						
						switch (FLexer.NextToken().AsSymbol)
						{
							case Keywords.ListSeparator : break;
							case Keywords.EndList : LDone = true; break;
							default : throw new ParserException(ParserException.Codes.ListTerminatorExpected);
						}
					}
				}
			}
			
			MetaData(LDefinition);
			LDefinition.SetEndPosition(FLexer);
			return LDefinition;
		}        

		/*
			BNF:
			<index definition> ::=
				index "{"<index column definition commalist>"}" <metadata>
		*/
        protected IndexDefinition IndexDefinition()
        {
			IndexDefinition LDefinition = new IndexDefinition();
			FLexer.NextToken().CheckSymbol(Keywords.Index);
			LDefinition.SetPosition(FLexer);
			IndexColumnDefinitionList(LDefinition.Columns);
			MetaData(LDefinition);
			LDefinition.SetEndPosition(FLexer);
			return LDefinition;
        }
        
        protected void IndexColumnDefinitionList(IndexColumnDefinitions AColumns)
        {
			FLexer.NextToken().CheckSymbol(Keywords.BeginList);
			if (FLexer.PeekTokenSymbol(1) == Keywords.EndList)
				FLexer.NextToken();
			else
				do
				{
					AColumns.Add(IndexColumnDefinition());
					switch (FLexer.NextToken().AsSymbol)
					{
						case Keywords.ListSeparator: break;
						case Keywords.EndList: return;
						default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
					}
				} while (true);
        }

		/*
			BNF:
			<index column definition> ::=
				<column name> [sort <expression>] [asc | desc]
		*/        
        protected IndexColumnDefinition IndexColumnDefinition()
        {
			IndexColumnDefinition LColumn = new IndexColumnDefinition();
			LColumn.ColumnName = QualifiedIdentifier();
			LColumn.SetPosition(FLexer);

			if (FLexer.PeekTokenSymbol(1) == Keywords.Sort)
				LColumn.Sort = SortDefinition();

			LColumn.Ascending = true;
			switch (FLexer.PeekTokenSymbol(1))
			{
				case Keywords.Desc: LColumn.Ascending = false; goto case Keywords.Asc;
				case Keywords.Asc: FLexer.NextToken(); break;
			}
			
			LColumn.SetEndPosition(FLexer);
			return LColumn;
        }
        
		/* 
			BNF:
			<reconciliation settings> ::=
				[reconciliation "{"<reconciliation settings item commalist>"}"]
				
			<reconciliation settings item> ::=
				<reconciliation mode definition> |
				<reconciliation master>
				
			<reconciliation mode definition> ::=
				mode = "{"<reconciliation mode commalist>"}"
				
			<reconciliation mode> ::=
				none |
				startup |
				command |
				automatic
				
			<reconciliation master> ::=
				master = (server | device | both)
        */
        public ReconciliationSettings ReconciliationSettings()
        {
			ReconciliationSettings LSettings = new ReconciliationSettings();
			if (FLexer.PeekTokenSymbol(1) == Keywords.Reconciliation)
			{
				FLexer.NextToken();
				LSettings.SetPosition(FLexer);
				FLexer.NextToken().CheckSymbol(Keywords.BeginList);
				bool LDone = false;
				do
				{
					switch (FLexer.NextToken().AsSymbol)
					{
						case Keywords.Mode:
							FLexer.NextToken().CheckSymbol(Keywords.Equal);
							FLexer.NextToken().CheckSymbol(Keywords.BeginList);
							bool LInnerDone = false;
							do
							{
								LSettings.ReconcileMode = LSettings.ReconcileMode | (ReconcileMode)Enum.Parse(typeof(ReconcileMode), FLexer.NextToken().AsSymbol, true);
								
								switch (FLexer.NextToken().AsSymbol)
								{
									case Keywords.ListSeparator: break;
									case Keywords.EndList: LInnerDone = true; break;
									default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
								}
							} while (!LInnerDone);
						break;

						case Keywords.Master:
							FLexer.NextToken().CheckSymbol(Keywords.Equal);
							LSettings.ReconcileMaster = (ReconcileMaster)Enum.Parse(typeof(ReconcileMaster), FLexer.NextToken().AsSymbol, true);
						break;
					}
					
					switch (FLexer.NextToken().AsSymbol)
					{
						case Keywords.ListSeparator: break;
						case Keywords.EndList: LDone = true; break;
						default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
					}
				} while (!LDone);
			}

			return LSettings;
        }

		/*
			BNF:
			<create sort statement> ::=
				create sort <scalar type name> using <expression> <metadata>
		*/        
        protected CreateSortStatement CreateSortStatement(int ALine, int ALinePos)
        {
			CreateSortStatement LStatement = new CreateSortStatement();
			LStatement.Line = ALine;
			LStatement.LinePos = ALinePos;
			LStatement.ScalarTypeName = QualifiedIdentifier();
			FLexer.NextToken().CheckSymbol(Keywords.Using);
			LStatement.Expression = Expression();
			MetaData(LStatement);
			LStatement.SetEndPosition(FLexer);
			return LStatement;
        }
        
        /*
			BNF:
			<create conversion statement> ::=
				create conversion <scalar type name> to <scalar type name> using <operator name> [widening | narrowing] <metadata>
        */
        protected CreateConversionStatement CreateConversionStatement(int ALine, int ALinePos)
        {
			CreateConversionStatement LStatement = new CreateConversionStatement();
			LStatement.Line = ALine;
			LStatement.LinePos = ALinePos;
			LStatement.SourceScalarTypeName = TypeSpecifier();
			FLexer.NextToken().CheckSymbol(Keywords.To);
			LStatement.TargetScalarTypeName = TypeSpecifier();
			FLexer.NextToken().CheckSymbol(Keywords.Using);
			LStatement.OperatorName = new IdentifierExpression();
			LStatement.OperatorName.Identifier = QualifiedIdentifier();
			LStatement.OperatorName.SetPosition(FLexer);
			switch (FLexer.PeekTokenSymbol(1))
			{
				case Keywords.Widening :
					FLexer.NextToken();
					LStatement.IsNarrowing = false;
				break;
				
				case Keywords.Narrowing :
					FLexer.NextToken();
					LStatement.IsNarrowing = true;
				break;
			}
			MetaData(LStatement);
			LStatement.SetEndPosition(FLexer);
			return LStatement;
        }
        
        /*
			BNF:
			<create role statement> ::=
				create role <role name> <metadata>
        */
        protected CreateRoleStatement CreateRoleStatement(int ALine, int ALinePos)
        {
			CreateRoleStatement LStatement = new CreateRoleStatement();
			LStatement.Line = ALine;
			LStatement.LinePos = ALinePos;
			LStatement.RoleName = QualifiedIdentifier();
			MetaData(LStatement);
			LStatement.SetEndPosition(FLexer);
			return LStatement;
        }
        
        /*
			BNF:
			<create right statement> ::=
				create right <right name>
		*/
		protected CreateRightStatement CreateRightStatement(int ALine, int ALinePos)
		{
			CreateRightStatement LStatement = new CreateRightStatement();
			LStatement.Line = ALine;
			LStatement.LinePos = ALinePos;
			LStatement.RightName = QualifiedIdentifier();
			LStatement.SetEndPosition(FLexer);
			return LStatement;
		}
        
		/* 
			BNF:
			<alter statement> ::=
				<alter table statement> |
				<alter view statement> |
				<alter constraint statement> |
				<alter reference statement> |
				<alter scalar type statement> |
				<alter operator statement> |
				<alter aggregate operator statement> |
				<alter device statement> |
				<alter server statement> |
				<alter sort statement> |
				<alter role statement>
		*/
        protected Statement AlterStatement()
        {
			FLexer.NextToken();
			int LLine = FLexer[0, false].Line;
			int LLinePos = FLexer[0, false].LinePos;
			switch (FLexer.NextToken().AsSymbol)
			{
				case Keywords.Table: return AlterTableStatement(LLine, LLinePos);
				case Keywords.View: return AlterViewStatement(LLine, LLinePos);
				case Keywords.Constraint: return AlterConstraintStatement(LLine, LLinePos);
				case Keywords.Reference: return AlterReferenceStatement(LLine, LLinePos);
				case Keywords.Type: return AlterScalarTypeStatement(LLine, LLinePos);
				case Keywords.Operator: return AlterOperatorStatement(LLine, LLinePos);
				case Keywords.Aggregate: return AlterAggregateOperatorStatement(LLine, LLinePos);
				case Keywords.Server: return AlterServerStatement(LLine, LLinePos);
				case Keywords.Device: return AlterDeviceStatement(LLine, LLinePos);
				case Keywords.Sort: return AlterSortStatement(LLine, LLinePos);
				case Keywords.Role: return AlterRoleStatement(LLine, LLinePos);
				default: throw new ParserException(ParserException.Codes.UnknownAlterDirective, FLexer[0].AsSymbol);
			}
        }
        
		/* 
			BNF:
			<alter table statement> ::=
				alter table <table name> 
					["{"<alter table definition item commalist>"}"]
					<alter metadata>
        */
        protected Statement AlterTableStatement(int ALine, int ALinePos)
        {
			AlterTableStatement LStatement = new AlterTableStatement();
			LStatement.Line = ALine;
			LStatement.LinePos = ALinePos;
			LStatement.TableVarName = QualifiedIdentifier();
			if (FLexer.PeekTokenSymbol(1) == Keywords.BeginList)
			{
				FLexer.NextToken();
				bool LDone = false;
				do
				{
					AlterTableStatementItem(LStatement);
					switch (FLexer.NextToken().AsSymbol)
					{
						case Keywords.ListSeparator: break;
						case Keywords.EndList: LDone = true; break;
						default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
					}
				} while (!LDone);
			}
			AlterMetaData(LStatement, false);
			LStatement.SetEndPosition(FLexer);
			return LStatement;
        }

		/* 
			BNF:
			<alter table definition item> ::=
				<alter column definition> |
				<alter row constraint definition> |
				<alter key definition> |
				<alter reference definition> |
				<alter order definition>

			<alter row constraint definition> ::=
				(create <row constraint definition>) |
				(alter constraint <constraint name> [<expression>] <alter metadata>) |
				<alter transition constraint definition> |
				(drop [transition] constraint <constraint name>)
		*/        
        protected void AlterTableStatementItem(AlterTableStatement AStatement)
        {
			switch (FLexer.NextToken().AsSymbol)
			{
				case Keywords.Create: AlterTableCreateDefinition(AStatement); break;
				case Keywords.Alter: AlterTableAlterDefinition(AStatement); break;
				case Keywords.Drop: AlterTableDropDefinition(AStatement); break;
				default: throw new ParserException(ParserException.Codes.DDLDirectiveExpected);
			}
        }
        
        protected void AlterTableCreateDefinition(AlterTableStatement AStatement)
        {
			switch (FLexer.PeekTokenSymbol(1))
			{
				case Keywords.Column: 
					FLexer.NextToken();
					AStatement.CreateColumns.Add(ColumnDefinition());
				break;
				case Keywords.Transition:
				case Keywords.Constraint: AStatement.CreateConstraints.Add(RowConstraintDefinition()); break;
				case Keywords.Key: AStatement.CreateKeys.Add(KeyDefinition()); break;
				case Keywords.Reference: AStatement.CreateReferences.Add(ReferenceDefinition()); break;
				case Keywords.Order: AStatement.CreateOrders.Add(OrderDefinition()); break;
				default: throw new ParserException(ParserException.Codes.UnknownCreateDirective, FLexer[0].AsSymbol);
			}
        }
        
        protected void AlterTableAlterDefinition(AlterTableStatement AStatement)
        {
			switch (FLexer.PeekTokenSymbol(1))
			{
				case Keywords.Tags: AlterMetaData(AStatement, false); break;
				default:
					switch (FLexer.NextToken().AsSymbol)
					{
						case Keywords.Column: AStatement.AlterColumns.Add(AlterColumnDefinition()); break;
						case Keywords.Transition: AStatement.AlterConstraints.Add(AlterTransitionConstraintDefinition()); break;
						case Keywords.Constraint: AStatement.AlterConstraints.Add(AlterConstraintDefinition()); break;
						case Keywords.Key: AStatement.AlterKeys.Add(AlterKeyDefinition()); break;
						case Keywords.Reference: AStatement.AlterReferences.Add(AlterReferenceDefinition()); break;
						case Keywords.Order: AStatement.AlterOrders.Add(AlterOrderDefinition()); break;
						default: throw new ParserException(ParserException.Codes.UnknownAlterDirective, FLexer[0].AsSymbol);
					}
					break;
			}
        }
        
        protected void AlterTableDropDefinition(AlterTableStatement AStatement)
        {
			switch (FLexer.NextToken().AsSymbol)
			{
				case Keywords.Column: AStatement.DropColumns.Add(DropColumnDefinition()); break;
				case Keywords.Transition:
				case Keywords.Constraint: AStatement.DropConstraints.Add(DropConstraintDefinition(true)); break;
				case Keywords.Key: AStatement.DropKeys.Add(DropKeyDefinition()); break;
				case Keywords.Reference: AStatement.DropReferences.Add(DropReferenceDefinition()); break;
				case Keywords.Order: AStatement.DropOrders.Add(DropOrderDefinition()); break;
				default: throw new ParserException(ParserException.Codes.UnknownDropDirective, FLexer[0].AsSymbol);
			}
        }
        
		/* 
			BNF:
			<alter view statement> ::=
				alter view <view name> 
					["{"<alter view definition item commalist>"}"]
					<alter metadata>
		*/
		protected Statement AlterViewStatement(int ALine, int ALinePos)
		{
			AlterViewStatement LStatement = new AlterViewStatement();
			LStatement.Line = ALine;
			LStatement.LinePos = ALinePos;
			LStatement.TableVarName = QualifiedIdentifier();
			if (FLexer.PeekTokenSymbol(1) == Keywords.BeginList)
			{
				FLexer.NextToken();
				bool LDone = false;
				do
				{
					AlterViewStatementItem(LStatement);
					switch (FLexer.NextToken().AsSymbol)
					{
						case Keywords.ListSeparator: break;
						case Keywords.EndList: LDone = true; break;
						default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
					}
				} while (!LDone);
			}
			AlterMetaData(LStatement, false);
			LStatement.SetEndPosition(FLexer);
			return LStatement;
		}
		
		/*			 
			BNF:
			<alter view definition item> ::=
				<alter row constraint definition> |
				<alter key definition> |
				<alter reference definition> |
				<alter order definition>
		*/
        protected void AlterViewStatementItem(AlterViewStatement AStatement)
        {
			switch (FLexer.NextToken().AsSymbol)
			{
				case Keywords.Create: AlterViewCreateDefinition(AStatement); break;
				case Keywords.Alter: AlterViewAlterDefinition(AStatement); break;
				case Keywords.Drop: AlterViewDropDefinition(AStatement); break;
				default: throw new ParserException(ParserException.Codes.DDLDirectiveExpected);
			}
        }
        
        protected void AlterViewCreateDefinition(AlterViewStatement AStatement)
        {
			switch (FLexer.PeekTokenSymbol(1))
			{
				case Keywords.Transition:
				case Keywords.Constraint: AStatement.CreateConstraints.Add(RowConstraintDefinition()); break;
				case Keywords.Key: AStatement.CreateKeys.Add(KeyDefinition()); break;
				case Keywords.Reference: AStatement.CreateReferences.Add(ReferenceDefinition()); break;
				case Keywords.Order: AStatement.CreateOrders.Add(OrderDefinition()); break;
				default: throw new ParserException(ParserException.Codes.UnknownCreateDirective, FLexer[0].AsSymbol);
			}
        }
        
        protected void AlterViewAlterDefinition(AlterViewStatement AStatement)
        {
			switch (FLexer.NextToken().AsSymbol)
			{
				case Keywords.Transition: AStatement.AlterConstraints.Add(AlterTransitionConstraintDefinition()); break;
				case Keywords.Constraint: AStatement.AlterConstraints.Add(AlterConstraintDefinition()); break;
				case Keywords.Key: AStatement.AlterKeys.Add(AlterKeyDefinition()); break;
				case Keywords.Reference: AStatement.AlterReferences.Add(AlterReferenceDefinition()); break;
				case Keywords.Order: AStatement.AlterOrders.Add(AlterOrderDefinition()); break;
				default: throw new ParserException(ParserException.Codes.UnknownAlterDirective, FLexer[0].AsSymbol);
			}
        }
        
        protected void AlterViewDropDefinition(AlterViewStatement AStatement)
        {
			switch (FLexer.NextToken().AsSymbol)
			{
				case Keywords.Transition:
				case Keywords.Constraint: AStatement.DropConstraints.Add(DropConstraintDefinition(true)); break;
				case Keywords.Key: AStatement.DropKeys.Add(DropKeyDefinition()); break;
				case Keywords.Reference: AStatement.DropReferences.Add(DropReferenceDefinition()); break;
				case Keywords.Order: AStatement.DropOrders.Add(DropOrderDefinition()); break;
				default: throw new ParserException(ParserException.Codes.UnknownDropDirective, FLexer[0].AsSymbol);
			}
        }
		
		/* 
			BNF:
			<alter column definition> ::=
				create column <column definition> |
				alter column <column name> 
					[: <type specifier>] 
					<alter nilable definition>
					["{"<ne alter column definition item>"}"] 
					<alter metadata> |
				drop column <column name>
			
			<alter column definition item> ::=
				<alter default definition> |
				<alter constraint definition> |
				<alter nilable definition>
				
			<alter nilable definition> ::=
				[[not] nil]
		*/
        protected Statement AlterColumnDefinition()
        {
			AlterColumnDefinition LDefinition = new AlterColumnDefinition();
			LDefinition.SetPosition(FLexer);
			LDefinition.ColumnName = QualifiedIdentifier();
			if (FLexer.PeekTokenSymbol(1) == Keywords.TypeSpecifier)
			{
				FLexer.NextToken();
				LDefinition.TypeSpecifier = TypeSpecifier();
			}
			
			if (FLexer.PeekTokenSymbol(1) == Keywords.Not)
			{
				FLexer.NextToken();
				FLexer.NextToken().CheckType(TokenType.Nil);
				LDefinition.ChangeNilable = true;
				LDefinition.IsNilable = false;
			}
			else if (FLexer[1].Type == TokenType.Nil)
			{
				FLexer.NextToken();
				LDefinition.ChangeNilable = true;
				LDefinition.IsNilable = true;
			}
			
			if (FLexer.PeekTokenSymbol(1) == Keywords.BeginList)
			{
				FLexer.NextToken();
				bool LDone = false;
				do
				{
					FLexer.NextToken();
					if (FLexer[0].Type == TokenType.Nil)
					{
						LDefinition.ChangeNilable = true;
						LDefinition.IsNilable = true;
					}
					else
					{
						switch (FLexer[0].AsSymbol)
						{
							case Keywords.Not:
								FLexer.NextToken().CheckType(TokenType.Nil);
								LDefinition.ChangeNilable = true;
								LDefinition.IsNilable = false;
							break;
							
							case Keywords.Create:
								switch (FLexer.PeekTokenSymbol(1))
								{
									case Keywords.Default: 
										if (LDefinition.Default != null)
											throw new ParserException(ParserException.Codes.DefaultDefinitionExists);
										LDefinition.Default = DefaultDefinition();
									break;

									case Keywords.Constraint: 
										LDefinition.CreateConstraints.Add(ConstraintDefinition()); 
									break;
									
									default: throw new ParserException(ParserException.Codes.UnknownCreateDirective, FLexer.PeekTokenSymbol(1));
								}
							break;
							
							case Keywords.Alter:
								switch (FLexer.NextToken().AsSymbol)
								{
									case Keywords.Default: 
										if (LDefinition.Default != null)
											throw new ParserException(ParserException.Codes.DefaultDefinitionExists);
										LDefinition.Default = AlterDefaultDefinition(); 
									break;
									case Keywords.Constraint: LDefinition.AlterConstraints.Add(AlterConstraintDefinition()); break;
									default: throw new ParserException(ParserException.Codes.UnknownAlterDirective, FLexer[0].AsSymbol);
								}
							break;
							
							case Keywords.Drop:
								switch (FLexer.NextToken().AsSymbol)
								{
									case Keywords.Default: 
										if (LDefinition.Default != null)
											throw new ParserException(ParserException.Codes.DefaultDefinitionExists);
										LDefinition.Default = DropDefaultDefinition(); 
									break;
									case Keywords.Constraint: LDefinition.DropConstraints.Add(DropConstraintDefinition()); break;
									default: throw new ParserException(ParserException.Codes.UnknownDropDirective, FLexer[0].AsSymbol);
								}
							break;
							
							default: throw new ParserException(ParserException.Codes.DDLDirectiveExpected);
						}
					}
					
					switch (FLexer.NextToken().AsSymbol)
					{
						case Keywords.ListSeparator: break;
						case Keywords.EndList: LDone = true; break;
						default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
					}
				} while (!LDone);
			}
			
			AlterMetaData(LDefinition, false);
			LDefinition.SetEndPosition(FLexer);
			return LDefinition;
        }
        
        protected Statement DropColumnDefinition()
        {
			DropColumnDefinition LDefinition = new DropColumnDefinition();
			LDefinition.SetPosition(FLexer);
			LDefinition.ColumnName = QualifiedIdentifier();
			LDefinition.SetEndPosition(FLexer);
			return LDefinition;
        }
        
		/* 
			BNF:
			<alter constraint statement> ::=
				alter constraint <constraint name> [<expression>] <alter metadata>
        */
        protected Statement AlterConstraintStatement(int ALine, int ALinePos)
        {
			AlterConstraintStatement LStatement = new AlterConstraintStatement();
			LStatement.Line = ALine;
			LStatement.LinePos = ALinePos;
			LStatement.ConstraintName = QualifiedIdentifier();
			if (FLexer.PeekTokenSymbol(1) != Keywords.Alter)
				LStatement.Expression = Expression();
			AlterMetaData(LStatement, false);
			LStatement.SetEndPosition(FLexer);
			return LStatement;
        }
        
		/* 
			BNF:
			<alter constraint definition> ::=
				(create <constraint definition>) |
				(alter constraint <constraint name> [<expression>] <alter metadata>) |
				(drop constraint <constraint name>)
		*/
		protected Statement AlterConstraintDefinition()
		{
			AlterConstraintDefinition LDefinition = new AlterConstraintDefinition();
			LDefinition.SetPosition(FLexer);
			LDefinition.ConstraintName = QualifiedIdentifier();
			if (FLexer.PeekTokenSymbol(1) != Keywords.Alter)
				LDefinition.Expression = Expression();
			AlterMetaData(LDefinition, false);
			LDefinition.SetEndPosition(FLexer);
			return LDefinition;
		}
		
		/*
			BNF:
			<alter transition constraint definition> ::=
				alter transition constraint <constraint name>
					[<alter transition constraint definition item>]
					[<alter transition constraint definition item>]
					[<alter transition constraint definition item>]
					<alter metadata>
					
			<alter transition constraint definition item> ::=
				(create on <transition> <expression>) |
				(alter on <transition> <expression>) |
				(drop on <transition>)
				
			<transition> ::=
				insert | update | delete
		*/        
        protected Statement AlterTransitionConstraintDefinition()
        {
			AlterTransitionConstraintDefinition LDefinition = new AlterTransitionConstraintDefinition();
			LDefinition.SetPosition(FLexer);
			FLexer.NextToken();
			LDefinition.ConstraintName = QualifiedIdentifier();
			AlterTransitionConstraintDefinitionItem(LDefinition);
			AlterTransitionConstraintDefinitionItem(LDefinition);
			AlterTransitionConstraintDefinitionItem(LDefinition);
			AlterMetaData(LDefinition, (FLexer[0].Type == TokenType.Symbol) && (FLexer[0].AsSymbol == Keywords.Alter));
			LDefinition.SetEndPosition(FLexer);
			return LDefinition;
        }
        
        protected void AlterTransitionConstraintDefinitionItem(AlterTransitionConstraintDefinition ADefinition)
        {
			switch (FLexer.PeekTokenSymbol(1))
			{
				case Keywords.Create : 
					FLexer.NextToken();
					if (FLexer.PeekTokenSymbol(1) == Keywords.On)
					{
						FLexer.NextToken();
						switch (FLexer.NextToken().AsSymbol)
						{
							case Keywords.Insert : ADefinition.OnInsert = new AlterTransitionConstraintDefinitionCreateItem(Expression()); break;
							case Keywords.Update : ADefinition.OnUpdate = new AlterTransitionConstraintDefinitionCreateItem(Expression()); break;
							case Keywords.Delete : ADefinition.OnDelete = new AlterTransitionConstraintDefinitionCreateItem(Expression()); break;
							default : throw new ParserException(ParserException.Codes.UnknownConstraintTarget);
						}
					}
					break;
					
				case Keywords.Alter :
					FLexer.NextToken();
					if (FLexer.PeekTokenSymbol(1) == Keywords.On)
					{
						FLexer.NextToken();
						switch (FLexer.NextToken().AsSymbol)
						{
							case Keywords.Insert : ADefinition.OnInsert = new AlterTransitionConstraintDefinitionAlterItem(Expression()); break;
							case Keywords.Update : ADefinition.OnUpdate = new AlterTransitionConstraintDefinitionAlterItem(Expression()); break;
							case Keywords.Delete : ADefinition.OnDelete = new AlterTransitionConstraintDefinitionAlterItem(Expression()); break;
							default : throw new ParserException(ParserException.Codes.UnknownConstraintTarget);
						}
					}
					break;

				case Keywords.Drop :
					FLexer.NextToken();
					if (FLexer.PeekTokenSymbol(1) == Keywords.On)
					{
						FLexer.NextToken();
						switch (FLexer.NextToken().AsSymbol)
						{
							case Keywords.Insert : ADefinition.OnInsert = new AlterTransitionConstraintDefinitionDropItem(); break;
							case Keywords.Update : ADefinition.OnUpdate = new AlterTransitionConstraintDefinitionDropItem(); break;
							case Keywords.Delete : ADefinition.OnDelete = new AlterTransitionConstraintDefinitionDropItem(); break;
							default : throw new ParserException(ParserException.Codes.UnknownConstraintTarget);
						}
					}
					break;
			}
        }
        
        protected Statement DropConstraintDefinition(bool ATransitionContext)
        {
			DropConstraintDefinition LDefinition = new DropConstraintDefinition();
			LDefinition.SetPosition(FLexer);
			if ((ATransitionContext) && (FLexer[0].AsSymbol == Keywords.Transition))
			{
				FLexer.NextToken();
				LDefinition.IsTransition = true;
			}
			LDefinition.ConstraintName = QualifiedIdentifier();
			LDefinition.SetEndPosition(FLexer);
			return LDefinition;
        }
        
        protected Statement DropConstraintDefinition()
        {
			return DropConstraintDefinition(false);
        }

		/* 
			BNF:
			<alter key definition> ::=
				(create <key definition>) |
				(alter key "{"<column name commalist>"}" <alter metadata>) |
				(drop key "{"<column name commalist>"}")
		*/        
        protected Statement AlterKeyDefinition()
        {
			AlterKeyDefinition LDefinition = new AlterKeyDefinition();
			LDefinition.SetPosition(FLexer);
			KeyColumnList(LDefinition.Columns);
			AlterMetaData(LDefinition, false);
			LDefinition.SetEndPosition(FLexer);
			return LDefinition;
        }
        
        protected Statement DropKeyDefinition()
        {
			DropKeyDefinition LDefinition = new DropKeyDefinition();
			LDefinition.SetPosition(FLexer);
			KeyColumnList(LDefinition.Columns);
			LDefinition.SetEndPosition(FLexer);
			return LDefinition;
        }
        
		/* 
			BNF:
			<alter reference statement> ::=
				alter reference <reference name> <alter metadata>
        */
        protected Statement AlterReferenceStatement(int ALine, int ALinePos)
        {
			AlterReferenceStatement LStatement = new AlterReferenceStatement();
			LStatement.Line = ALine;
			LStatement.LinePos = ALinePos;
			LStatement.ReferenceName = QualifiedIdentifier();
			AlterMetaData(LStatement, false);
			LStatement.SetEndPosition(FLexer);
			return LStatement;
        }

		/* 
			BNF:
			<alter reference definition> ::=
				(create <reference definition>) |
				(alter reference <reference name> <alter metadata>) |
				(drop <reference name>)
		*/        
        protected Statement AlterReferenceDefinition()
        {
			AlterReferenceDefinition LDefinition = new AlterReferenceDefinition();
			LDefinition.SetPosition(FLexer);
			LDefinition.ReferenceName = QualifiedIdentifier();
			AlterMetaData(LDefinition, false);
			LDefinition.SetEndPosition(FLexer);
			return LDefinition;
        }
        
        protected Statement DropReferenceDefinition()
        {
			DropReferenceDefinition LDefinition = new DropReferenceDefinition();
			LDefinition.SetPosition(FLexer);
			LDefinition.ReferenceName = QualifiedIdentifier();
			LDefinition.SetEndPosition(FLexer);
			return LDefinition;
        }

		/* 
			BNF:
			<alter order definition> ::=
				(create <order definition>) |
				(alter order "{"<order column definition commalist>"}" <alter metadata>) |
				(drop order "{"<order column definition commalist>"}")
		*/        
        protected Statement AlterOrderDefinition()
        {
			AlterOrderDefinition LDefinition = new AlterOrderDefinition();
			LDefinition.SetPosition(FLexer);
			OrderColumnDefinitionList(LDefinition.Columns);
			AlterMetaData(LDefinition, false);
			LDefinition.SetEndPosition(FLexer);
			return LDefinition;
        }
        
        protected Statement DropOrderDefinition()
        {
			DropOrderDefinition LDefinition = new DropOrderDefinition();
			LDefinition.SetPosition(FLexer);
			OrderColumnDefinitionList(LDefinition.Columns);
			LDefinition.SetEndPosition(FLexer);
			return LDefinition;
        }
        
		/* 
			BNF:
			<alter scalar type statement> ::=
				alter type <scalar type name> 
					["{"<alter scalar type definition item commalist>"}"]
					<alter class definition>
					<alter metadata>
        */
        protected Statement AlterScalarTypeStatement(int ALine, int ALinePos)
        {
			AlterScalarTypeStatement LStatement = new AlterScalarTypeStatement();
			LStatement.Line = ALine;
			LStatement.LinePos = ALinePos;
			LStatement.ScalarTypeName = QualifiedIdentifier();
			if (FLexer.PeekTokenSymbol(1) == Keywords.BeginList)
			{
				FLexer.NextToken();
				bool LDone = false;
				do
				{
					AlterScalarTypeStatementItem(LStatement);
					switch (FLexer.NextToken().AsSymbol)
					{
						case Keywords.ListSeparator: break;
						case Keywords.EndList: LDone = true; break;
						default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
					}
				} while (!LDone);
			}

			if (FLexer.PeekTokenSymbol(1) == Keywords.Alter)
			{
				FLexer.NextToken();
				switch (FLexer.PeekTokenSymbol(1))
				{
					case Keywords.Class: 
						LStatement.AlterClassDefinition = AlterClassDefinition(); 
						AlterMetaData(LStatement, false);
					break;
					
					case Keywords.Tags: AlterMetaData(LStatement, true); break;
					default: throw new ParserException(ParserException.Codes.UnknownAlterDirective, FLexer.PeekTokenSymbol(1));
				}
			}
				
			LStatement.SetEndPosition(FLexer);
			return LStatement;
        }
        
		/* 
			BNF:
			<alter scalar type definition item> ::=
				<alter representation definition> |
				<alter constraint definition> |
				<alter default definition> |
				<alter special definition>
        */
        protected void AlterScalarTypeStatementItem(AlterScalarTypeStatement AStatement)
        {
			switch (FLexer.NextToken().AsSymbol)
			{
				case Keywords.Create: AlterScalarTypeCreateDefinition(AStatement); break;
				case Keywords.Alter: AlterScalarTypeAlterDefinition(AStatement); break;
				case Keywords.Drop: AlterScalarTypeDropDefinition(AStatement); break;
				default: throw new ParserException(ParserException.Codes.DDLDirectiveExpected);
			}
        }
        
        protected void AlterScalarTypeCreateDefinition(AlterScalarTypeStatement AStatement)
        {
			switch (FLexer.PeekTokenSymbol(1))
			{
				case Keywords.Representation: AStatement.CreateRepresentations.Add(RepresentationDefinition()); break;
				case Keywords.Constraint: AStatement.CreateConstraints.Add(ConstraintDefinition()); break;
				case Keywords.Default:
					if (AStatement.Default != null)
						throw new ParserException(ParserException.Codes.DefaultDefinitionExists);
					AStatement.Default = DefaultDefinition();
				break;
				case Keywords.Special: AStatement.CreateSpecials.Add(SpecialDefinition()); break;
				default: throw new ParserException(ParserException.Codes.UnknownCreateDirective, FLexer[0].AsSymbol);
			}
        }
        
        protected void AlterScalarTypeAlterDefinition(AlterScalarTypeStatement AStatement)
        {
			switch (FLexer.NextToken().AsSymbol)
			{
				case Keywords.Representation: AStatement.AlterRepresentations.Add(AlterRepresentationDefinition()); break;
				case Keywords.Constraint: AStatement.AlterConstraints.Add(AlterConstraintDefinition()); break;
				case Keywords.Default:
					if (AStatement.Default != null)
						throw new ParserException(ParserException.Codes.DefaultDefinitionExists);
					AStatement.Default = AlterDefaultDefinition();
				break;
				case Keywords.Special: AStatement.AlterSpecials.Add(AlterSpecialDefinition()); break;
				default: throw new ParserException(ParserException.Codes.UnknownAlterDirective, FLexer[0].AsSymbol);
			}
        }
        
        protected void AlterScalarTypeDropDefinition(AlterScalarTypeStatement AStatement)
        {
			switch (FLexer.NextToken().AsSymbol)
			{
				case Keywords.Representation: AStatement.DropRepresentations.Add(DropRepresentationDefinition()); break;
				case Keywords.Constraint: AStatement.DropConstraints.Add(DropConstraintDefinition()); break;
				case Keywords.Default:
					if (AStatement.Default != null)
						throw new ParserException(ParserException.Codes.DefaultDefinitionExists);
					AStatement.Default = DropDefaultDefinition();
				break;
				case Keywords.Special: AStatement.DropSpecials.Add(DropSpecialDefinition()); break;
				default: throw new ParserException(ParserException.Codes.UnknownDropDirective, FLexer[0].AsSymbol);
			}
        }
        
		/* 
			BNF:
			<alter representation definition> ::=
				(create <representation definition>) |
				(
					alter representation 
						<representation name> 
						["{"<ne alter property definition commalist>"}"] 
						[alter selector <alter accessor block>]
						<alter metadata>
				) |
				(drop representation <representation name>)
				
			<alter accessor block> ::=
				<alter class definition> | <expression> | <block>
		*/        
        protected Statement AlterRepresentationDefinition()
        {
			AlterRepresentationDefinition LDefinition = new AlterRepresentationDefinition();
			LDefinition.SetPosition(FLexer);
			LDefinition.RepresentationName = QualifiedIdentifier();
			if (FLexer.PeekTokenSymbol(1) == Keywords.BeginList)
			{
				FLexer.NextToken();
				bool LDone = false;
				do
				{
					switch (FLexer.NextToken().AsSymbol)
					{
						case Keywords.Create: LDefinition.CreateProperties.Add(PropertyDefinition()); break;
						case Keywords.Alter: LDefinition.AlterProperties.Add(AlterPropertyDefinition()); break;
						case Keywords.Drop: LDefinition.DropProperties.Add(DropPropertyDefinition()); break;
						default: throw new ParserException(ParserException.Codes.DDLDirectiveExpected);
					}
					
					switch (FLexer.NextToken().AsSymbol)
					{
						case Keywords.ListSeparator: break;
						case Keywords.EndList: LDone = true; break;
						default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
					}
				} while (!LDone);
			}
			
			if (FLexer.PeekTokenSymbol(1) == Keywords.Alter)
			{
				FLexer.NextToken();
				switch (FLexer.PeekTokenSymbol(1))
				{
					case Keywords.Selector:
						FLexer.NextToken();
						LDefinition.SelectorAccessorBlock = new AlterAccessorBlock();
						AlterAccessorBlock(LDefinition.SelectorAccessorBlock); 
						AlterMetaData(LDefinition, false);
					break;
					
					case Keywords.Tags: AlterMetaData(LDefinition, true); break;
					default: throw new ParserException(ParserException.Codes.UnknownAlterDirective, FLexer.PeekTokenSymbol(1));
				}
			}
				
			LDefinition.SetEndPosition(FLexer);
			return LDefinition;
        }
        
        protected void AlterAccessorBlock(AlterAccessorBlock AAccessorBlock)
        {
			switch (FLexer.PeekTokenSymbol(1))
			{
				case Keywords.Alter :
					FLexer.NextToken(); 
					AAccessorBlock.AlterClassDefinition = AlterClassDefinition();
				break;
				
				case Keywords.Begin :
					FLexer.NextToken();
					AAccessorBlock.Block = Block();
					FLexer.NextToken().CheckSymbol(Keywords.End);
				break;
				
				default : AAccessorBlock.Expression = Expression(); break;
			}
        }
        
        protected Statement DropRepresentationDefinition()
        {
			DropRepresentationDefinition LDefinition = new DropRepresentationDefinition();
			LDefinition.SetPosition(FLexer);
			LDefinition.RepresentationName = QualifiedIdentifier();
			LDefinition.SetEndPosition(FLexer);
			return LDefinition;
        }
        
		/* 
			BNF:
			<alter property definition> ::=
				(create <property definition>) |
				(
					alter <property name>
						[: <type specifier>]
						[alter read <alter accessor block>]
						[alter write <alter accessor block>]
						<alter metadata>
				) |
				(drop <property name>)
        */
        protected Statement AlterPropertyDefinition()
        {
			int LLine = FLexer[0, false].Line;
			int LLinePos = FLexer[0, false].LinePos;
			AlterPropertyDefinition LDefinition = new AlterPropertyDefinition(QualifiedIdentifier());
			LDefinition.Line = LLine;
			LDefinition.LinePos = LLinePos;
			if (FLexer.PeekTokenSymbol(1) == Keywords.TypeSpecifier)
			{
				FLexer.NextToken();
				LDefinition.PropertyType = TypeSpecifier();
			}
			
			if (FLexer.PeekTokenSymbol(1) == Keywords.Alter)
			{
				FLexer.NextToken();
				FLexer.NextToken().CheckSymbol(Keywords.Read);
				LDefinition.ReadAccessorBlock = new AlterAccessorBlock();
				AlterAccessorBlock(LDefinition.ReadAccessorBlock);
			}
			
			if (FLexer.PeekTokenSymbol(1) == Keywords.Alter)
			{
				FLexer.NextToken();
				FLexer.NextToken().CheckSymbol(Keywords.Write);
				LDefinition.WriteAccessorBlock = new AlterAccessorBlock();
				AlterAccessorBlock(LDefinition.WriteAccessorBlock);
			}
			
			AlterMetaData(LDefinition, false);
			LDefinition.SetEndPosition(FLexer);
			return LDefinition;
        }
        
        protected Statement DropPropertyDefinition()
        {
			DropPropertyDefinition LDefinition = new DropPropertyDefinition();
			LDefinition.SetPosition(FLexer);
			LDefinition.PropertyName = QualifiedIdentifier();
			LDefinition.SetEndPosition(FLexer);
			return LDefinition;
        }

		/* 
			BNF:
			<alter special definition> ::=
				(create <special definition>) |
				(alter special <special name> [<expression>] <alter metadata>) |
				(drop special <special name>)
		*/        
        protected Statement AlterSpecialDefinition()
        {
			AlterSpecialDefinition LDefinition = new AlterSpecialDefinition();
			LDefinition.SetPosition(FLexer);
			LDefinition.Name = QualifiedIdentifier();
			if (FLexer.PeekTokenSymbol(1) != Keywords.Alter)
				LDefinition.Value = Expression();
			AlterMetaData(LDefinition, false);
			LDefinition.SetEndPosition(FLexer);
			return LDefinition;
        }
        
        protected Statement DropSpecialDefinition()
        {
			DropSpecialDefinition LDefinition = new DropSpecialDefinition();
			LDefinition.SetPosition(FLexer);
			LDefinition.Name = QualifiedIdentifier();
			LDefinition.SetEndPosition(FLexer);
			return LDefinition;
        }
        
		/* 
			BNF:
			<alter default definition> ::=
				(create <default definition>) |
				(alter default [<expression>] <alter metadata>) |
				(drop default)
		*/
        protected AlterDefaultDefinition AlterDefaultDefinition()
        {
			AlterDefaultDefinition LDefinition = new AlterDefaultDefinition();
			LDefinition.SetPosition(FLexer);
			if (FLexer.PeekTokenSymbol(1) != Keywords.Alter)
				LDefinition.Expression = Expression();
			AlterMetaData(LDefinition, false);
			LDefinition.SetEndPosition(FLexer);
			return LDefinition;
        }
        
        protected DropDefaultDefinition DropDefaultDefinition()
        {
			DropDefaultDefinition LDefinition = new DropDefaultDefinition();
			LDefinition.SetPosition(FLexer);
			LDefinition.SetEndPosition(FLexer);
			return LDefinition;
        }
        
		/* 
			BNF:
			<alter operator statement> ::=
				alter operator <operator name>"("<formal parameter specifier commalist>")"
					[(<alter class definition> | <block>)]
					<alter metadata>
		*/        
        protected Statement AlterOperatorStatement(int ALine, int ALinePos)
        {
			AlterOperatorStatement LStatement = new AlterOperatorStatement();
			LStatement.Line = ALine;
			LStatement.LinePos = ALinePos;
			LStatement.OperatorSpecifier = OperatorSpecifier();
			
			if (FLexer.PeekTokenSymbol(1) == Keywords.Alter)
			{
				FLexer.NextToken();
				if (FLexer.PeekTokenSymbol(1) == Keywords.Class)
				{
					LStatement.Block.SetPosition(FLexer);
					LStatement.Block.AlterClassDefinition = AlterClassDefinition();
					LStatement.Block.SetEndPosition(FLexer);
					AlterMetaData(LStatement, false);
				}
				else
					AlterMetaData(LStatement, true);
			}
			else
			{
				FLexer.NextToken().CheckSymbol(Keywords.Begin);
				LStatement.Block.SetPosition(FLexer);
				LStatement.Block.Block = Block();
				FLexer.NextToken().CheckSymbol(Keywords.End);
				LStatement.Block.SetEndPosition(FLexer);
				AlterMetaData(LStatement, false);
			}

			LStatement.SetEndPosition(FLexer);
			return LStatement;
        }

		/* 
			BNF:
			<alter aggregate operator statement> ::=
				alter aggregate operator <operator name>"("<formal parameter specifier commalist>")"
					[initialization (<alter class definition> | <block>)]
					[aggregation (<alter class definition> | <block>)]
					[finalization (<alter class definition> | <block>)]
					<alter metadata>
		*/        
        protected Statement AlterAggregateOperatorStatement(int ALine, int ALinePos)
        {
			AlterAggregateOperatorStatement LStatement = new AlterAggregateOperatorStatement();
			LStatement.Line = ALine;
			LStatement.LinePos = ALinePos;
			FLexer.NextToken().CheckSymbol(Keywords.Operator);
			LStatement.OperatorSpecifier = OperatorSpecifier();
			
			if (FLexer.PeekTokenSymbol(1) == Keywords.Initialization)
			{
				FLexer.NextToken();
				if (FLexer.PeekTokenSymbol(1) == Keywords.Alter)
				{
					LStatement.Initialization.SetPosition(FLexer);
					LStatement.Initialization.AlterClassDefinition = AlterClassDefinition();
					LStatement.Initialization.SetEndPosition(FLexer);
				}
				else
				{
					FLexer.NextToken().CheckSymbol(Keywords.Begin);
					LStatement.Initialization.SetPosition(FLexer);
					LStatement.Initialization.Block = Block();
					FLexer.NextToken().CheckSymbol(Keywords.End);
					LStatement.Initialization.SetEndPosition(FLexer);
				}
			}
			
			if (FLexer.PeekTokenSymbol(1) == Keywords.Aggregation)
			{
				FLexer.NextToken();
				if (FLexer.PeekTokenSymbol(1) == Keywords.Alter)
				{
					LStatement.Aggregation.SetPosition(FLexer);
					LStatement.Aggregation.AlterClassDefinition = AlterClassDefinition();
					LStatement.Aggregation.SetEndPosition(FLexer);
				}
				else
				{
					FLexer.NextToken().CheckSymbol(Keywords.Begin);
					LStatement.Aggregation.SetPosition(FLexer);
					LStatement.Aggregation.Block = Block();
					FLexer.NextToken().CheckSymbol(Keywords.End);
					LStatement.Aggregation.SetEndPosition(FLexer);
				}
			}
			
			if (FLexer.PeekTokenSymbol(1) == Keywords.Finalization)
			{
				FLexer.NextToken();
				if (FLexer.PeekTokenSymbol(1) == Keywords.Alter)
				{
					LStatement.Finalization.SetPosition(FLexer);
					LStatement.Finalization.AlterClassDefinition = AlterClassDefinition();
					LStatement.Finalization.SetEndPosition(FLexer);
				}
				else
				{
					FLexer.NextToken().CheckSymbol(Keywords.Begin);
					LStatement.Finalization.SetPosition(FLexer);
					LStatement.Finalization.Block = Block();
					FLexer.NextToken().CheckSymbol(Keywords.End);
					LStatement.Finalization.SetEndPosition(FLexer);
				}
			}
			
			AlterMetaData(LStatement, false);
			LStatement.SetEndPosition(FLexer);
			return LStatement;
        }

		/* 
			BNF:
			<alter server link statement> ::=
				alter server <server link name> <alter metadata>
		*/        
        protected Statement AlterServerStatement(int ALine, int ALinePos)
        {
			AlterServerStatement LStatement = new AlterServerStatement();
			LStatement.Line = ALine;
			LStatement.LinePos = ALinePos;
			LStatement.ServerName = QualifiedIdentifier();
			AlterMetaData(LStatement, false);
			LStatement.SetEndPosition(FLexer);
			return LStatement;
        }
        
		/* 
			BNF:
			<alter device statement> ::=
				alter device <device name> 
					["{"<alter device map item commalist>"}"]
					<alter reconciliation settings>
					<alter class definition> 
					<alter metadata>

			<alter reconciliation settings> ::=
				[alter reconciliation "{"<reconciliation settings item commalist>"}"]
		*/
        protected Statement AlterDeviceStatement(int ALine, int ALinePos)
        {
			AlterDeviceStatement LStatement = new AlterDeviceStatement();
			LStatement.Line = ALine;
			LStatement.LinePos = ALinePos;
			LStatement.DeviceName = QualifiedIdentifier();
			
			if (FLexer.PeekTokenSymbol(1) == Keywords.BeginList)
			{
				FLexer.NextToken();
				bool LDone = false;
				do
				{
					AlterDeviceStatementItem(LStatement);
					switch (FLexer.NextToken().AsSymbol)
					{
						case Keywords.ListSeparator: break;
						case Keywords.EndList: LDone = true; break;
						default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
					}
				} while (!LDone);
			}

			if (FLexer.PeekTokenSymbol(1) == Keywords.Alter)
			{
				FLexer.NextToken();
				switch (FLexer.PeekTokenSymbol(1))
				{
					case Keywords.Reconciliation:
						LStatement.ReconciliationSettings = ReconciliationSettings();
						if (FLexer.PeekTokenSymbol(1) == Keywords.Alter)
						{
							FLexer.NextToken();
							switch (FLexer.PeekTokenSymbol(1))
							{
								case Keywords.Class:
									LStatement.AlterClassDefinition = AlterClassDefinition();
									AlterMetaData(LStatement, false);
								break;
								
								case Keywords.Tags: AlterMetaData(LStatement, true); break;
								default: throw new ParserException(ParserException.Codes.UnknownAlterDirective, FLexer.PeekTokenSymbol(1));
							}
						}
					break;
					
					case Keywords.Class: 
						LStatement.AlterClassDefinition = AlterClassDefinition(); 
						AlterMetaData(LStatement, false);
					break;
					
					case Keywords.Tags: AlterMetaData(LStatement, true); break;
					default: throw new ParserException(ParserException.Codes.UnknownAlterDirective, FLexer.PeekTokenSymbol(1));
				}
			}
				
			LStatement.SetEndPosition(FLexer);
			return LStatement;
        }
        
		/* 
			BNF:
			<alter device map item> ::=
				<alter device scalar type map> |
				<alter device operator map> |
				<alter device store definition>
				
			<alter device scalar type map> ::=
				(create <device scalar type map>) | 
				(alter type <scalar type name> [<alter class definition>] <alter metadata>) | 
				(drop type <scalar type name>)
				
			<alter device operator map> ::=
				(create <device operator map>) |
				(alter operator <operator specifier> [<alter class definition>] <alter metadata>) |
				(drop operator <operator specifier>)
				
			<alter device store definition> ::=
				(create <device store definition>) |
				(alter store <store name> 
					[<expression>] 
					[alter by (default | ("{"<index column definition commalist>"}" <metadata>))] 
					[alter indexes (default | "{"<alter index definition commalist>"}")] 
					<alter metadata>) |
				(drop store <store name>)
				
			<alter index definition> ::=
				(create <index definition>) |
				(alter index "{"<index definition commalist>"}" <alter metadata>) |
				(drop index "{"<index definition commalist>"}")
        */
        protected void AlterDeviceStatementItem(AlterDeviceStatement AStatement)
        {
			switch (FLexer.NextToken().AsSymbol)
			{
				case Keywords.Create: AlterDeviceCreateItem(AStatement); break;
				case Keywords.Alter: AlterDeviceAlterItem(AStatement); break;
				case Keywords.Drop: AlterDeviceDropItem(AStatement); break;
				default: throw new ParserException(ParserException.Codes.DDLDirectiveExpected);
			}
        }
        
        protected void AlterDeviceCreateItem(AlterDeviceStatement AStatement)
        {
			switch (FLexer.NextToken().AsSymbol)
			{
				case Keywords.Type: AStatement.CreateDeviceScalarTypeMaps.Add(DeviceScalarTypeMap()); break;
				case Keywords.Operator: AStatement.CreateDeviceOperatorMaps.Add(DeviceOperatorMap()); break;
				case Keywords.Store: AStatement.CreateDeviceStoreDefinitions.Add(DeviceStoreDefinition()); break;
				default: throw new ParserException(ParserException.Codes.UnknownCreateDirective, FLexer[0].AsSymbol);
			}
        }
        
        protected void AlterDeviceAlterItem(AlterDeviceStatement AStatement)
        {
			switch (FLexer.PeekTokenSymbol(1))
			{
				case Keywords.Type: AStatement.AlterDeviceScalarTypeMaps.Add(AlterDeviceScalarTypeMap()); break;
				case Keywords.Operator: AStatement.AlterDeviceOperatorMaps.Add(AlterDeviceOperatorMap()); break;
				case Keywords.Store: AStatement.AlterDeviceStoreDefinitions.Add(AlterDeviceStoreDefinition()); break;
				default: throw new ParserException(ParserException.Codes.UnknownAlterDirective, FLexer[0].AsSymbol);
			}
        }
        
        protected AlterDeviceScalarTypeMap AlterDeviceScalarTypeMap()
        {
			AlterDeviceScalarTypeMap LAlterDeviceScalarTypeMap = new AlterDeviceScalarTypeMap();
			LAlterDeviceScalarTypeMap.SetPosition(FLexer);
			FLexer.NextToken().CheckSymbol(Keywords.Type);
			LAlterDeviceScalarTypeMap.ScalarTypeName = QualifiedIdentifier();
			FLexer.NextToken().CheckSymbol(Keywords.Alter);
			if (FLexer.PeekTokenSymbol(1) == Keywords.Class)
			{
				LAlterDeviceScalarTypeMap.AlterClassDefinition = AlterClassDefinition();
				AlterMetaData(LAlterDeviceScalarTypeMap, false);
			}
			else
				AlterMetaData(LAlterDeviceScalarTypeMap, true);
			LAlterDeviceScalarTypeMap.SetEndPosition(FLexer);
			return LAlterDeviceScalarTypeMap;
        }
        
        protected AlterDeviceOperatorMap AlterDeviceOperatorMap()
        {
			AlterDeviceOperatorMap LAlterDeviceOperatorMap = new AlterDeviceOperatorMap();
			LAlterDeviceOperatorMap.SetPosition(FLexer);
			FLexer.NextToken().CheckSymbol(Keywords.Operator);
			LAlterDeviceOperatorMap.OperatorSpecifier = OperatorSpecifier();
			FLexer.NextToken().CheckSymbol(Keywords.Alter);
			if (FLexer.PeekTokenSymbol(1) == Keywords.Class)
			{
				LAlterDeviceOperatorMap.AlterClassDefinition = AlterClassDefinition();
				AlterMetaData(LAlterDeviceOperatorMap, false);
			}
			else
				AlterMetaData(LAlterDeviceOperatorMap, true);
			LAlterDeviceOperatorMap.SetEndPosition(FLexer);
			return LAlterDeviceOperatorMap;
        }
        
        protected AlterDeviceStoreDefinition AlterDeviceStoreDefinition()
        {
			AlterDeviceStoreDefinition LDefinition = new AlterDeviceStoreDefinition();
			LDefinition.SetPosition(FLexer);
			FLexer.NextToken().CheckSymbol(Keywords.Store);
			LDefinition.StoreName = QualifiedIdentifier();
			if (FLexer.PeekTokenSymbol(1) != Keywords.Alter)
				LDefinition.Expression = Expression();
			FLexer.NextToken().CheckSymbol(Keywords.Alter);
			switch (FLexer.PeekTokenSymbol(1))
			{
				case Keywords.By : 
					FLexer.NextToken();
					if (FLexer.PeekTokenSymbol(1) == Keywords.Default)
					{
						FLexer.NextToken();
						LDefinition.ClusteredDefault = true;
					}
					else
					{
						LDefinition.ClusteredIndexDefinition = new IndexDefinition();
						LDefinition.ClusteredIndexDefinition.SetPosition(FLexer);
						IndexColumnDefinitionList(LDefinition.ClusteredIndexDefinition.Columns);
						MetaData(LDefinition.ClusteredIndexDefinition);
					}
				break;

				case Keywords.Indexes : AlterDeviceStoreDefinitionIndexes(LDefinition); break;

				case Keywords.Tags : AlterMetaData(LDefinition, true); break;
				default : throw new ParserException(ParserException.Codes.UnknownAlterDirective, FLexer[0].AsSymbol);
			}

			if (FLexer.PeekTokenSymbol(1) == Keywords.Alter)
			{
				FLexer.NextToken();
				switch (FLexer.PeekTokenSymbol(1))
				{
					case Keywords.Indexes : AlterDeviceStoreDefinitionIndexes(LDefinition); break;

					case Keywords.Tags : AlterMetaData(LDefinition, true); break;
				}
			}

			if (FLexer.PeekTokenSymbol(1) == Keywords.Alter)
				AlterMetaData(LDefinition, true);

			LDefinition.SetEndPosition(FLexer);
			return LDefinition;
        }
        
        protected void AlterDeviceStoreDefinitionIndexes(AlterDeviceStoreDefinition ADefinition)
        {
			FLexer.NextToken();
			if (FLexer.PeekTokenSymbol(1) == Keywords.Default)
			{
				FLexer.NextToken();
				ADefinition.IndexesDefault = true;
			}
			else
			{
				FLexer.NextToken().CheckSymbol(Keywords.BeginList);
				bool LDone = false;
				while (!LDone)
				{
					switch (FLexer.NextToken().AsSymbol)
					{
						case Keywords.Create : ADefinition.CreateIndexDefinitions.Add(IndexDefinition()); break;
						case Keywords.Alter : ADefinition.AlterIndexDefinitions.Add(AlterIndexDefinition()); break;
						case Keywords.Drop : ADefinition.DropIndexDefinitions.Add(DropIndexDefinition()); break;
						default : throw new ParserException(ParserException.Codes.DDLDirectiveExpected);
					}
					
					switch (FLexer.NextToken().AsSymbol)
					{
						case Keywords.ListSeparator : break;
						case Keywords.EndList : LDone = true; break;
						default : throw new ParserException(ParserException.Codes.ListTerminatorExpected);
					}
				}
			}
        }
        
        protected AlterIndexDefinition AlterIndexDefinition()
        {
			AlterIndexDefinition LDefinition = new AlterIndexDefinition();
			LDefinition.SetPosition(FLexer);
			FLexer.NextToken().CheckSymbol(Keywords.Index);
			IndexColumnDefinitionList(LDefinition.Columns);
			AlterMetaData(LDefinition, true);
			LDefinition.SetEndPosition(FLexer);
			return LDefinition;
        }
        
        protected DropIndexDefinition DropIndexDefinition()
        {
			DropIndexDefinition LDefinition = new DropIndexDefinition();
			LDefinition.SetPosition(FLexer);
			FLexer.NextToken().CheckSymbol(Keywords.Index);
			IndexColumnDefinitionList(LDefinition.Columns);
			LDefinition.SetEndPosition(FLexer);
			return LDefinition;
        }
        
        protected void AlterDeviceDropItem(AlterDeviceStatement AStatement)
        {
			switch (FLexer.PeekTokenSymbol(1))
			{
				case Keywords.Type: AStatement.DropDeviceScalarTypeMaps.Add(DropDeviceScalarTypeMap()); break;
				case Keywords.Operator: AStatement.DropDeviceOperatorMaps.Add(DropDeviceOperatorMap()); break;
				case Keywords.Store: AStatement.DropDeviceStoreDefinitions.Add(DropDeviceStoreDefinition()); break;
				default: throw new ParserException(ParserException.Codes.UnknownDropDirective, FLexer[0].AsSymbol);
			}
        }
        
        protected DropDeviceScalarTypeMap DropDeviceScalarTypeMap()
        {
			DropDeviceScalarTypeMap LDropDeviceScalarTypeMap = new DropDeviceScalarTypeMap();
			LDropDeviceScalarTypeMap.SetPosition(FLexer);
			FLexer.NextToken().CheckSymbol(Keywords.Type);
			LDropDeviceScalarTypeMap.ScalarTypeName = QualifiedIdentifier();
			LDropDeviceScalarTypeMap.SetEndPosition(FLexer);
			return LDropDeviceScalarTypeMap;
        }
        
        protected DropDeviceOperatorMap DropDeviceOperatorMap()
        {
			DropDeviceOperatorMap LDropDeviceOperatorMap = new DropDeviceOperatorMap();
			LDropDeviceOperatorMap.SetPosition(FLexer);
			FLexer.NextToken().CheckSymbol(Keywords.Operator);
			LDropDeviceOperatorMap.OperatorSpecifier = OperatorSpecifier();
			LDropDeviceOperatorMap.SetEndPosition(FLexer);
			return LDropDeviceOperatorMap;
        }
        
        protected DropDeviceStoreDefinition DropDeviceStoreDefinition()
        {
			DropDeviceStoreDefinition LDefinition = new DropDeviceStoreDefinition();
			LDefinition.SetPosition(FLexer);
			FLexer.NextToken().CheckSymbol(Keywords.Store);
			LDefinition.StoreName = QualifiedIdentifier();
			LDefinition.SetEndPosition(FLexer);
			return LDefinition;
        }
        
        /*
			BNF:
			<alter sort statement> ::=
				alter sort <scalar type name> [using <expression>] <alter metadata>
        */
        protected AlterSortStatement AlterSortStatement(int ALine, int ALinePos)
        {
			AlterSortStatement LStatement = new AlterSortStatement();
			LStatement.Line = ALine;
			LStatement.LinePos = ALinePos;
			LStatement.ScalarTypeName = QualifiedIdentifier();
			if (FLexer.PeekTokenSymbol(1) == Keywords.Using)
			{
				FLexer.NextToken();
				LStatement.Expression = Expression();
			}
			AlterMetaData(LStatement, false);
			LStatement.SetEndPosition(FLexer);
			return LStatement;
        }
        
        /*
			BNF:
			<alter role statement> ::=
				alter role <role name> <alter metadata>
		*/
		protected AlterRoleStatement AlterRoleStatement(int ALine, int ALinePos)
		{
			AlterRoleStatement LStatement = new AlterRoleStatement();
			LStatement.Line = ALine;
			LStatement.LinePos = ALinePos;
			LStatement.RoleName = QualifiedIdentifier();
			AlterMetaData(LStatement, false);
			LStatement.SetEndPosition(FLexer);
			return LStatement;
		}
		
		/* 
			BNF:
            <drop statement> ::=
                (drop table <table name>) |
                (drop view <view name>) |
                (drop constraint <constraint name>) |
                (drop reference <reference name>) |
                (drop type <scalar type name>) |
                (drop operator <operator name>"("<formal parameter specifier commalist>")") |
				(drop aggregate operator <operator name>"("<formal parameter specifier commalist>")") |
                (drop device <device name>) |
				(drop server <server name>) |
                (drop sort <scalar type name>) |
                (drop conversion <scalar type name> to <scalar type name> using <operator name>) |
                (drop role <role name>) |
                (drop right <right name>)
		*/
        protected Statement DropStatement()
        {
			FLexer.NextToken();
			int LLine = FLexer[0, false].Line;
			int LLinePos = FLexer[0, false].LinePos;
			switch (FLexer.NextToken().AsSymbol)
			{
				case Keywords.Table: return DropTableStatement(LLine, LLinePos);
				case Keywords.View: return DropViewStatement(LLine, LLinePos);
				case Keywords.Constraint: return DropConstraintStatement(LLine, LLinePos);
				case Keywords.Reference: return DropReferenceStatement(LLine, LLinePos);
				case Keywords.Type: return DropScalarTypeStatement(LLine, LLinePos);
				case Keywords.Operator: return DropOperatorStatement(LLine, LLinePos);
				case Keywords.Aggregate:
					FLexer.NextToken().CheckSymbol(Keywords.Operator);
					return DropOperatorStatement(LLine, LLinePos);
				case Keywords.Server: return DropServerStatement(LLine, LLinePos);
				case Keywords.Device: return DropDeviceStatement(LLine, LLinePos);
				case Keywords.Sort: return DropSortStatement(LLine, LLinePos);
				case Keywords.Conversion: return DropConversionStatement(LLine, LLinePos);
				case Keywords.Role: return DropRoleStatement(LLine, LLinePos);
				case Keywords.Right: return DropRightStatement(LLine, LLinePos);
				default: throw new ParserException(ParserException.Codes.UnknownDropDirective, FLexer[0].AsSymbol);
			}
        }
        
        protected DropTableStatement DropTableStatement(int ALine, int ALinePos)
        {
			DropTableStatement LStatement = new DropTableStatement();
			LStatement.Line = ALine;
			LStatement.LinePos = ALinePos;
			LStatement.ObjectName = QualifiedIdentifier();
			LStatement.SetEndPosition(FLexer);
			return LStatement;
        }
        
        protected DropViewStatement DropViewStatement(int ALine, int ALinePos)
        {
			DropViewStatement LStatement = new DropViewStatement();
			LStatement.Line = ALine;
			LStatement.LinePos = ALinePos;
			LStatement.ObjectName = QualifiedIdentifier();
			LStatement.SetEndPosition(FLexer);
			return LStatement;
        }
        
        protected DropConstraintStatement DropConstraintStatement(int ALine, int ALinePos)
        {
			DropConstraintStatement LStatement = new DropConstraintStatement();
			LStatement.Line = ALine;
			LStatement.LinePos = ALinePos;
			LStatement.ConstraintName = QualifiedIdentifier();
			LStatement.SetEndPosition(FLexer);
			return LStatement;
        }
        
        protected DropReferenceStatement DropReferenceStatement(int ALine, int ALinePos)
        {
			DropReferenceStatement LStatement = new DropReferenceStatement();
			LStatement.Line = ALine;
			LStatement.LinePos = ALinePos;
			LStatement.ReferenceName = QualifiedIdentifier();
			LStatement.SetEndPosition(FLexer);
			return LStatement;
        }
        
        protected DropScalarTypeStatement DropScalarTypeStatement(int ALine, int ALinePos)
        {
			DropScalarTypeStatement LStatement = new DropScalarTypeStatement();
			LStatement.Line = ALine;
			LStatement.LinePos = ALinePos;
			LStatement.ObjectName = QualifiedIdentifier();
			LStatement.SetEndPosition(FLexer);
			return LStatement;
        }

        protected DropOperatorStatement DropOperatorStatement(int ALine, int ALinePos)
        {
			DropOperatorStatement LStatement = new DropOperatorStatement();
			LStatement.Line = ALine;
			LStatement.LinePos = ALinePos;
			LStatement.ObjectName = QualifiedIdentifier();
			FormalParameterSpecifiers(LStatement.FormalParameterSpecifiers);
			LStatement.SetEndPosition(FLexer);
			return LStatement;
        }
        
        protected DropServerStatement DropServerStatement(int ALine, int ALinePos)
        {
			DropServerStatement LStatement = new DropServerStatement();
			LStatement.Line = ALine;
			LStatement.LinePos = ALinePos;
			LStatement.ObjectName = QualifiedIdentifier();
			LStatement.SetEndPosition(FLexer);
			return LStatement;
        }
        
        protected DropDeviceStatement DropDeviceStatement(int ALine, int ALinePos)
        {
			DropDeviceStatement LStatement = new DropDeviceStatement();
			LStatement.Line = ALine;
			LStatement.LinePos = ALinePos;
			LStatement.ObjectName = QualifiedIdentifier();
			LStatement.SetEndPosition(FLexer);
			return LStatement;
        }

        protected DropSortStatement DropSortStatement(int ALine, int ALinePos)
        {
			DropSortStatement LStatement = new DropSortStatement();
			LStatement.Line = ALine;
			LStatement.LinePos = ALinePos;
			LStatement.ScalarTypeName = QualifiedIdentifier();
			LStatement.SetEndPosition(FLexer);
			return LStatement;
        }
        
        protected DropConversionStatement DropConversionStatement(int ALine, int ALinePos)
        {
			DropConversionStatement LStatement = new DropConversionStatement();
			LStatement.Line = ALine;
			LStatement.LinePos = ALinePos;
			LStatement.SourceScalarTypeName = TypeSpecifier();
			FLexer.NextToken().CheckSymbol(Keywords.To);
			LStatement.TargetScalarTypeName = TypeSpecifier();
			LStatement.SetEndPosition(FLexer);
			return LStatement;
		}
		
		protected DropRoleStatement DropRoleStatement(int ALine, int ALinePos)
		{
			DropRoleStatement LStatement = new DropRoleStatement();
			LStatement.Line = ALine;
			LStatement.LinePos = ALinePos;
			LStatement.RoleName = QualifiedIdentifier();
			LStatement.SetEndPosition(FLexer);
			return LStatement;
		}
		
		protected DropRightStatement DropRightStatement(int ALine, int ALinePos)
		{
			DropRightStatement LStatement = new DropRightStatement();
			LStatement.Line = ALine;
			LStatement.LinePos = ALinePos;
			LStatement.RightName = QualifiedIdentifier();
			LStatement.SetEndPosition(FLexer);
			return LStatement;
		}

		/*
			BNF:
			<attach statement> ::=
				attach [operator] <operator name> 
					to <event source specifier> 
					<event specifier clause>
					[before "{"<ne operator name commalist>"}"]
					<metadata>
		*/
		protected AttachStatement AttachStatement()
		{
			AttachStatement LStatement = new AttachStatement();
			FLexer.NextToken().CheckSymbol(Keywords.Attach);
			LStatement.SetPosition(FLexer);
			if (FLexer.PeekTokenSymbol(1) == Keywords.Operator)
				FLexer.NextToken();
			LStatement.OperatorName = QualifiedIdentifier();
			FLexer.NextToken().CheckSymbol(Keywords.To);
			LStatement.EventSourceSpecifier = EventSourceSpecifier();
			LStatement.EventSpecifier = EventSpecifierClause();
			if (FLexer.PeekTokenSymbol(1) == Keywords.Before)
			{
				FLexer.NextToken();
				FLexer.NextToken().CheckSymbol(Keywords.BeginList);
				bool LDone = false;
				do
				{
					LStatement.BeforeOperatorNames.Add(QualifiedIdentifier());
					
					switch (FLexer.NextToken().AsSymbol)
					{
						case Keywords.ListSeparator : break;
						case Keywords.EndList : LDone = true; break;
						default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
					}
				} while (!LDone);
			}
			MetaData(LStatement);
			LStatement.SetEndPosition(FLexer);
			return LStatement;
		}
		
		/*
			BNF:
			<event source specifier> ::=
				<tablevar name> |
				(<column name> in <tablevar name>) |
				<scalar type name>
		*/
		protected EventSourceSpecifier EventSourceSpecifier()
		{
			string LIdentifier = QualifiedIdentifier();
			if (FLexer.PeekTokenSymbol(1) == Keywords.In)
			{
				ColumnEventSourceSpecifier LColumnSpecifier = new ColumnEventSourceSpecifier();
				FLexer.NextToken();
				LColumnSpecifier.SetPosition(FLexer);
				LColumnSpecifier.TableVarName = QualifiedIdentifier();
				LColumnSpecifier.ColumnName = LIdentifier;
				LColumnSpecifier.SetEndPosition(FLexer);
				return LColumnSpecifier;
			}
			else
			{
				ObjectEventSourceSpecifier LSpecifier = new ObjectEventSourceSpecifier();
				LSpecifier.SetPosition(FLexer);
				LSpecifier.ObjectName = LIdentifier;
				LSpecifier.SetEndPosition(FLexer);
				return LSpecifier;
			}
		}
		
		/*
			BNF:
			<event specifier clause> ::=
				on (<event specifier> | ("{"<ne event specifier commalist>"}"))
				
			<event specifier> ::=
				((before | after) (insert | update | delete)) | 
				(default | validate | change)
		*/
		protected EventSpecifier EventSpecifierClause()
		{
			EventSpecifier LEventSpecifier = new EventSpecifier();
			FLexer.NextToken().CheckSymbol(Keywords.On);
			LEventSpecifier.SetPosition(FLexer);
			if (FLexer.PeekTokenSymbol(1) == Keywords.BeginList)
			{
				FLexer.NextToken().CheckSymbol(Keywords.BeginList);
				bool LDone = false;
				while (!LDone)
				{
					EventSpecifier(LEventSpecifier);

					switch (FLexer.NextToken().AsSymbol)
					{
						case Keywords.ListSeparator: break;
						case Keywords.EndList: LDone = true; break;
						default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
					}
				}
			}
			else
				EventSpecifier(LEventSpecifier);
			LEventSpecifier.SetEndPosition(FLexer);
			return LEventSpecifier;
		}
		
		protected void EventSpecifier(EventSpecifier AEventSpecifier)
		{
			switch (FLexer.NextToken().AsSymbol)
			{
				case Keywords.Before:
				case Keywords.After:
					bool LBefore = (FLexer[0].AsSymbol == Keywords.Before);
					
					switch (FLexer.NextToken().AsSymbol)
					{
						case Keywords.Insert: AEventSpecifier.EventType |= (LBefore ? EventType.BeforeInsert : EventType.AfterInsert); break;
						case Keywords.Update: AEventSpecifier.EventType |= (LBefore ? EventType.BeforeUpdate : EventType.AfterUpdate); break;
						case Keywords.Delete: AEventSpecifier.EventType |= (LBefore ? EventType.BeforeDelete : EventType.AfterDelete); break;
						default: throw new ParserException(ParserException.Codes.UnknownEventSpecifier);
					}
				break;

				case Keywords.Default: AEventSpecifier.EventType |= EventType.Default; break;
				case Keywords.Validate: AEventSpecifier.EventType |= EventType.Validate; break;
				case Keywords.Change: AEventSpecifier.EventType |= EventType.Change; break;
				
				default: throw new ParserException(ParserException.Codes.UnknownEventSpecifier, FLexer[0].AsSymbol);
			}
		}
		
		/*
			BNF:
			<detach statement> ::=
				detach [operator] <operator name>
					from <event source specifier>
					<event specifier clause>
		*/
		protected DetachStatement DetachStatement()
		{
			DetachStatement LStatement = new DetachStatement();
			FLexer.NextToken().CheckSymbol(Keywords.Detach);
			LStatement.SetPosition(FLexer);
			if (FLexer.PeekTokenSymbol(1) == Keywords.Operator)
				FLexer.NextToken();
			LStatement.OperatorName = QualifiedIdentifier();
			FLexer.NextToken().CheckSymbol(Keywords.From);
			LStatement.EventSourceSpecifier = EventSourceSpecifier();
			LStatement.EventSpecifier = EventSpecifierClause();
			LStatement.SetEndPosition(FLexer);
			return LStatement;
		}
		
		/*
			BNF:
			<invoke statement> ::=
				invoke <operator name>
					on <event source specifier>
					<event specifier clause>
					before "{"<ne operator name commalist>"}"
		*/
		protected InvokeStatement InvokeStatement()
		{
			InvokeStatement LStatement = new InvokeStatement();
			FLexer.NextToken().CheckSymbol(Keywords.Invoke);
			LStatement.SetPosition(FLexer);
			LStatement.OperatorName = QualifiedIdentifier();
			FLexer.NextToken().CheckSymbol(Keywords.On);
			LStatement.EventSourceSpecifier = EventSourceSpecifier();
			LStatement.EventSpecifier = EventSpecifierClause();
			FLexer.NextToken().CheckSymbol(Keywords.Before);
			FLexer.NextToken().CheckSymbol(Keywords.BeginList);
			bool LDone = false;
			do
			{
				LStatement.BeforeOperatorNames.Add(QualifiedIdentifier());
				
				switch (FLexer.NextToken().AsSymbol)
				{
					case Keywords.ListSeparator : break;
					case Keywords.EndList : LDone = true; break;
					default: throw new ParserException(ParserException.Codes.ListTerminatorExpected);
				}
			} while (!LDone);
			LStatement.SetEndPosition(FLexer);
			return LStatement;
		}
		
		/*
			BNF:
			<grant statement> ::=
				grant <right specifier>
					[on <catalog object specifier>] 
					to <security specifier>
					
			<right specifier> ::=
				all | usage | ("{"<right name commalist>"}")
					
			<right name> ::=
				<qualified identifier>
				
			<catalog object specifier> ::=
				<qualified identifier> | <operator specifier>
				
			<user id> ::=
				<string>
				
			<group name> ::=
				<string>
				
			<role name> ::=
				<qualified identifier>

			<security specifier> ::=
				(user <user id>) | 
				(role <role name>) |
				(group <group name> [inherited] [apply recursively] [include users])
		*/
		protected void RightSpecifier(RightStatementBase AStatement)
		{
			switch (FLexer.NextToken().AsSymbol)
			{
				case Keywords.All : AStatement.RightType = RightSpecifierType.All; break;
				case Keywords.Usage : AStatement.RightType = RightSpecifierType.Usage; break;
				case Keywords.BeginList : 
					AStatement.RightType = RightSpecifierType.List;
					bool LDone = false;
					while (!LDone)
					{
						RightSpecifier LSpecifier = new RightSpecifier();
						LSpecifier.RightName = QualifiedIdentifier();
						LSpecifier.SetPosition(FLexer);
						AStatement.Rights.Add(LSpecifier);
						switch (FLexer.NextToken().AsSymbol)
						{
							case Keywords.ListSeparator : break;
							case Keywords.EndList : LDone = true; break;
							default : throw new ParserException(ParserException.Codes.ListTerminatorExpected);
						}
					}
				break;
				default : throw new ParserException(ParserException.Codes.InvalidRightSpecifier);
			}
		}
		
		protected CatalogObjectSpecifier CatalogObjectSpecifier()
		{
			CatalogObjectSpecifier LSpecifier = new CatalogObjectSpecifier();
			LSpecifier.ObjectName = QualifiedIdentifier();
			LSpecifier.SetPosition(FLexer);
			if (FLexer.PeekTokenSymbol(1) == Keywords.BeginGroup)
			{
				LSpecifier.IsOperator = true;
				FormalParameterSpecifiers(LSpecifier.FormalParameterSpecifiers);
			}
			
			LSpecifier.SetEndPosition(FLexer);
			return LSpecifier;
		}
		
		protected void CatalogObjectSpecifier(RightStatementBase AStatement)
		{
			if (FLexer.PeekTokenSymbol(1) == Keywords.On)
			{
				FLexer.NextToken();
				AStatement.Target = CatalogObjectSpecifier();
			}
		}
		
		protected void SecuritySpecifier(RightStatementBase AStatement)
		{
			switch (FLexer.NextToken().AsSymbol)
			{
				case Keywords.User :
					AStatement.GranteeType = GranteeType.User;
					FLexer.NextToken();
					#if USEISTRING
					if (FLexer[0].Type == LexerToken.String)
						AStatement.Grantee = FLexer[0].AsString();
					else
						AStatement.Grantee = FLexer.TokenIString();
					#else
					AStatement.Grantee = FLexer[0].AsString;
					#endif
				break;
				
				case Keywords.Role :
					AStatement.GranteeType = GranteeType.Role;
					AStatement.Grantee = QualifiedIdentifier();
				break;
				
				case Keywords.Group :
					AStatement.GranteeType = GranteeType.Group;
					FLexer.NextToken();
					#if USEISTRING
					if (FLexer[0].Type == LexerToken.String)
						AStatement.Grantee = FLexer[0].AsString();
					else
						AStatement.Grantee = FLexer.TokenIString();
					#else
					AStatement.Grantee = FLexer[0].AsString;
					#endif
					if (FLexer.PeekTokenSymbol(1) == Keywords.Inherited)
					{
						FLexer.NextToken();
						AStatement.IsInherited = true;
					}
					
					if (FLexer.PeekTokenSymbol(1) == Keywords.Apply)
					{
						FLexer.NextToken();
						AStatement.ApplyRecursively = true;
					}
					
					if (FLexer.PeekTokenSymbol(1) == Keywords.Include)
					{
						FLexer.NextToken();
						AStatement.IncludeUsers = true;
					}
				break;
				
				default : throw new ParserException(ParserException.Codes.InvalidSecuritySpecifier);
			}
		}
		
		protected GrantStatement GrantStatement()
		{
			GrantStatement LGrantStatement = new GrantStatement();
			FLexer.NextToken().CheckSymbol(Keywords.Grant);
			LGrantStatement.SetPosition(FLexer);
			RightSpecifier(LGrantStatement);
			CatalogObjectSpecifier(LGrantStatement);
			FLexer.NextToken().CheckSymbol(Keywords.To);
			SecuritySpecifier(LGrantStatement);
			LGrantStatement.SetEndPosition(FLexer);
			return LGrantStatement;
		}
		
		/*
			BNF:
			<revoke statement> ::=
				revoke <right specifier> [on <catalog object specifier>] from <security specifier>
		*/
		protected RevokeStatement RevokeStatement()
		{
			RevokeStatement LRevokeStatement = new RevokeStatement();
			FLexer.NextToken().CheckSymbol(Keywords.Revoke);
			LRevokeStatement.SetPosition(FLexer);
			RightSpecifier(LRevokeStatement);
			CatalogObjectSpecifier(LRevokeStatement);
			FLexer.NextToken().CheckSymbol(Keywords.From);
			SecuritySpecifier(LRevokeStatement);
			LRevokeStatement.SetEndPosition(FLexer);
			return LRevokeStatement;
		}
		
		/*
			BNF:
			<revert statement> ::=
				revert <right specifier> [on <catalog object specifier>] for <security specifier>
		*/
		protected RevertStatement RevertStatement()
		{
			RevertStatement LRevertStatement = new RevertStatement();
			FLexer.NextToken().CheckSymbol(Keywords.Revert);
			LRevertStatement.SetPosition(FLexer);
			RightSpecifier(LRevertStatement);
			CatalogObjectSpecifier(LRevertStatement);
			FLexer.NextToken().CheckSymbol(Keywords.For);
			SecuritySpecifier(LRevertStatement);
			LRevertStatement.SetEndPosition(FLexer);
			return LRevertStatement;
		}
    }
}

