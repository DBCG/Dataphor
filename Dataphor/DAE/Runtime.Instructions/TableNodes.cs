/*
	Dataphor
	Â© Copyright 2000-2008 Alphora
	This file is licensed under a modified BSD-license which can be found here: http://dataphor.org/dataphor_license.txt
*/
#define UseReferenceDerivation
#define USEUPDATEVALUEFLAGS
	
namespace Alphora.Dataphor.DAE.Runtime.Instructions
{
	using System;
	using System.Text;
	using System.Threading;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.Specialized;

	using Alphora.Dataphor;
	using Alphora.Dataphor.DAE;
	using Alphora.Dataphor.DAE.Server;	
	using Alphora.Dataphor.DAE.Language;
	using Alphora.Dataphor.DAE.Language.D4;
	using Alphora.Dataphor.DAE.Runtime;
	using Alphora.Dataphor.DAE.Runtime.Data;
	using Alphora.Dataphor.DAE.Device.ApplicationTransaction;
	using Schema = Alphora.Dataphor.DAE.Schema;
	
	// TODO: Make sure the cursors only select the columns that are absolutely necessary to perform their task.
	// (i.e. make sure a join only selects the fields it needs to compare to do the join from its source cursors.)
            
	// TODO: determine how to optimize for non-rowlevel modification operations
	// TODO: incorporate the General Unification Theorem into these nodes
	
	/*
        Key determination for expressions per operator ->
        
            Retrieve ->
                Key is defined by the table or view being retrieved
                
            Project ->
                if the columns of the projection include the key of the source bag
                    the key is inherited from the source bag
                else
                    if the projection is distinct
                        the key is all columns of the projection
                    else
                        the key is undefined
                        
            Aggregate ->
                if the by columns of the aggregation include the key of the source bag
                    the key is inherited from the source bag
                else
                    the key is all by columns of the aggregation
                        
            Restrict ->
                Key is inherited from the source bag
                    
            Order ->
                Key is inherited from the source bag
                
            Intersect ->
                Key is inherited from the left source bag
                    The operation is implemented by including rows from the 
                    left side that can be found in the right side.  If the intersect
                    is based on sets, the operation is commutative.  If the intersect
                    is based on bags or a bag and set, the operation loses commutativity,
                    hence the implementation specific assumption that the key is derived 
                    from the left bag.
                
            Difference ->
                Key is inherited from the left source bag
            
            Union ->
                if the union is distinct
                    if there is a left key and a right key
                        the keys are the distinct set of keys generated by taking the cartesian product
                        of the left and right keys, and unioning the attributes of the keys in each pair
                    else
                        the key is all columns in the union
                else
                    the key is undefined
            
            Product ->
                If the left bag and the right bag have keys,
                    the key of the product is the union of the keys
                else
                    the key is undefined
                    
            Join ->
                Determine uniqueness for the right and left columns over which the join is defined
                
                if the left join columns and the right join columns are unique
                    the key is the left key or the right key
                else if the left join columns are unique
                    if there is a right key
                        the key is the right key
                    else 
                        the key is undefined
                else if the right join columns are unique
                    if there is a left key
                        the key is the left key
                    else
                        the key is undefined
                else if neither join columns are unique
                    if there is a left key and a right key
                        the key is the left key and the right key
                    else
                        the key is undefined
                    
                if the join is a full outer
                    add an exists column to the left and right column list
                else if the join is a left outer
                    add an exists column to the right column list
                else if the join is a right outer
                    add an exists column to the left column list
                  
            Divide ->
                if the attributes of A that are not in B form a key in A,
                    the key is that key
                else
                    the key is undefined
                  
            Great Divide ->
                if bag A has a key
                    the key is the key for bag A
                else
                    the key is undefined
                    
        Predicate derivation rules per operator ->
        
            Retrieve ->
                the predicate is inherited from the source object
                
            Project ->
            
            Aggregate ->
            
            Restrict ->
                the predicate is the predicate of the source object and the restriction expression
            
            Order ->
                the predicate is inherited from the source object
            
            Intersect ->
                the predicate is P(A) and P(B)
            
            Difference ->
                the predicate is P(A) and not P(B)
            
            Union ->
                the predicate is P(A) or P(B)
            
            Product ->
            
            Join ->
                given (A) join (B) on <theta>
                    there is a row in A such that theta evaluates to true for at least one row in B
                    
                given (A) left outer join (B) on <theta>
                    there is a row in A such that theta evaluates to true for some row(s) in B
                    
                given (A) right outer join (B) on <theta>
                    there is a row in B such that theta evaluates to true for some row(s) in A
                    
                given (A) full outer join (B) on <theta>
                    there is a row in A such that theta evaluates to true for some row(s) in A or
                    there is a row in B such that theta evaluates to true for some row(s) in B
            
            Divide ->
                    
        Modification propagation rules per operator ->
            
            Retrieve ->
                if the operator cursor is updateable
                    modifications take place through the cursor (Insert, Update, Delete methods)
                else
                    if the operator cursor has at least one key
                        if a server is available and supports the modification being requested
                            the statement is executed against the server
                        else
                            the modification is propogated to the source cursor
                    else
                        the modification is rejected
                        
            Project ->
                same as retrieve 
                
            Aggregate ->
                same as retrieve
            
            Restrict ->
                same as retrieve with the exception that the incoming row must satisfy the conditions
                of the restriction.
            
            Order ->
                same as retrieve
                
            Union ->
                if the cursor is updateable
                    modifications take place through the cursor
                else
                    if the operator cursor has at least one key
                        if a server is available and supports the operation being requested
                            the statement is executed against the server
                        else
                            for an insert
                                if the row satisfies the predicate for the left source cursor
                                    the row is inserted in the left source cursor
                                if the row satisfies the predicate for the right source cursor
                                    if the row still does not exist in the right source cursor
                                        the row is inserted into the right source cursor
                            for an update
                                if the old row satisfies the predicate for the left source cursor
                                    the row is deleted from the left source cursor (without checking integrity constraints)
                                if the old row satisfies the predicate for the right source cursor
                                    the row is deleted from the right source cursor (without checking integrity constraints)
                                if the new row satisfies the predicate for the left source cursor
                                    the new row is inserted in the left source cursor
                                if the new row satisfies the predicate for the right source cursor
                                    if the row still does not exist in the right source cursor
                                        the new row is inserted in the right source cursor
                            for a delete
                                if the row satisfies the predicate for the left source cursor
                                    the row is deleted from the left source cursor
                                if the row satisfies the predicate for the right source cursor
                                    the row is deleted from the right source cursor
                    else
                        the modification is rejected
                
            Intersect ->
                if the cursor is updateable
                    the modification takes place through the cursor
                else
                    if the operator has at least one key
                        if a server is available and supports the modification being requested
                            the modification is executed against the server
                        else
                            for an insert
                                the new row must satisfy the predicate for both source cursors
                                the new row is inserted into the left source cursor
                                if it still does not exist in the right source cursor
                                    the row is inserted into the right source cursor
                            for an update
                                the new row must satisfy the predicate for both source cursors
                                the old row is deleted from the left source cursor (without checking integrity)
                                the old row is deleted from the right source cursor (without checking integrity)
                                the new row is inserted into the left source cursor
                                if the row still does not exist in the right source cursor
                                    the row is inserted into the right source cursor
                            for a delete
                                the row is deleted from the left source cursor
                                the row is deleted from the right source cursor
                    else
                        the modification is rejected
            
            Difference ->
                if the cursor is updateable
                    the modification takes place through the cursor
                else
                    if the operator has at least one key
                        if a server is available and supports the modification being requested
                            the modification is executed against the server
                        else
                            for an insert
                                the new row must satisfy the left predicate and not the right predicate
                                the row is inserted into the left source cursor
                            for an update
                                the new row must satisfy the left predicate and not the right predicate
                                the old row is deleted from the left source cursor (without checking integrity)
                                the new row is inserted into the left source cursor
                            for a delete
                                the row is deleted from the left source cursor
                    else
                        the modification is rejected
            
            Product ->   
                if the cursor is updateable
                    the modification takes place through the cursor
                else
                    if the operator has at least one key
                        if a server is available and supports the modification being requested
                            the modification is executed against the server
                        else
                            for an insert
                                the new rows are inserted into the left and right source cursors
                            for an update
                                the old rows are deleted from the left and right source cursors (without checking integrity)
                                the new rows are inserted into the left and right source cursors
                            for a delete
                                the old rows are deleted from the left and right source cursors
                    else
                        the modification is rejected
                             
            Join ->
                if the cursor is updateable
                    the modification takes place through the cursor
                else
                    if the operator has at least one key
                        if a server is available and supports the modification being requested
                            the modification is executed against the server
                        else
                            for an insert
                                the new row must satisfy the join expression
                                if the join is inner
                                    the new rows are inserted into the left and right source cursors
                                if the join is outer
                                    if there is no exists flag, or the exists flag is true for the left row
                                        the left row is inserted in the left source cursor
                                    if there is no exists flag, or the exists flag is true for the right row
                                        the right row is inserted in the right source cursor
                            for an update
                                the new row must satisfy the join expression
                                if the join is inner
                                    the rows are updated in the left and right source cursors
                                if the join is outer
                                    if there is no exists flag, or the exists flag is true for the left row
                                        if the old exists flag is false
                                            the left row is inserted in the left source cursor
                                        else
                                            the left row is updated in the left source cursor
                                    else
                                        the left row is deleted from the left source cursor
                                    if there is no exists flag, or the exists flag is true for the right row
                                        if the old exists flag is false
                                            the right row is inserted in the right source cursor
                                        else
                                            the right row is updated in the right source cursor
                                    else
                                        the right row is deleted from the right source cursor
                            for a delete
                                the rows are deleted from the left and right source cursors
                    else
                        the modification is rejected
                        
            Divide ->
                if the cursor is updateable
                    the modification takes place through the cursor
                else
                    if the operator has at least one key
                        if a server is available and supports the modification being requested
                            the modification is executed against the server
                        else
                            for an insert
                                the product of the new row with B is inserted into A
                            for an update
                                the product of the old row with B is deleted from A (without checking integrity)
                                the product of the new row with B is inserted into A
                            for a delete
                                the product of the new row with B is inserted into A
                    else
                        the modification is rejected
                             
            Great Divide ->
                if the cursor is updateable
                    the modification takes place through the cursor
                else
                    if the operator has at least one key
                        if a server is available and supports the modification being requested
                            the modification is executed against the server
                        else
                            for an insert
                                the new row is inserted into A along with all matching rows are in C for all rows in B
                            for an update
                                the old row is deleted from A along with all matching rows from C for all rows in B (without checking integrity)
                                the new row is inserted into A along with all matching rows in C for all rows in B
                            for a delete
                                the old row is deleted from A along with all matching rows from C for all rows in B
                    else
                        the modification is rejected
                             
	*/
	
    public abstract class DMLNode : PlanNode
    {
		private bool FUnchecked = false;
		public bool Unchecked { get { return FUnchecked; } }
		
		protected override void DetermineModifiers(Plan APlan)
		{
			base.DetermineModifiers(APlan);
			if (Modifiers != null)
				FUnchecked = Boolean.Parse(LanguageModifiers.GetModifier(Modifiers, "Unchecked", Unchecked.ToString()));
		}
		
		public override void DetermineDataType(Plan APlan)
		{
			DetermineModifiers(APlan);
		}
    }

	// Nodes[0] - Source table / row value
	// Nodes[1] - Target table variable
    public class InsertNode : DMLNode
    {
		private bool FInsertedUpdate;
		public bool InsertedUpdate
		{
			get { return FInsertedUpdate; }
			set { FInsertedUpdate = value; }
		}
		
		private string FUpdateColumnNames;
		public string UpdateColumnNames
		{
			get { return FUpdateColumnNames; }
			set { FUpdateColumnNames = value; }
		}
		
		protected override void DetermineModifiers(Plan APlan)
		{
			base.DetermineModifiers(APlan);
			if (Modifiers != null)
			{
				InsertedUpdate = Boolean.Parse(LanguageModifiers.GetModifier(Modifiers, "InsertedUpdate", InsertedUpdate.ToString()));
				UpdateColumnNames = LanguageModifiers.GetModifier(Modifiers, "UpdateColumnNames", UpdateColumnNames);
			}
		}
		
		public override void InternalDetermineBinding(Plan APlan)
		{
			APlan.PushCursorContext(new CursorContext(CursorType.Static, CursorCapability.Navigable, CursorIsolation.None));
			try
			{
				Nodes[0].DetermineBinding(APlan);
			}
			finally
			{
				APlan.PopCursorContext();
			}
			
			APlan.PushCursorContext(new CursorContext(CursorType.Static, CursorCapability.Navigable | CursorCapability.Updateable, CursorIsolation.Isolated));
			try
			{
				bool LSaveIsInsert = APlan.ServerProcess.IsInsert;
				APlan.ServerProcess.IsInsert = true;
				try
				{
					Nodes[1].DetermineBinding(APlan);
				}
				finally
				{
					APlan.ServerProcess.IsInsert = LSaveIsInsert;
				}
			}
			finally
			{
				APlan.PopCursorContext();
			}
		}
		
		public override void BindToProcess(Plan APlan)
		{
			APlan.PushCursorContext(new CursorContext(CursorType.Static, CursorCapability.Navigable, CursorIsolation.None));
			try
			{
				Nodes[0].BindToProcess(APlan);
			}
			finally
			{
				APlan.PopCursorContext();
			}

			APlan.PushStatementContext(new StatementContext(StatementType.Insert));
			try
			{
				APlan.PushCursorContext(new CursorContext(CursorType.Static, CursorCapability.Navigable | CursorCapability.Updateable, CursorIsolation.Isolated));
				try
				{
					bool LSaveIsInsert = APlan.ServerProcess.IsInsert;
					APlan.ServerProcess.IsInsert = true;
					try
					{
						Nodes[1].BindToProcess(APlan);
					}
					finally
					{
						APlan.ServerProcess.IsInsert = LSaveIsInsert;
					}
				}
				finally
				{
					APlan.PopCursorContext();
				}
			}
			finally
			{
				APlan.PopStatementContext();
			}
		}

		public override object InternalExecute(ServerProcess AProcess)
		{
			if (AProcess.IsReconciliationEnabled())
			{
				// Open a table for the source expression
				// Open a table for the target expression
				// Insert each row of the source expression into the target expression
				object LSource = Nodes[0].Execute(AProcess);

				object LTarget;
				bool LSaveIsInsert = AProcess.IsInsert; 
				bool LSaveIsOpeningInsertCursor = AProcess.IsOpeningInsertCursor; 
				AProcess.IsInsert = true; // To indicate to application transactions that data should not be populated
				AProcess.IsOpeningInsertCursor = true; // To indicate to devices involved in the expression that it is not necessary to open the cursor
				try
				{
					LTarget = Nodes[1].Execute(AProcess);
				}
				finally
				{
					AProcess.IsInsert = LSaveIsInsert;
					AProcess.IsOpeningInsertCursor = LSaveIsOpeningInsertCursor;
				}

				if (LSource is Row)
				{
					using (Row LRow = (Row)LSource)
					{
						using (Table LTargetTable = (Table)LTarget)
						{
							if (InsertedUpdate)
							{
								Schema.RowType LOldRowType = new Schema.RowType();
								Schema.RowType LNewRowType = new Schema.RowType();
								for (int LIndex = 0; LIndex < LRow.DataType.Columns.Count; LIndex++)
									if (Schema.Object.Qualifier(LRow.DataType.Columns[LIndex].Name) == Keywords.Old)
										LOldRowType.Columns.Add(LRow.DataType.Columns[LIndex].CopyAndRename(Schema.Object.Dequalify(LRow.DataType.Columns[LIndex].Name)));
									else
										LNewRowType.Columns.Add(LRow.DataType.Columns[LIndex].CopyAndRename(Schema.Object.Dequalify(LRow.DataType.Columns[LIndex].Name)));
										
								using (Row LOldRow = new Row(AProcess, LOldRowType))
								{
									using (Row LNewRow = new Row(AProcess, LNewRowType))
									{
										for (int LIndex = 0; LIndex < LRow.DataType.Columns.Count; LIndex++)
											if (Schema.Object.Qualifier(LRow.DataType.Columns[LIndex].Name) == Keywords.Old)
												LOldRow[Schema.Object.Dequalify(LRow.DataType.Columns[LIndex].Name)] = LRow[LIndex];
											else
												LNewRow[Schema.Object.Dequalify(LRow.DataType.Columns[LIndex].Name)] = LRow[LIndex];
											
										#if USEUPDATEVALUEFLAGS
										BitArray LValueFlags = new BitArray(LNewRow.DataType.Columns.Count);
										if (UpdateColumnNames != null)
										{
											string[] LUpdateColumnNames = UpdateColumnNames.Split(';');
											Schema.Columns LUpdateColumns = new Schema.Columns();
											for (int LIndex = 0; LIndex < LUpdateColumnNames.Length; LIndex++)
												LUpdateColumns.Add(LNewRow.DataType.Columns[LUpdateColumnNames[LIndex]]);
											for (int LIndex = 0; LIndex < LValueFlags.Length; LIndex++)
												LValueFlags[LIndex] = LUpdateColumns.ContainsName(LNewRow.DataType.Columns[LIndex].Name);
										}
										else
											for (int LIndex = 0; LIndex < LValueFlags.Length; LIndex++)
												LValueFlags[LIndex] = true;

										LTargetTable.Insert(LOldRow, LNewRow, LValueFlags, Unchecked);
										#else
										LTargetTable.Insert(LOldRow, LNewRow, null, Unchecked);
										#endif
									}
								}
							}
							else
							{
								BitArray LValueFlags = new BitArray(LRow.DataType.Columns.Count);
								for (int LIndex = 0; LIndex < LValueFlags.Length; LIndex++)
									LValueFlags[LIndex] = true;

								LTargetTable.Insert(null, LRow, LValueFlags, Unchecked);
							}

							return null;
						}
					}
				}
				else
				{
					using (Table LSourceTable = ((Table)LSource))
					{
						using (Row LRow = new Row(AProcess, LSourceTable.DataType.RowType))
						{
							using (Table LTargetTable = ((Table)LTarget))
							{
								// TODO: Make sure LSource is static if it is referenced by the expression of LTarget
								if (InsertedUpdate)
								{
									Schema.RowType LOldRowType = new Schema.RowType();
									Schema.RowType LNewRowType = new Schema.RowType();
									for (int LIndex = 0; LIndex < LRow.DataType.Columns.Count; LIndex++)
										if (Schema.Object.Qualifier(LRow.DataType.Columns[LIndex].Name) == Keywords.Old)
											LOldRowType.Columns.Add(LRow.DataType.Columns[LIndex].CopyAndRename(Schema.Object.Dequalify(LRow.DataType.Columns[LIndex].Name)));
										else
											LNewRowType.Columns.Add(LRow.DataType.Columns[LIndex].CopyAndRename(Schema.Object.Dequalify(LRow.DataType.Columns[LIndex].Name)));
											
									using (Row LOldRow = new Row(AProcess, LOldRowType))
									{
										using (Row LNewRow = new Row(AProcess, LNewRowType))
										{
											#if USEUPDATEVALUEFLAGS
											BitArray LValueFlags = new BitArray(LNewRow.DataType.Columns.Count);
											if (UpdateColumnNames != null)
											{
												string[] LUpdateColumnNames = UpdateColumnNames.Split(';');
												Schema.Columns LUpdateColumns = new Schema.Columns();
												for (int LIndex = 0; LIndex < LUpdateColumnNames.Length; LIndex++)
													LUpdateColumns.Add(LNewRow.DataType.Columns[LUpdateColumnNames[LIndex]]);
												for (int LIndex = 0; LIndex < LValueFlags.Length; LIndex++)
													LValueFlags[LIndex] = LUpdateColumns.ContainsName(LNewRow.DataType.Columns[LIndex].Name);
											}
											else
												for (int LIndex = 0; LIndex < LValueFlags.Length; LIndex++)
													LValueFlags[LIndex] = true;
											#endif

											while (LSourceTable.Next())
											{
												LSourceTable.Select(LRow);

												for (int LIndex = 0; LIndex < LRow.DataType.Columns.Count; LIndex++)
													if (Schema.Object.Qualifier(LRow.DataType.Columns[LIndex].Name) == Keywords.Old)
														LOldRow[Schema.Object.Dequalify(LRow.DataType.Columns[LIndex].Name)] = LRow[LIndex];
													else
														LNewRow[Schema.Object.Dequalify(LRow.DataType.Columns[LIndex].Name)] = LRow[LIndex];
														
												#if USEUPDATEVALUEFLAGS
												LTargetTable.Insert(LOldRow, LNewRow, LValueFlags, Unchecked);
												#else
												LTargetTable.Insert(LOldRow, LNewRow, null, Unchecked);
												#endif
											}
										}
									}
								}
								else
								{
									BitArray LValueFlags = new BitArray(LRow.DataType.Columns.Count);
									for (int LIndex = 0; LIndex < LValueFlags.Length; LIndex++)
										LValueFlags[LIndex] = true;

									while (LSourceTable.Next())
									{
										LSourceTable.Select(LRow);
										LTargetTable.Insert(null, LRow, LValueFlags, Unchecked);
									}
								}
								return null;
							}
						}
					}
				}
			}
			
			return null;
		}

		public override Statement EmitStatement(EmitMode AMode)
		{
			InsertStatement LStatement = new InsertStatement();
			LStatement.Modifiers = Modifiers;
			LStatement.SourceExpression = (Expression)Nodes[0].EmitStatement(AMode);
			LStatement.Target = (Expression)Nodes[1].EmitStatement(AMode);
			return LStatement;
		}
    }
    
    public class UpdateColumnNode : PlanNode
    {
		// constructor
		public UpdateColumnNode() : base()
		{
			IgnoreUnsupported = true;
		}
		#if USECOLUMNLOCATIONBINDING
		public UpdateColumnNode(Schema.IDataType ADataType, int AColumnLocation, PlanNode ATargetValue) : base()
		{
			IgnoreUnsupported = true;
			FDataType = ADataType;
			FColumnLocation = AColumnLocation;
			Nodes.Add(ATargetValue);
		}

		// ColumnLocation
		protected int FColumnLocation;
		public int ColumnLocation
		{
			get { return FColumnLocation; }
			set { FColumnLocation = value; }
		}
		#else
		public UpdateColumnNode(Schema.IDataType ADataType, string AColumnName, PlanNode ATargetValue) : base()
		{
			IgnoreUnsupported = true;
			FDataType = ADataType;
			ColumnName = AColumnName;
			Nodes.Add(ATargetValue);
		}
		
		// ColumnName
		public string ColumnName;
		#endif
		
		public override object InternalExecute(ServerProcess AProcess)
		{
			return Nodes[0].Execute(AProcess);
		}
    }
    
    public class UpdateNode : DMLNode
    {
		protected bool FIsKeyAffected = false;
		public bool IsKeyAffected
		{
			get { return FIsKeyAffected; }
			set { FIsKeyAffected = value; }
		}
		
		protected PlanNode FTargetNode = null;
		public PlanNode TargetNode
		{
			get { return FTargetNode; }
			set { FTargetNode = value; }
		}
		
		protected PlanNode FConditionNode = null;
		public PlanNode ConditionNode
		{
			get { return FConditionNode; }
			set { FConditionNode = value; }
		}

		public override void InternalDetermineBinding(Plan APlan)
		{
			APlan.PushCursorContext(new CursorContext(CursorType.Static, CursorCapability.Navigable | CursorCapability.Updateable, CursorIsolation.Isolated));
			try
			{
				Nodes[0].DetermineBinding(APlan);
				if (!(((TableNode)Nodes[0]).CursorType == CursorType.Static))
				{
					Nodes[0] = Compiler.EmitCopyNode(APlan, (TableNode)Nodes[0]);
					ApplicationTransaction LTransaction = null;
					if (APlan.ServerProcess.ApplicationTransactionID != Guid.Empty)
						LTransaction = APlan.ServerProcess.GetApplicationTransaction();
					try
					{
						if (LTransaction != null)
							LTransaction.PushGlobalContext();
						try
						{
							((TableNode)Nodes[0]).InferPopulateNode(APlan);
							Nodes[0].DetermineDevice(APlan);
						}
						finally
						{
							if (LTransaction != null)
								LTransaction.PopGlobalContext();
						}
					}
					finally
					{
						if (LTransaction != null)
							Monitor.Exit(LTransaction);
					}
				}
			}
			finally
			{
				APlan.PopCursorContext();
			}

			APlan.EnterRowContext();
			try
			{
				APlan.Symbols.Push(new Symbol(((Schema.TableType)Nodes[0].DataType).RowType));
				try
				{
					for (int LIndex = 1; LIndex < Nodes.Count; LIndex++)
						Nodes[LIndex].DetermineBinding(APlan);
				}
				finally
				{
					APlan.Symbols.Pop();
				}
			}
			finally
			{
				APlan.ExitRowContext();
			}
		}
		
		public override void BindToProcess(Plan APlan)
		{
			APlan.PushStatementContext(new StatementContext(StatementType.Update));
			try
			{
				APlan.PushCursorContext(new CursorContext(CursorType.Static, CursorCapability.Navigable | CursorCapability.Updateable, CursorIsolation.Isolated));
				try
				{
					Nodes[0].BindToProcess(APlan);
				}
				finally
				{
					APlan.PopCursorContext();
				}
			}
			finally
			{
				APlan.PopStatementContext();
			}

			for (int LIndex = 1; LIndex < Nodes.Count; LIndex++)
				Nodes[LIndex].BindToProcess(APlan);
		}
		
		public override object InternalExecute(ServerProcess AProcess)
		{
			if (AProcess.IsReconciliationEnabled())
			{
				// Open a table for the expression
				// for each row in the table, update the value of each column to the given expression
				using (Table LTable = (Table)Nodes[0].Execute(AProcess))
				{
					Row LOldRow = new Row(AProcess, LTable.DataType.RowType);
					try
					{
						Row LNewRow = new Row(AProcess, LTable.DataType.RowType);
						try
						{
							if (LTable.Next())
							{
								#if USEUPDATEVALUEFLAGS
								BitArray LValueFlags = new BitArray(LNewRow.DataType.Columns.Count);
								Schema.Columns LUpdateColumns = new Schema.Columns();
								for (int LIndex = 1; LIndex < Nodes.Count; LIndex++)
									LUpdateColumns.Add(LNewRow.DataType.Columns[((UpdateColumnNode)Nodes[LIndex]).ColumnName]);
								for (int LIndex = 0; LIndex < LValueFlags.Length; LIndex++)
									LValueFlags[LIndex] = LUpdateColumns.ContainsName(LNewRow.DataType.Columns[LIndex].Name);
								#endif
									
								while (true)
								{
									LTable.Select(LOldRow);
									LTable.Select(LNewRow);
									AProcess.Context.Push(LOldRow);
									try
									{
										for (int LIndex = 1; LIndex < Nodes.Count; LIndex++)
										{
											object LObject = Nodes[LIndex].Execute(AProcess);
											try
											{
												#if USECOLUMNLOCATIONBINDING
												LNewRow[((UpdateColumnNode)Nodes[LIndex]).ColumnLocation] = LObject;
												#else
												LNewRow[((UpdateColumnNode)Nodes[LIndex]).ColumnName] = LObject;
												#endif
											}
											finally
											{
												DataValue.DisposeValue(AProcess, LObject);
											}
										}
									}
									finally
									{
										AProcess.Context.Pop();
									}
									
									#if USEUPDATEVALUEFLAGS
									LTable.Update(LNewRow, LValueFlags, Unchecked);
									#else
									LTable.Update(LNewRow, null, Unchecked);
									#endif
										
									if (!LTable.Next())
										break;
								}
							}
							
							return null;
						}
						finally
						{
							LNewRow.Dispose();
						}
					}
					finally
					{
						LOldRow.Dispose();
					}
				}
			}
			
			return null;
		}
		
		public override Statement EmitStatement(EmitMode AMode)
		{
			UpdateStatement LStatement = new UpdateStatement();
			LStatement.Modifiers = Modifiers;
			LStatement.Target = (Expression)FTargetNode.EmitStatement(AMode);
			if (FConditionNode != null)
				LStatement.Condition = (Expression)FConditionNode.EmitStatement(AMode);
			Schema.TableType LDataType = (Schema.TableType)Nodes[0].DataType;
			UpdateColumnNode LNode;
			for (int LIndex = 1; LIndex < Nodes.Count; LIndex++)
			{
				LNode = (UpdateColumnNode)Nodes[LIndex];
				#if USECOLUMNLOCATIONBINDING
				LStatement.Columns.Add(new UpdateColumnExpression(new IdentifierExpression(LDataType.Columns[LNode.ColumnLocation].Name), (Expression)LNode.Nodes[0].EmitStatement(AMode)));
				#else
				LStatement.Columns.Add(new UpdateColumnExpression(new IdentifierExpression(LNode.ColumnName), (Expression)LNode.Nodes[0].EmitStatement(AMode)));
				#endif
			}
			return LStatement;
		}
    }
    
    public class UpdateRowNode : DMLNode
    {
		private bool FIsGeneric;
		public bool IsGeneric { get { return FIsGeneric; } }
		
		private UpdateColumnExpressions FColumnExpressions = new UpdateColumnExpressions();
		public UpdateColumnExpressions ColumnExpressions { get { return FColumnExpressions; } }
		
		public override void DetermineDataType(Plan APlan)
		{
			DetermineModifiers(APlan);
			if (!Nodes[0].DataType.IsGeneric)
			{
				APlan.EnterRowContext();
				try
				{
					APlan.Symbols.Push(new Symbol(Nodes[0].DataType));
					try
					{
						foreach (UpdateColumnExpression LExpression in FColumnExpressions)
							Nodes.Add(Compiler.CompileUpdateColumnExpression(APlan, LExpression));
					}
					finally
					{
						APlan.Symbols.Pop();
					}
				}
				finally
				{
					APlan.ExitRowContext();
				}
			}
			else
			{
				FIsGeneric = true;
				foreach (UpdateColumnExpression LExpression in FColumnExpressions)
					Nodes.Add(Compiler.CompileExpression(APlan, LExpression.Expression));
			}
		}

		public override void InternalDetermineBinding(Plan APlan)
		{
			if (!FIsGeneric)
			{
				Nodes[0].DetermineBinding(APlan);
				APlan.EnterRowContext();
				try
				{
					APlan.Symbols.Push(new Symbol(Nodes[0].DataType));
					try
					{
						for (int LIndex = 1; LIndex < Nodes.Count; LIndex++)
							Nodes[LIndex].DetermineBinding(APlan);
					}
					finally
					{
						APlan.Symbols.Pop();
					}
				}
				finally
				{
					APlan.ExitRowContext();
				}
			}
			else
				base.InternalDetermineBinding(APlan);
		}

		public override object InternalExecute(ServerProcess AProcess)
		{
			if (!IsGeneric)
			{
				Row LTarget = (Row)AProcess.Context.Peek(((StackReferenceNode)Nodes[0]).Location);
				AProcess.Context.Push(LTarget);
				try
				{
					for (int LIndex = 1; LIndex < Nodes.Count; LIndex++)
					{
						object LObject = Nodes[LIndex].Execute(AProcess);
						try
						{
							#if USECOLUMNLOCATIONBINDING
							LTarget[((UpdateColumnNode)Nodes[LIndex]).ColumnLocation] = LObject;
							#else
							LTarget[((UpdateColumnNode)Nodes[LIndex]).ColumnName] = LObject;
							#endif
						}
						finally
						{
							DataValue.DisposeValue(AProcess, LObject);
						}
					}
				}
				finally
				{
					AProcess.Context.Pop();
				}
			}
			else
			{
				Row LTarget = (Row)AProcess.Context.Peek(((StackReferenceNode)Nodes[0]).Location);
				UpdateColumnNode[] LColumnNodes = new UpdateColumnNode[FColumnExpressions.Count];
				AProcess.Plan.EnterRowContext();
				try
				{
					AProcess.Plan.Symbols.Push(new Symbol(LTarget.DataType));
					try
					{
						for (int LIndex = 0; LIndex < FColumnExpressions.Count; LIndex++)
							LColumnNodes[LIndex] = Compiler.EmitUpdateColumnNode(AProcess.Plan, FColumnExpressions[LIndex], new ValueNode(Nodes[LIndex + 1].DataType, Nodes[LIndex + 1].Execute(AProcess)));
					}
					finally
					{
						AProcess.Plan.Symbols.Pop();
					}
				}
				finally
				{
					AProcess.Plan.ExitRowContext();
				}
				
				AProcess.Context.Push(LTarget);
				try
				{
					for (int LIndex = 0; LIndex < FColumnExpressions.Count; LIndex++)
					{
						object LObject = LColumnNodes[LIndex].Execute(AProcess);
						try
						{
							LTarget[LColumnNodes[LIndex].ColumnName] = LObject;
						}
						finally
						{
							DataValue.DisposeValue(AProcess, LObject);
						}
					}
				}
				finally
				{
					AProcess.Plan.Symbols.Pop();
				}
			}
			return null;
		}
		
		public override Statement EmitStatement(EmitMode AMode)
		{
			UpdateStatement LStatement = new UpdateStatement();
			LStatement.Modifiers = Modifiers;
			LStatement.Target = (Expression)Nodes[0].EmitStatement(AMode);
			Schema.RowType LDataType = (Schema.RowType)Nodes[0].DataType;
			LStatement.Columns.AddRange(FColumnExpressions);
			return LStatement;
		}
    }
    
    public class DeleteNode : DMLNode
    {
		public override void InternalDetermineBinding(Plan APlan)
		{
			APlan.PushCursorContext(new CursorContext(CursorType.Static, CursorCapability.Navigable | CursorCapability.Updateable, CursorIsolation.Isolated));
			try
			{
				Nodes[0].DetermineBinding(APlan);
				if (!(((TableNode)Nodes[0]).CursorType == CursorType.Static))
				{
					Nodes[0] = Compiler.EmitCopyNode(APlan, (TableNode)Nodes[0]);
					ApplicationTransaction LTransaction = null;
					if (APlan.ServerProcess.ApplicationTransactionID != Guid.Empty)
						LTransaction = APlan.ServerProcess.GetApplicationTransaction();
					try
					{
						if (LTransaction != null)
							LTransaction.PushGlobalContext();
						try
						{
							((TableNode)Nodes[0]).InferPopulateNode(APlan);
							Nodes[0].DetermineDevice(APlan);
						}
						finally
						{
							if (LTransaction != null)
								LTransaction.PopGlobalContext();
						}
					}
					finally
					{
						if (LTransaction != null)
							Monitor.Exit(LTransaction);
					}
				}
			}
			finally
			{
				APlan.PopCursorContext();
			}
		}
		
		public override void BindToProcess(Plan APlan)
		{
			APlan.PushStatementContext(new StatementContext(StatementType.Delete));
			try
			{
				APlan.PushCursorContext(new CursorContext(CursorType.Static, CursorCapability.Navigable | CursorCapability.Updateable, CursorIsolation.Isolated));
				try
				{
					Nodes[0].BindToProcess(APlan);
				}
				finally
				{
					APlan.PopCursorContext();
				}
			}
			finally
			{
				APlan.PopStatementContext();
			}
		}
		
		public override object InternalExecute(ServerProcess AProcess)
		{
			if (AProcess.IsReconciliationEnabled())
			{
				// Open a table for the expression
				// delete all the rows
				using (Table LTable = (Table)Nodes[0].Execute(AProcess))
				{
					if (LTable.Next())
					{
						while (true)
						{
							LTable.Delete(Unchecked);
							if (LTable.CursorType == CursorType.Static)
								LTable.Next();
								
							if (LTable.EOF())
								break;
						}
					}
					
					return null;
				}
			}
			
			return null;
		}
		
		public override Statement EmitStatement(EmitMode AMode)
		{
			DeleteStatement LStatement = new DeleteStatement();
			LStatement.Modifiers = Modifiers;
			LStatement.Target = (Expression)Nodes[0].EmitStatement(AMode);
			return LStatement;
		}
    }

    public class TableSelectorNode : TableNode
    {
		public TableSelectorNode(Schema.ITableType ADataType) : base()
		{
			FDataType = ADataType;
			FTableVar = new Schema.ResultTableVar(this);
		}
		
		public override void DetermineCharacteristics(Plan APlan)
		{
			FIsLiteral = true;
			FIsFunctional = true;
			FIsDeterministic = true;
			FIsRepeatable = true;
			for (int LIndex = 0; LIndex < NodeCount; LIndex++)
			{
				FIsLiteral = FIsLiteral && Nodes[LIndex].IsLiteral;
				FIsFunctional = FIsFunctional && Nodes[LIndex].IsFunctional;
				FIsDeterministic = FIsDeterministic && Nodes[LIndex].IsDeterministic;
				FIsRepeatable = FIsRepeatable && Nodes[LIndex].IsRepeatable;
			} 
			FTableVar.DetermineRemotable(APlan.ServerProcess);
			FTableVar.Owner = APlan.User;
			if (Order == null)
				Order = new Schema.Order(FTableVar.FindClusteringKey(), APlan);
		}
		
		public override void DetermineCursorBehavior(Plan APlan)
		{
			FCursorType = CursorType.Static;
			FRequestedCursorType = APlan.CursorContext.CursorType;
			FCursorCapabilities = CursorCapability.Navigable | CursorCapability.BackwardsNavigable | CursorCapability.Searchable | CursorCapability.Bookmarkable;
			FCursorIsolation = CursorIsolation.None;
			Order = new Schema.Order(FTableVar.FindClusteringKey(), APlan);
		}
		
		public override object InternalExecute(ServerProcess AProcess)
		{
			LocalTable LTable = new LocalTable(this, AProcess);
			try
			{
				LTable.Open();
				// Insert each row from the arguments into this new table
				for (int LIndex = 0; LIndex < NodeCount; LIndex++)
				{
					Row LRow = (Row)Nodes[LIndex].Execute(AProcess);
					try
					{
						LTable.FNativeTable.Insert(AProcess, LRow); // Insert directly into the native table value to avoid the updatable capability check
					}
					finally
					{
						LRow.Dispose();
					}
				}

				LTable.First();
				return LTable;
			}
			catch
			{
				LTable.Dispose();
				throw;
			}
		}
		
		public override Statement EmitStatement(EmitMode AMode)
		{
			if (FDataType is Schema.ITableType)
			{
				TableSelectorExpression LExpression = new TableSelectorExpression();
				LExpression.TypeSpecifier = DataType.EmitSpecifier(AMode);
				for (int LIndex = 0; LIndex < NodeCount; LIndex++)
					LExpression.Expressions.Add(Nodes[LIndex].EmitStatement(AMode));
				LExpression.Modifiers = Modifiers;
				foreach (Schema.Key LKey in TableVar.Keys)
					if (LKey.Columns.Count < TableVar.Columns.Count)
						LExpression.Keys.Add(LKey.EmitStatement(AMode));
				return LExpression;
			}
			else
			{
				PresentationSelectorExpression LExpression = new PresentationSelectorExpression();
				LExpression.TypeSpecifier = DataType.EmitSpecifier(AMode);
				for (int LIndex = 0; LIndex < NodeCount; LIndex++)
					LExpression.Expressions.Add(Nodes[LIndex].EmitStatement(AMode));
				LExpression.Modifiers = Modifiers;
				foreach (Schema.Key LKey in TableVar.Keys)
					if (LKey.Columns.Count < TableVar.Columns.Count)
						LExpression.Keys.Add(LKey.EmitStatement(AMode));
				return LExpression;
			}
		}
    }
    
	// Internal instruction to convert a table opened from a TableNode.Execute to a TableValue
    public class TableToTableValueNode : PlanNode
    {
		public TableToTableValueNode() : base()
		{
			IgnoreUnsupported = true;
		}
		
		public TableToTableValueNode(TableNode ASourceNode) : base()
		{
			IgnoreUnsupported = true;
			Nodes.Add(ASourceNode);
		}
		
		public TableNode SourceNode { get { return (TableNode)Nodes[0]; } }
		
		public override void DetermineCharacteristics(Plan APlan)
		{
			IsLiteral = SourceNode.IsLiteral;
			IsFunctional = SourceNode.IsFunctional;
			IsDeterministic = SourceNode.IsDeterministic;
			IsRepeatable = SourceNode.IsRepeatable;
			IsNilable = SourceNode.IsLiteral;
		}
		
		public override void DetermineDataType(Plan APlan)
		{
			DetermineModifiers(APlan);
			FDataType = SourceNode.DataType;
		}

		public override object InternalExecute(ServerProcess AProcess)
		{	
			Table LTable = SourceNode.Execute(AProcess) as Table;
			LTable.Open();
			try
			{
				// We need to construct a new TableVar here because otherwise the native table
				// will be constructed with the keys inferred for the source, resulting in
				// incorrect access plans (see Defect #33978 for more).
				Schema.ResultTableVar LTableVar = new Schema.ResultTableVar(SourceNode);
				LTableVar.Owner = AProcess.Plan.User;
				LTableVar.EnsureTableVarColumns();
				LTableVar.EnsureKey(AProcess.Plan);
				
				NativeTable LNativeTable = new NativeTable(AProcess, LTableVar);
				while (LTable.Next())
				{
					using (Row LRow = LTable.Select())
					{	
						LNativeTable.Insert(AProcess, LRow);
					}
				}
				return new TableValue(AProcess, LNativeTable);
			}
			finally
			{
				LTable.Dispose();
			}
		}
		
		public override Statement EmitStatement(EmitMode AMode)
		{
			return SourceNode.EmitStatement(AMode);
		}
    }
    
    // Internal instruction to convert a TableValue returned from a non-TableNode.Execute to a Table
    public class TableValueToTableNode : TableNode
    {
		public TableValueToTableNode() : base() {}
		
		public override void DetermineCharacteristics(Plan APlan)
		{
			IsLiteral = Nodes[0].IsLiteral;
			IsFunctional = Nodes[0].IsFunctional;
			IsDeterministic = Nodes[0].IsDeterministic;
			IsRepeatable = Nodes[0].IsRepeatable;
			IsNilable = Nodes[0].IsLiteral;
		}
		
		public override void DetermineDataType(Plan APlan)
		{
			DetermineModifiers(APlan);
			FDataType = Nodes[0].DataType;
			TableVar = new Schema.ResultTableVar(this);
			FTableVar.Owner = APlan.User;
			TableVar.EnsureTableVarColumns();
			TableVar.EnsureKey(APlan);
		}

		public override void DetermineCursorBehavior(Plan APlan)
		{
			FCursorType = CursorType.Static;
			FRequestedCursorType = APlan.CursorContext.CursorType;
			FCursorCapabilities = CursorCapability.Navigable | CursorCapability.BackwardsNavigable | CursorCapability.Searchable | CursorCapability.Bookmarkable;
			if (Nodes[0] is StackReferenceNode)
				FCursorCapabilities |= CursorCapability.Updateable;
			FCursorIsolation = CursorIsolation.None;
			Order = FTableVar.FindClusteringOrder(APlan);
		}
		
		public override object InternalExecute(ServerProcess AProcess)
		{
			TableValue LTableValue = Nodes[0].Execute(AProcess) as TableValue;
			TableScan LTable = new TableValueScan(this, AProcess);
			LTable.NativeTable = LTableValue.AsNative as NativeTable;
			LTable.Key = LTable.NativeTable.TableVar.FindClusteringOrder(AProcess.Plan);
			LTable.Direction = ScanDirection.Forward;
			LTable.Open();

			return LTable;
		}
		
		public override Statement EmitStatement(EmitMode AMode)
		{
			return Nodes[0].EmitStatement(AMode);
		}
		
		protected NativeTable GetNativeTable(ServerProcess AProcess)
		{
			StackReferenceNode LNode = Nodes[0] as StackReferenceNode;
			if (LNode != null)
			{
				TableValue LTableValue = AProcess.Context.Peek(LNode.Location) as TableValue;
				if (LTableValue != null)
					return LTableValue.AsNative as NativeTable;
			}
			return null;
		}

		// TODO: Revisit update semantics here. Why are we updating what should be an rvalue?		
		protected override void InternalExecuteInsert(ServerProcess AProcess, Row AOldRow, Row ANewRow, BitArray AValueFlags, bool AUnchecked)
		{
			NativeTable LNativeTable = GetNativeTable(AProcess);
			if (LNativeTable != null)
				LNativeTable.Insert(AProcess, ANewRow);
			else
				base.InternalExecuteInsert(AProcess, AOldRow, ANewRow, AValueFlags, AUnchecked);
		}
		
		protected override void InternalExecuteUpdate(ServerProcess AProcess, Row AOldRow, Row ANewRow, BitArray AValueFlags, bool ACheckConcurrency, bool AUnchecked)
		{
		
			NativeTable LNativeTable = GetNativeTable(AProcess);
			if (LNativeTable != null)
				LNativeTable.Update(AProcess, AOldRow, ANewRow);
			else
				base.InternalExecuteUpdate(AProcess, AOldRow, ANewRow, AValueFlags, ACheckConcurrency, AUnchecked);
		}
		
		protected override void InternalExecuteDelete(ServerProcess AProcess, Row ARow, bool ACheckConcurrency, bool AUnchecked)
		{
			NativeTable LNativeTable = GetNativeTable(AProcess);
			if (LNativeTable != null)
				LNativeTable.Delete(AProcess, ARow);
			else
				base.InternalExecuteDelete(AProcess, ARow, ACheckConcurrency, AUnchecked);
		}
    }
    
    public abstract class TableVarNode : TableNode
    {
		public TableVarNode() : base(){}
		public TableVarNode(Schema.TableVar ATableVar) : base()
		{
			FTableVar = ATableVar;
		}
		
		public override void DetermineCharacteristics(Plan APlan)
		{
			FIsLiteral = false;
			FIsFunctional = true;
			FIsDeterministic = true;
			FIsRepeatable = true;
			FTableVar.DetermineRemotable(APlan.ServerProcess);

			bool LIsNilable = (PropagateInsert == PropagateAction.False || !PropagateUpdate);
			
			if (LIsNilable)
				foreach (Schema.TableVarColumn LColumn in TableVar.Columns)
					LColumn.IsNilable = LIsNilable;
		}
		
		public virtual void DetermineVariableProperties(Plan APlan)
		{
			switch (APlan.StatementContext.StatementType)
			{
				case StatementType.Insert : 
				case StatementType.Update :
				case StatementType.Delete :
				case StatementType.Assignment :
					if (FTableVar.IsConstant)
						throw new CompilerException(CompilerException.Codes.ConstantObjectCannotBeAssigned, APlan.CurrentStatement(), FTableVar.DisplayName);
					FTableVar.IsModified = true;
				break;
			}
		}
		
		public virtual void DetermineRights(Plan APlan)
		{
			FInsertRight = null;
			FUpdateRight = null;
			FDeleteRight = null;
			
			FHasInsertRight = false;
			FHasUpdateRight = false;
			FHasDeleteRight = false;
			
			Schema.TableVar LTableVar = null;
			if (FTableVar.IsATObject)
			{
				int LCatalogIndex = APlan.Catalog.IndexOfName(FTableVar.SourceTableName);
				if (LCatalogIndex >= 0)
					LTableVar = (Schema.TableVar)APlan.Catalog[LCatalogIndex];
			}
			else
				LTableVar = FTableVar;
				
			if (LTableVar != null)
			{
				FInsertRight = LTableVar.GetRight(Schema.RightNames.Insert);
				FUpdateRight = LTableVar.GetRight(Schema.RightNames.Update);
				FDeleteRight = LTableVar.GetRight(Schema.RightNames.Delete);
				
				switch (APlan.StatementContext.StatementType)
				{
					case StatementType.Select : 
						APlan.CheckRight(LTableVar.GetRight(Schema.RightNames.Select));
						if ((APlan.CursorContext.CursorCapabilities & CursorCapability.Updateable) != 0)
						{
							FHasInsertRight = APlan.HasRight(FInsertRight);
							FHasUpdateRight = APlan.HasRight(FUpdateRight);
							FHasDeleteRight = APlan.HasRight(FDeleteRight);
						}
					break;
					case StatementType.Insert : 
						APlan.CheckRight(FInsertRight); 
						FHasInsertRight = true;
						FHasUpdateRight = APlan.HasRight(FUpdateRight);
						FHasDeleteRight = APlan.HasRight(FDeleteRight);
					break;
					
					case StatementType.Update : 
						APlan.CheckRight(FUpdateRight); 
						FHasInsertRight = APlan.HasRight(FInsertRight);
						FHasUpdateRight = true;
						FHasDeleteRight = APlan.HasRight(FDeleteRight);
					break;

					case StatementType.Delete : 
						APlan.CheckRight(FDeleteRight); 
						FHasInsertRight = APlan.HasRight(FInsertRight);
						FHasUpdateRight = APlan.HasRight(FUpdateRight);
						FHasDeleteRight = true;
					break;
					
					case StatementType.Assignment : 
						APlan.CheckRight(FDeleteRight);
						APlan.CheckRight(FInsertRight);
						FHasDeleteRight = true;
						FHasUpdateRight = APlan.HasRight(FUpdateRight);
						FHasInsertRight = true;
					break;
				}
			}
			else
			{
				FHasInsertRight = true;
				FHasUpdateRight = true;
				FHasDeleteRight = true;
			}
		}
		
		protected string FInsertRight;
		protected string FUpdateRight;
		protected string FDeleteRight;
		
		protected bool FHasInsertRight;
		public bool HasInsertRight
		{
			get { return FHasInsertRight; }
			set { FHasInsertRight = value; }
		}
		
		protected bool FHasUpdateRight;
		public bool HasUpdateRight
		{
			get { return FHasUpdateRight; }
			set { FHasUpdateRight = value; }
		}
		
		protected bool FHasDeleteRight;
		public bool HasDeleteRight
		{
			get { return FHasDeleteRight; }
			set { FHasDeleteRight = value; }
		}
		
		// PropagateInsert
		private PropagateAction FPropagateInsert = PropagateAction.True;
		public PropagateAction PropagateInsert
		{
			get { return FPropagateInsert; }
			set { FPropagateInsert = value; }
		}
		
		// PropagateUpdate
		private bool FPropagateUpdate = true;
		public bool PropagateUpdate
		{
			get { return FPropagateUpdate; }
			set { FPropagateUpdate = value; }
		}
		
		// PropagateDelete
		private bool FPropagateDelete = true;
		public bool PropagateDelete
		{
			get { return FPropagateDelete; }
			set { FPropagateDelete = value; }
		}
		
		// PropagateDefault
		private bool FPropagateDefault = true;
		public bool PropagateDefault
		{
			get { return FPropagateDefault; }
			set { FPropagateDefault = value; }
		}
		
		// PropagateValidate
		private bool FPropagateValidate = true;
		public bool PropagateValidate
		{
			get { return FPropagateValidate; }
			set { FPropagateValidate = value; }
		}
		
		// PropagateChange
		private bool FPropagateChange = true;
		public bool PropagateChange
		{
			get { return FPropagateChange; }
			set { FPropagateChange = value; }
		}
		
		// ShouldTranslate
		private bool FShouldTranslate = true;
		public bool ShouldTranslate
		{
			get { return FShouldTranslate; }
			set { FShouldTranslate = value; }
		}
		
		// ShouldValidateKeyConstraints
		protected override bool ShouldValidateKeyConstraints(Schema.Transition ATransition)
		{
			switch (ATransition)
			{
				case Schema.Transition.Insert: return (FPropagateInsert == PropagateAction.True);
				case Schema.Transition.Update: return FPropagateUpdate;
				default: return base.ShouldValidateKeyConstraints(ATransition);
			}
		}
		
		// Insert
		public override void Insert(ServerProcess AProcess, Row AOldRow, Row ANewRow, BitArray AValueFlags, bool AUnchecked)
		{
			if (FPropagateInsert != PropagateAction.False)
			{
				base.Insert(AProcess, AOldRow, ANewRow, AValueFlags, AUnchecked);
			}
		}

		// Update
		public override void Update(ServerProcess AProcess, Row AOldRow, Row ANewRow, BitArray AValueFlags, bool ACheckConcurrency, bool AUnchecked)
		{
			if (FPropagateUpdate)
			{
				base.Update(AProcess, AOldRow, ANewRow, AValueFlags, ACheckConcurrency, AUnchecked);
			}
		}

		// Delete
		public override void Delete(ServerProcess AProcess, Row ARow, bool ACheckConcurrency, bool AUnchecked)
		{
			if (FPropagateDelete)
			{
				base.Delete(AProcess, ARow, ACheckConcurrency, AUnchecked);
			}
		}

		// Validate
		public override bool Validate(ServerProcess AProcess, Row AOldRow, Row ANewRow, BitArray AValueFlags, string AColumnName)
		{
			if (FPropagateValidate)
				return base.Validate(AProcess, AOldRow, ANewRow, AValueFlags, AColumnName);
			return false;
		}
		
		// Change
		public override bool Change(ServerProcess AProcess, Row AOldRow, Row ANewRow, BitArray AValueFlags, string AColumnName)
		{
			if (FPropagateChange)
				return base.Change(AProcess, AOldRow, ANewRow, AValueFlags, AColumnName);
			return false;
		}
		
		// Default
		public override bool Default(ServerProcess AProcess, Row AOldRow, Row ANewRow, BitArray AValueFlags, string AColumnName)
		{
			if (FPropagateDefault)
				return base.Default(AProcess, AOldRow, ANewRow, AValueFlags, AColumnName);
			return false;
		}

		protected override void DetermineModifiers(Plan APlan)
		{
			base.DetermineModifiers(APlan);

			if (Modifiers != null)
			{
				PropagateInsert = (PropagateAction)Enum.Parse(typeof(PropagateAction), LanguageModifiers.GetModifier(Modifiers, "PropagateInsert", PropagateInsert.ToString()), true);
				PropagateUpdate = Boolean.Parse(LanguageModifiers.GetModifier(Modifiers, "PropagateUpdate", PropagateUpdate.ToString()));
				PropagateDelete = Boolean.Parse(LanguageModifiers.GetModifier(Modifiers, "PropagateDelete", PropagateDelete.ToString()));
				PropagateDefault = Boolean.Parse(LanguageModifiers.GetModifier(Modifiers, "PropagateDefault", PropagateDefault.ToString()));
				PropagateValidate = Boolean.Parse(LanguageModifiers.GetModifier(Modifiers, "PropagateValidate", PropagateValidate.ToString()));
				PropagateChange = Boolean.Parse(LanguageModifiers.GetModifier(Modifiers, "PropagateChange", PropagateChange.ToString()));
				ShouldTranslate = Boolean.Parse(LanguageModifiers.GetModifier(Modifiers, "ShouldTranslate", ShouldTranslate.ToString()));
			}
		}
		
		// Default
		protected override bool InternalDefault(ServerProcess AProcess, Row AOldRow, Row ANewRow, BitArray AValueFlags, string AColumnName, bool AIsDescending)
		{
			BitArray LValueFlags = ANewRow.GetValueFlags();
			bool LChanged = DefaultColumns(AProcess, TableVar, ANewRow, AValueFlags, AColumnName);
			if (AIsDescending && LChanged)
				for (int LIndex = 0; LIndex < ANewRow.DataType.Columns.Count; LIndex++)
					if (!LValueFlags[LIndex] && ANewRow.HasValue(LIndex))
						Change(AProcess, AOldRow, ANewRow, AValueFlags, ANewRow.DataType.Columns[LIndex].Name);
			return LChanged;
		}
		
		// ExplicitBind
		private bool FExplicitBind;
		/// <summary>Indicates that this table var node is explicitly bound to the supporting variable for an application transaction and should not be re-bound to the actual table variable when re-compiled as part of a dynamic execution.</summary>
		public bool ExplicitBind
		{
			get { return FExplicitBind; }
			set { FExplicitBind = value; }
		}
		
		// Statement
		public override Statement EmitStatement(EmitMode AMode)
		{
			Expression LExpression;
			if ((FTableVar.SourceTableName != null) && ((AMode == EmitMode.ForRemote) || !FExplicitBind))
				LExpression = new TableIdentifierExpression(Schema.Object.EnsureRooted(FTableVar.SourceTableName));
			else if ((FTableVar.SessionObjectName != null) && (AMode != EmitMode.ForRemote))
				LExpression = new TableIdentifierExpression(Schema.Object.EnsureRooted(FTableVar.SessionObjectName));
			else
				LExpression = new TableIdentifierExpression(Schema.Object.EnsureRooted(FTableVar.Name));
			LExpression.Modifiers = Modifiers;
			return LExpression;
		}
    }
    
    // BaseTableVarNode ->
    //  Represents retrieval of a base table var.  Validation is
    //  all handled by the TableNode.  If the device does not support
    //  modification through statements, this node uses row level
    //  modification on the device.
    //
    // operator iRetrieveTable(scalar) : table{}
    public class BaseTableVarNode : TableVarNode
    {
		public BaseTableVarNode() : base()
		{
			ShouldCheckConcurrency = true;
		}
		
		public BaseTableVarNode(Schema.TableVar ATableVar) : base(ATableVar)
		{
			ShouldCheckConcurrency = true;
		}
		
        public override Schema.TableVar TableVar 
        { 
			get { return base.TableVar; } 
			set { base.TableVar = value; } 
		}
		
		public override void DetermineDataType(Plan APlan)
		{
			DetermineModifiers(APlan);
			FDataType = FTableVar.DataType;
			DetermineRights(APlan);
			DetermineVariableProperties(APlan);
		}
		
		public override void DetermineVariableProperties(Plan APlan)
		{
			base.DetermineVariableProperties(APlan);
			switch (APlan.StatementContext.StatementType)
			{
				case StatementType.Insert : 
				case StatementType.Update :
				case StatementType.Delete :
				case StatementType.Assignment :
					APlan.SetIsFunctional(false);
				break;
			}
		}
		
		public override void DetermineDevice(Plan APlan)
		{
			PrepareJoinApplicationTransaction(APlan);

			if (FTableVar is Schema.BaseTableVar)
				FDevice = ((Schema.BaseTableVar)FTableVar).Device;
			else
				throw new CompilerException(CompilerException.Codes.InvalidRetrieveTarget, APlan.CurrentStatement());

			if (FDevice != null)
			{
				APlan.ServerProcess.EnsureDeviceStarted(FDevice);
				Schema.DevicePlan LDevicePlan = FDevice.Prepare(APlan, this);
				if (!LDevicePlan.IsSupported)
					throw new RuntimeException(RuntimeException.Codes.NoSupportingDevice, FDevice.Name, FTableVar.DisplayName);

				APlan.AddDevicePlan(LDevicePlan);
				FDeviceSupported = true;
				CheckDeviceRights(APlan);
				if ((FCursorCapabilities & CursorCapability.Updateable) != 0)
				{
					DetermineModifySupported(APlan);
					FSymbols = Compiler.SnapshotSymbols(APlan);
				}
			}
			else
				FNoDevice = true;
		}
		
		protected void CheckDeviceRights(Plan APlan)
		{
			if ((Device != null) && !FTableVar.IsATObject)
			{
				APlan.CheckRight(Device.GetRight(Schema.RightNames.Read));
				if ((FCursorCapabilities & CursorCapability.Updateable) != 0)
					APlan.CheckRight(Device.GetRight(Schema.RightNames.Write));
			}
		}
		
		public override void BindToProcess(Plan APlan)
		{
			CheckDeviceRights(APlan);
			DetermineRights(APlan);
			APlan.ServerProcess.EnsureApplicationTransactionTableVar(FTableVar);
			base.BindToProcess(APlan);
		}
		
		// Execute		
		public override object InternalExecute(ServerProcess AProcess)
		{
			throw new RuntimeException(RuntimeException.Codes.NoSupportingDevice);
		}
		
		protected void InternalInsert(ServerProcess AProcess, Row ARow, BitArray AValueFlags)
		{
			if (!FHasInsertRight)
				throw new ServerException(ServerException.Codes.UnauthorizedRight, ErrorSeverity.Environment, AProcess.Plan.User.ID, FInsertRight);
			AProcess.DeviceConnect(FDevice).InsertRow(FTableVar, ARow, AValueFlags);
		}
		
		// Insert
		protected override void InternalExecuteInsert(ServerProcess AProcess, Row AOldRow, Row ANewRow, BitArray AValueFlags, bool AUnchecked)
		{
			switch (PropagateInsert)
			{
				case PropagateAction.True : 
					InternalInsert(AProcess, ANewRow, AValueFlags); 
				break;
				
				case PropagateAction.Ensure :
				case PropagateAction.Ignore :
					using (Row LSourceRow = new Row(AProcess, DataType.RowType))
					{
						ANewRow.CopyTo(LSourceRow);
						using (Row LCurrentRow = Select(AProcess, LSourceRow))
						{
							if (LCurrentRow != null)
							{
								if (PropagateInsert == PropagateAction.Ensure)
									InternalUpdate(AProcess, LCurrentRow, ANewRow, AValueFlags, false);
							}
							else
								InternalInsert(AProcess, ANewRow, AValueFlags);
						}
					}
				break;
			}
		}
		
		protected void InternalUpdate(ServerProcess AProcess, Row AOldRow, Row ANewRow, BitArray AValueFlags, bool ACheckConcurrency)
		{
			if (!FHasUpdateRight)
				throw new ServerException(ServerException.Codes.UnauthorizedRight, ErrorSeverity.Environment, AProcess.Plan.User.ID, FUpdateRight);
			AProcess.DeviceConnect(FDevice).UpdateRow(FTableVar, AOldRow, ANewRow, AValueFlags);
		}
		
		// Update
		protected override void InternalExecuteUpdate(ServerProcess AProcess, Row AOldRow, Row ANewRow, BitArray AValueFlags, bool ACheckConcurrency, bool AUnchecked)
		{
			if (PropagateUpdate)
				InternalUpdate(AProcess, AOldRow, ANewRow, AValueFlags, ACheckConcurrency);
		}
		
		// Delete
		protected override void InternalExecuteDelete(ServerProcess AProcess, Row ARow, bool ACheckConcurrency, bool AUnchecked)
		{
			if (PropagateDelete)
			{
				if (!FHasDeleteRight)
					throw new ServerException(ServerException.Codes.UnauthorizedRight, ErrorSeverity.Environment, AProcess.Plan.User.ID, FDeleteRight);
				AProcess.DeviceConnect(FDevice).DeleteRow(FTableVar, ARow);
			}
		}
		
		private PlanNode FJoinATNode;
		
		private void EnsureJoinATNode(Plan APlan, Schema.RowType ARowType)
		{
			if (FJoinATNode == null)
			{
				Schema.RowType LKeyType = new Schema.RowType(FTableVar.FindClusteringKey().Columns);
				APlan.Symbols.Push(new Symbol("ATRow", ARowType));
				try
				{
					InsertStatement LInsertStatement =
						new InsertStatement
						(
							new RestrictExpression
							(
								new IdentifierExpression(Schema.Object.EnsureRooted(FTableVar.SourceTableName)), 
								Compiler.BuildKeyEqualExpression
								(
									APlan, 
									String.Empty, 
									"ATRow", 
									LKeyType.Columns,
									LKeyType.Columns
								)
							), 
							new IdentifierExpression(Schema.Object.EnsureRooted(FTableVar.Name))
						);
						
					LInsertStatement.Modifiers = new LanguageModifiers();
					LInsertStatement.Modifiers.Add(new LanguageModifier("Unchecked", "True"));

					Statement LStatement = 
						new IfStatement
						(
							new UnaryExpression
							(
								Instructions.Not, 
								new UnaryExpression
								(
									Instructions.Exists, 
									new RestrictExpression
									(
										new IdentifierExpression(Schema.Object.EnsureRooted(FTableVar.Name)), 
										Compiler.BuildKeyEqualExpression
										(
											APlan, 
											String.Empty, 
											"ATRow", 
											LKeyType.Columns, 
											LKeyType.Columns
										)
									)
								)
							), 
							LInsertStatement,
							null
						);
					ApplicationTransaction LTransaction = APlan.ServerProcess.GetApplicationTransaction();
					try
					{
						LTransaction.PushGlobalContext();
						try
						{
							APlan.PushSecurityContext(new SecurityContext(FTableVar.Owner));
							try
							{
								FJoinATNode = Compiler.BindNode(APlan, Compiler.CompileStatement(APlan, LStatement));
								APlan.CheckCompiled();
							}
							finally
							{
								APlan.PopSecurityContext();
							}
						}
						finally
						{
							LTransaction.PopGlobalContext();
						}
					}
					finally
					{
						Monitor.Exit(LTransaction);
					}
				}
				finally
				{
					APlan.Symbols.Pop();
				}
			}
		}

		public override void JoinApplicationTransaction(ServerProcess AProcess, Row ARow) 
		{
			/*
				if this retrieve is from an ATTable
					if not exists (ATTable where KeyColumns = ARow.KeyColumns)
						insert with { Unchecked = "True" } SourceTable where KeyColumns = ARow.KeyColumns into ATTable
			*/
			if (FTableVar.SourceTableName != null)
			{
				EnsureJoinATNode(AProcess.Plan, (Schema.RowType)ARow.DataType);
				AProcess.Context.Push(ARow);
				try
				{
					FJoinATNode.Execute(AProcess);
				}
				finally
				{
					AProcess.Context.Pop();
				}
			}
		}
    }
    
    // DerivedTableVarNode ->
    //  Represents retrieval of a virtual table var.
    //  There is no corresponding operator for this Node, it is used
    //  to ensure that the table type generated for the view maintains the
    //  keys, orders and constraints defined solely on this view.
    public class DerivedTableVarNode : TableVarNode
    {
		public DerivedTableVarNode() : base(){}
		public DerivedTableVarNode(Schema.TableVar ATableVar) : base(ATableVar){}

		public override void DetermineDataType(Plan APlan)
		{
			DetermineModifiers(APlan);
			FDataType = FTableVar.DataType;
			DetermineRights(APlan);
			DetermineVariableProperties(APlan);

			// Compile the invocation expression for the view
			APlan.PushSecurityContext(new SecurityContext(FTableVar.Owner));
			try
			{
				APlan.PushATCreationContext();
				try
				{
					Nodes.Add(Compiler.CompileExpression(APlan, ((Schema.DerivedTableVar)FTableVar).InvocationExpression));
				}
				finally
				{
					APlan.PopATCreationContext();
				}
			}
			finally
			{
				APlan.PopSecurityContext();
			}
		}
		
		public override void DetermineVariableProperties(Plan APlan)
		{
			base.DetermineVariableProperties(APlan);
			switch (APlan.StatementContext.StatementType)
			{
				case StatementType.Insert : 
				case StatementType.Update :
				case StatementType.Delete :
				case StatementType.Assignment :
					APlan.SetIsFunctional(false);
				break;
			}
		}
		
		public override void DetermineCursorBehavior(Plan APlan)
		{
			FCursorType = SourceNode.CursorType;
			FRequestedCursorType = APlan.CursorContext.CursorType;
			FCursorCapabilities = SourceNode.CursorCapabilities;
			if (TableVar.HasHandlers(APlan.ServerProcess))
				FCursorCapabilities |= CursorCapability.Updateable;
			FCursorIsolation = SourceNode.CursorIsolation;
			if (SourceNode.Order != null)
				Order = CopyOrder(SourceNode.Order);
			else
				Order = null;
		}
		
		public override void BindToProcess(Plan APlan)
		{
			DetermineRights(APlan);
			APlan.ServerProcess.EnsureApplicationTransactionTableVar(FTableVar);

			// Binding below the derived table variable should be based on the security context of the view owner
			if (FTableVar.Owner != null)
				APlan.PushSecurityContext(new SecurityContext(FTableVar.Owner));
			try
			{
				base.BindToProcess(APlan); 
			}
			finally
			{
				if (FTableVar.Owner != null)
					APlan.PopSecurityContext();
			}
		}
		
		// DerivedTableVar
		public Schema.DerivedTableVar DerivedTableVar { get { return (Schema.DerivedTableVar)TableVar; } }
		
		// SourceNode
		public TableNode SourceNode { get { return (TableNode)Nodes[0]; } }
		
		// SourceTableType
		public Schema.TableType SourceTableType { get { return (Schema.TableType)SourceNode.DataType; } }
		
		// Default
		protected override bool InternalDefault(ServerProcess AProcess, Row AOldRow, Row ANewRow, BitArray AValueFlags, string AColumnName, bool AIsDescending)
		{
			bool LChanged = false;
			if (AIsDescending)
				LChanged = SourceNode.Default(AProcess, AOldRow, ANewRow, AValueFlags, AColumnName);
			return base.InternalDefault(AProcess, AOldRow, ANewRow, AValueFlags, AColumnName, AIsDescending) || LChanged;
		}
		
		// Validate
		protected override bool InternalValidate(ServerProcess AProcess, Row AOldRow, Row ANewRow, BitArray AValueFlags, string AColumnName, bool AIsDescending, bool AIsProposable)
		{
			bool LChanged = false;
			if (AIsDescending)
				LChanged = SourceNode.Validate(AProcess, AOldRow, ANewRow, AValueFlags, AColumnName);
			return base.InternalValidate(AProcess, AOldRow, ANewRow, AValueFlags, AColumnName, AIsDescending, AIsProposable) || LChanged;
		}
		
		// Change
		protected override bool InternalChange(ServerProcess AProcess, Row AOldRow, Row ANewRow, BitArray AValueFlags, string AColumnName)
		{
			return SourceNode.Change(AProcess, AOldRow, ANewRow, AValueFlags, AColumnName);
		}
		
		// Insert
		protected void InternalInsert(ServerProcess AProcess, Row AOldRow, Row ANewRow, BitArray AValueFlags, bool AUnchecked)
		{
			if (!FHasInsertRight)
				throw new ServerException(ServerException.Codes.UnauthorizedRight, ErrorSeverity.Environment, AProcess.Plan.User.ID, FInsertRight);
			SourceNode.Insert(AProcess, AOldRow, ANewRow, AValueFlags, AUnchecked);
		}
		
		protected override void InternalExecuteInsert(ServerProcess AProcess, Row AOldRow, Row ANewRow, BitArray AValueFlags, bool AUnchecked)
		{
			switch (PropagateInsert)
			{
				case PropagateAction.True : 
					InternalInsert(AProcess, AOldRow, ANewRow, AValueFlags, AUnchecked);
				break;

				case PropagateAction.Ensure :
				case PropagateAction.Ignore :
					using (Row LSourceRow = new Row(AProcess, SourceNode.DataType.RowType))
					{
						ANewRow.CopyTo(LSourceRow);
						using (Row LCurrentRow = SourceNode.Select(AProcess, LSourceRow))
						{
							if (LCurrentRow != null)
							{
								if (PropagateInsert == PropagateAction.Ensure)
									InternalUpdate(AProcess, LCurrentRow, ANewRow, AValueFlags, false, AUnchecked);
							}
							else
								InternalInsert(AProcess, AOldRow, ANewRow, AValueFlags, AUnchecked);
						}
					}
				break;
			}
		}
		
		// Update
		protected void InternalUpdate(ServerProcess AProcess, Row AOldRow, Row ANewRow, BitArray AValueFlags, bool ACheckConcurrency, bool AUnchecked)
		{
			if (!FHasUpdateRight)
				throw new ServerException(ServerException.Codes.UnauthorizedRight, ErrorSeverity.Environment, AProcess.Plan.User.ID, FUpdateRight);
			SourceNode.Update(AProcess, AOldRow, ANewRow, AValueFlags, ACheckConcurrency, AUnchecked);
		}
		
		protected override void InternalExecuteUpdate(ServerProcess AProcess, Row AOldRow, Row ANewRow, BitArray AValueFlags, bool ACheckConcurrency, bool AUnchecked)
		{
			if (PropagateUpdate)
				InternalUpdate(AProcess, AOldRow, ANewRow, AValueFlags, ACheckConcurrency, AUnchecked);
		}
		
		// Delete
		protected override void InternalExecuteDelete(ServerProcess AProcess, Row ARow, bool ACheckConcurrency, bool AUnchecked)
		{
			if (PropagateDelete)
			{
				if (!FHasDeleteRight)
					throw new ServerException(ServerException.Codes.UnauthorizedRight, ErrorSeverity.Environment, AProcess.Plan.User.ID, FDeleteRight);
				SourceNode.Delete(AProcess, ARow, ACheckConcurrency, AUnchecked);
			}
		}
		
		public override object InternalExecute(ServerProcess AProcess)
		{
			return Nodes[0].Execute(AProcess);
		}

		public override void JoinApplicationTransaction(ServerProcess AProcess, Row ARow) 
		{
			SourceNode.JoinApplicationTransaction(AProcess, ARow);
		}
    }
    
    public abstract class UnaryTableNode : TableNode
    {
		// SourceNode
		public TableNode SourceNode { get { return (TableNode)Nodes[0]; } }
		
		// SourceTableVar
		public Schema.TableVar SourceTableVar { get { return SourceNode.TableVar; } }
		
		// SourceTableType
		public Schema.ITableType SourceTableType { get { return SourceNode.DataType; } }
		
		// PropagateInsert
		private PropagateAction FPropagateInsert = PropagateAction.True;
		public PropagateAction PropagateInsert
		{
			get { return FPropagateInsert; }
			set { FPropagateInsert = value; }
		}
		
		// PropagateUpdate
		private bool FPropagateUpdate = true;
		public bool PropagateUpdate
		{
			get { return FPropagateUpdate; }
			set { FPropagateUpdate = value; }
		}
		
		// PropagateDelete
		private bool FPropagateDelete = true;
		public bool PropagateDelete
		{
			get { return FPropagateDelete; }
			set { FPropagateDelete = value; }
		}
		
		// PropagateDefault
		private bool FPropagateDefault = true;
		public bool PropagateDefault
		{
			get { return FPropagateDefault; }
			set { FPropagateDefault = value; }
		}
		
		// PropagateValidate
		private bool FPropagateValidate = true;
		public bool PropagateValidate
		{
			get { return FPropagateValidate; }
			set { FPropagateValidate = value; }
		}
		
		// PropagateChange
		private bool FPropagateChange = true;
		public bool PropagateChange
		{
			get { return FPropagateChange; }
			set { FPropagateChange = value; }
		}
		
		// ShouldTranslate
		private bool FShouldTranslate = true;
		public bool ShouldTranslate
		{
			get { return FShouldTranslate; }
			set { FShouldTranslate = value; }
		}
		
		protected override void DetermineModifiers(Plan APlan)
		{
			base.DetermineModifiers(APlan);

			if (Modifiers != null)
			{
				PropagateInsert = (PropagateAction)Enum.Parse(typeof(PropagateAction), LanguageModifiers.GetModifier(Modifiers, "PropagateInsert", PropagateInsert.ToString()), true);
				PropagateUpdate = Boolean.Parse(LanguageModifiers.GetModifier(Modifiers, "PropagateUpdate", PropagateUpdate.ToString()));
				PropagateDelete = Boolean.Parse(LanguageModifiers.GetModifier(Modifiers, "PropagateDelete", PropagateDelete.ToString()));
				PropagateDefault = Boolean.Parse(LanguageModifiers.GetModifier(Modifiers, "PropagateDefault", PropagateDefault.ToString()));
				PropagateValidate = Boolean.Parse(LanguageModifiers.GetModifier(Modifiers, "PropagateValidate", PropagateValidate.ToString()));
				PropagateChange = Boolean.Parse(LanguageModifiers.GetModifier(Modifiers, "PropagateChange", PropagateChange.ToString()));
				ShouldTranslate = Boolean.Parse(LanguageModifiers.GetModifier(Modifiers, "ShouldTranslate", ShouldTranslate.ToString()));
			}
		}
		
		public override void DetermineCharacteristics(Plan APlan)
		{
			base.DetermineCharacteristics(APlan);

			bool LIsNilable = (PropagateInsert == PropagateAction.False || !PropagateUpdate);
			
			if (LIsNilable)
				foreach (Schema.TableVarColumn LColumn in TableVar.Columns)
					LColumn.IsNilable = LIsNilable;
		}
		
		public override void DetermineRemotable(Plan APlan)
		{
			Schema.ResultTableVar LTableVar = (Schema.ResultTableVar)TableVar;
			LTableVar.InferredIsDefaultRemotable = !PropagateDefault || SourceTableVar.IsDefaultRemotable;
			LTableVar.InferredIsChangeRemotable = !PropagateChange || SourceTableVar.IsChangeRemotable;
			LTableVar.InferredIsValidateRemotable = !PropagateValidate || SourceTableVar.IsValidateRemotable;
			base.DetermineRemotable(APlan);
			
			LTableVar.ShouldChange = PropagateChange && (LTableVar.ShouldChange || SourceTableVar.ShouldChange);
			LTableVar.ShouldDefault = PropagateDefault && (LTableVar.ShouldDefault || SourceTableVar.ShouldDefault);
			LTableVar.ShouldValidate = PropagateValidate && (LTableVar.ShouldValidate || SourceTableVar.ShouldValidate);
			
			foreach (Schema.TableVarColumn LColumn in LTableVar.Columns)
			{
				int LSourceColumnIndex = SourceTableVar.Columns.IndexOfName(LColumn.Name);
				if (LSourceColumnIndex >= 0)
				{
					Schema.TableVarColumn LSourceColumn = SourceTableVar.Columns[LSourceColumnIndex];

					LColumn.ShouldChange = PropagateChange && (LColumn.ShouldChange || LSourceColumn.ShouldChange);
					LTableVar.ShouldChange = LTableVar.ShouldChange || LColumn.ShouldChange;

					LColumn.ShouldDefault = PropagateDefault && (LColumn.ShouldDefault || LSourceColumn.ShouldDefault);
					LTableVar.ShouldDefault = LTableVar.ShouldDefault || LColumn.ShouldDefault;

					LColumn.ShouldValidate = PropagateValidate && (LColumn.ShouldValidate || LSourceColumn.ShouldValidate);
					LTableVar.ShouldValidate = LTableVar.ShouldValidate || LColumn.ShouldValidate;
				}
			}
		}
		
		// Default
		protected override bool InternalDefault(ServerProcess AProcess, Row AOldRow, Row ANewRow, BitArray AValueFlags, string AColumnName, bool AIsDescending)
		{
			if (AIsDescending && PropagateDefault)
				return SourceNode.Default(AProcess, AOldRow, ANewRow, AValueFlags, AColumnName);
			return base.InternalDefault(AProcess, AOldRow, ANewRow, AValueFlags, AColumnName, AIsDescending);
		}
		
		// Change
		protected override bool InternalChange(ServerProcess AProcess, Row AOldRow, Row ANewRow, BitArray AValueFlags, string AColumnName)
		{
			if (PropagateChange)
				return SourceNode.Change(AProcess, AOldRow, ANewRow, AValueFlags, AColumnName);
			return base.InternalChange(AProcess, AOldRow, ANewRow, AValueFlags, AColumnName);
		}
		
		// Validate
		protected override bool InternalValidate(ServerProcess AProcess, Row AOldRow, Row ANewRow, BitArray AValueFlags, string AColumnName, bool AIsDescending, bool AIsProposable)
		{
			if (AIsDescending && PropagateValidate)
				return SourceNode.Validate(AProcess, AOldRow, ANewRow, AValueFlags, AColumnName);
			return base.InternalValidate(AProcess, AOldRow, ANewRow, AValueFlags, AColumnName, AIsDescending, AIsProposable);
		}

		// Insert
		protected override void InternalExecuteInsert(ServerProcess AProcess, Row AOldRow, Row ANewRow, BitArray AValueFlags, bool AUnchecked)
		{
			switch (PropagateInsert)
			{
				case PropagateAction.True : 
					SourceNode.Insert(AProcess, AOldRow, ANewRow, AValueFlags, AUnchecked); 
				break;

				case PropagateAction.Ensure :
				case PropagateAction.Ignore :
					using (Row LSourceRow = new Row(AProcess, SourceNode.DataType.RowType))
					{
						ANewRow.CopyTo(LSourceRow);
						using (Row LCurrentRow = SourceNode.Select(AProcess, LSourceRow))
						{
							if (LCurrentRow != null)
							{
								if (PropagateInsert == PropagateAction.Ensure)
									SourceNode.Update(AProcess, LCurrentRow, ANewRow, AValueFlags, false, AUnchecked);
							}
							else
								SourceNode.Insert(AProcess, AOldRow, ANewRow, AValueFlags, AUnchecked);
						}
					}
				break;
			}
		}
		
		// Update
		protected override void InternalExecuteUpdate(ServerProcess AProcess, Row AOldRow, Row ANewRow, BitArray AValueFlags, bool ACheckConcurrency, bool AUnchecked)
		{
			if (PropagateUpdate)
				SourceNode.Update(AProcess, AOldRow, ANewRow, AValueFlags, ACheckConcurrency, AUnchecked);
		}
		
		// Delete
		protected override void InternalExecuteDelete(ServerProcess AProcess, Row ARow, bool ACheckConcurrency, bool AUnchecked)
		{
			if (PropagateDelete)
				SourceNode.Delete(AProcess, ARow, ACheckConcurrency, AUnchecked);
		}
		
		public override void JoinApplicationTransaction(ServerProcess AProcess, Row ARow) 
		{
			SourceNode.JoinApplicationTransaction(AProcess, ARow);
		}
	}
	
	// operator iOn(object)	: table{}
	public class OnNode : TableNode
	{
		protected OnExpression FOnExpression;
		public OnExpression OnExpression
		{
			get { return FOnExpression; }
			set { FOnExpression = value; }
		}
		
		protected Schema.ServerLink FServerLink;
		public Schema.ServerLink ServerLink
		{
			get { return FServerLink; }
			set { FServerLink = value; }
		}
		
		protected string FExpression;
		public string Expression
		{
			get
			{
				return FExpression;
			}
		}
		
		public override void DetermineDataType(Plan APlan)
		{
			DetermineModifiers(APlan);
			
			// OnNode data type is copied, not reference because the plan is volatile.
			Schema.Object LObject = Compiler.ResolveCatalogIdentifier(APlan, FOnExpression.ServerName);
			if (LObject == null)
				throw new CompilerException(CompilerException.Codes.UnknownIdentifier, FOnExpression, FOnExpression.ServerName);
				
			if (!(LObject is Schema.ServerLink))
				throw new CompilerException(CompilerException.Codes.ServerLinkExpected, FOnExpression);
				
			FServerLink = (Schema.ServerLink)LObject;
			
			CursorDefinition LCursorDefinition = FOnExpression.Expression as CursorDefinition;
			if (LCursorDefinition == null)
				LCursorDefinition = new CursorDefinition(FOnExpression.Expression);
			FExpression = new D4TextEmitter().Emit(new SelectStatement(LCursorDefinition));
			Schema.TableVar LTableVar = APlan.ServerProcess.RemoteConnect(FServerLink).PrepareTableVar(FExpression, new DataParams());
			
			FDataType = new Schema.TableType();
			FTableVar = new Schema.ResultTableVar(this);
			FTableVar.Owner = APlan.User;
			FTableVar.InheritMetaData(LTableVar.MetaData);
			CopyTableVarColumns(LTableVar.Columns);
			CopyKeys(LTableVar.Keys);
			CopyOrders(LTableVar.Orders);
			FTableVar.IsRemotable = false;
		}
		
		public override void DetermineDevice(Plan APlan)
		{
			FNoDevice = true;
		}

		public override Statement EmitStatement(EmitMode AMode)
		{
			return FOnExpression;
		}
		
		public override object InternalExecute(ServerProcess AProcess)
		{
			LocalTable LTable = new LocalTable(this, AProcess, (TableValue)AProcess.RemoteConnect(FServerLink).Evaluate(FExpression, new DataParams()));
			try
			{
				LTable.Open();
				return LTable;
			}
			catch
			{
				LTable.Dispose();
				throw;
			}
		}
	}
	
	public abstract class BinaryTableNode : TableNode
	{
		// LeftNode
		public TableNode LeftNode { get { return (TableNode)Nodes[0]; } }
		
		// LeftTableVar
		public Schema.TableVar LeftTableVar { get { return LeftNode.TableVar; } }
		
		// LeftTableType
		public Schema.TableType LeftTableType { get { return (Schema.TableType)LeftNode.DataType; } }
		
		// RightNode
		public TableNode RightNode { get { return (TableNode)Nodes[1]; } }
		
		// RightTableVar
		public Schema.TableVar RightTableVar { get { return RightNode.TableVar; } }
		
		// RightTableType
		public Schema.TableType RightTableType { get { return (Schema.TableType)RightNode.DataType; } }

		// PropagateInsertLeft
		private PropagateAction FPropagateInsertLeft = PropagateAction.True;
		public PropagateAction PropagateInsertLeft
		{
			get { return FPropagateInsertLeft; }
			set { FPropagateInsertLeft = value; }
		}
		
		// PropagateUpdateLeft
		private bool FPropagateUpdateLeft = true;
		public bool PropagateUpdateLeft
		{
			get { return FPropagateUpdateLeft; }
			set { FPropagateUpdateLeft = value; }
		}
		
		// PropagateDeleteLeft
		private bool FPropagateDeleteLeft = true;
		public bool PropagateDeleteLeft
		{
			get { return FPropagateDeleteLeft; }
			set { FPropagateDeleteLeft = value; }
		}
		
		// PropagateDefaultLeft
		private bool FPropagateDefaultLeft = true;
		public bool PropagateDefaultLeft
		{
			get { return FPropagateDefaultLeft; }
			set { FPropagateDefaultLeft = value; }
		}
		
		// PropagateValidateLeft
		private bool FPropagateValidateLeft = true;
		public bool PropagateValidateLeft
		{
			get { return FPropagateValidateLeft; }
			set { FPropagateValidateLeft = value; }
		}
		
		// PropagateChangeLeft
		private bool FPropagateChangeLeft = true;
		public bool PropagateChangeLeft
		{
			get { return FPropagateChangeLeft; }
			set { FPropagateChangeLeft = value; }
		}
		
		// ShouldTranslateLeft
		private bool FShouldTranslateLeft = true;
		public bool ShouldTranslateLeft
		{
			get { return FShouldTranslateLeft; }
			set { FShouldTranslateLeft = value; }
		}
		
		// PropagateInsertRight
		private PropagateAction FPropagateInsertRight = PropagateAction.True;
		public PropagateAction PropagateInsertRight
		{
			get { return FPropagateInsertRight; }
			set { FPropagateInsertRight = value; }
		}
		
		// PropagateUpdateRight
		private bool FPropagateUpdateRight = true;
		public bool PropagateUpdateRight
		{
			get { return FPropagateUpdateRight; }
			set { FPropagateUpdateRight = value; }
		}
		
		// PropagateDeleteRight
		private bool FPropagateDeleteRight = true;
		public bool PropagateDeleteRight
		{
			get { return FPropagateDeleteRight; }
			set { FPropagateDeleteRight = value; }
		}
		
		// PropagateDefaultRight
		private bool FPropagateDefaultRight = true;
		public bool PropagateDefaultRight
		{
			get { return FPropagateDefaultRight; }
			set { FPropagateDefaultRight = value; }
		}
		
		// PropagateValidateRight
		private bool FPropagateValidateRight = true;
		public bool PropagateValidateRight
		{
			get { return FPropagateValidateRight; }
			set { FPropagateValidateRight = value; }
		}
		
		// PropagateChangeRight
		private bool FPropagateChangeRight = true;
		public bool PropagateChangeRight
		{
			get { return FPropagateChangeRight; }
			set { FPropagateChangeRight = value; }
		}
		
		// ShouldTranslateRight
		private bool FShouldTranslateRight = true;
		public bool ShouldTranslateRight
		{
			get { return FShouldTranslateRight; }
			set { FShouldTranslateRight = value; }
		}
		
		protected override void DetermineModifiers(Plan APlan)
		{
			base.DetermineModifiers(APlan);

			if (Modifiers != null)
			{
				PropagateInsertLeft = (PropagateAction)Enum.Parse(typeof(PropagateAction), LanguageModifiers.GetModifier(Modifiers, "Left.PropagateInsert", PropagateInsertLeft.ToString()), true);
				PropagateUpdateLeft = Boolean.Parse(LanguageModifiers.GetModifier(Modifiers, "Left.PropagateUpdate", PropagateUpdateLeft.ToString()));
				PropagateDeleteLeft = Boolean.Parse(LanguageModifiers.GetModifier(Modifiers, "Left.PropagateDelete", PropagateDeleteLeft.ToString()));
				PropagateDefaultLeft = Boolean.Parse(LanguageModifiers.GetModifier(Modifiers, "Left.PropagateDefault", PropagateDefaultLeft.ToString()));
				PropagateValidateLeft = Boolean.Parse(LanguageModifiers.GetModifier(Modifiers, "Left.PropagateValidate", PropagateValidateLeft.ToString()));
				PropagateChangeLeft = Boolean.Parse(LanguageModifiers.GetModifier(Modifiers, "Left.PropagateChange", PropagateChangeLeft.ToString()));
				ShouldTranslateLeft = Boolean.Parse(LanguageModifiers.GetModifier(Modifiers, "Left.ShouldTranslate", ShouldTranslateLeft.ToString()));
				PropagateInsertRight = (PropagateAction)Enum.Parse(typeof(PropagateAction), LanguageModifiers.GetModifier(Modifiers, "Right.PropagateInsert", PropagateInsertRight.ToString()), true);
				PropagateUpdateRight = Boolean.Parse(LanguageModifiers.GetModifier(Modifiers, "Right.PropagateUpdate", PropagateUpdateRight.ToString()));
				PropagateDeleteRight = Boolean.Parse(LanguageModifiers.GetModifier(Modifiers, "Right.PropagateDelete", PropagateDeleteRight.ToString()));
				PropagateDefaultRight = Boolean.Parse(LanguageModifiers.GetModifier(Modifiers, "Right.PropagateDefault", PropagateDefaultRight.ToString()));
				PropagateValidateRight = Boolean.Parse(LanguageModifiers.GetModifier(Modifiers, "Right.PropagateValidate", PropagateValidateRight.ToString()));
				PropagateChangeRight = Boolean.Parse(LanguageModifiers.GetModifier(Modifiers, "Right.PropagateChange", PropagateChangeRight.ToString()));
				ShouldTranslateRight = Boolean.Parse(LanguageModifiers.GetModifier(Modifiers, "Right.ShouldTranslate", ShouldTranslateRight.ToString()));
			}
		}
		
		public override void DetermineRemotable(Plan APlan)
		{
			Schema.ResultTableVar LTableVar = (Schema.ResultTableVar)TableVar;
			LTableVar.InferredIsDefaultRemotable = (!PropagateDefaultLeft || LeftTableVar.IsDefaultRemotable) && (!PropagateDefaultRight || RightTableVar.IsDefaultRemotable);
			LTableVar.InferredIsChangeRemotable = (!PropagateChangeLeft || LeftTableVar.IsChangeRemotable) && (!PropagateChangeRight || RightTableVar.IsChangeRemotable);
			LTableVar.InferredIsValidateRemotable = (!PropagateValidateLeft || LeftTableVar.IsValidateRemotable) && (!PropagateValidateRight || RightTableVar.IsValidateRemotable);
			base.DetermineRemotable(APlan);
		}
		
		protected override bool InternalDefault(ServerProcess AProcess, Row AOldRow, Row ANewRow, BitArray AValueFlags, string AColumnName, bool AIsDescending)
		{
			return false;
		}
		
		protected override bool InternalChange(ServerProcess AProcess, Row AOldRow, Row ANewRow, BitArray AValueFlags, string AColumnName)
		{
			return false;
		}
		
		protected override bool InternalValidate(ServerProcess AProcess, Row AOldRow, Row ANewRow, BitArray AValueFlags, string AColumnName, bool AIsDescending, bool AIsProposable)
		{
			return false;
		}
		
		protected override void InternalBeforeInsert(ServerProcess AProcess, Row ARow, BitArray AValueFlags)
		{
		}
		
		protected override void InternalAfterInsert(ServerProcess AProcess, Row ARow, BitArray AValueFlags)
		{
		}
		
		protected override void InternalExecuteInsert(ServerProcess AProcess, Row AOldRow, Row ANewRow, BitArray AValueFlags, bool AUnchecked)
		{
		}
		
		protected override void InternalBeforeUpdate(ServerProcess AProcess, Row AOldRow, Row ANewRow, BitArray AValueFlags)
		{
		}
		
		protected override void InternalAfterUpdate(ServerProcess AProcess, Row AOldRow, Row ANewRow, BitArray AValueFlags)
		{
		}
		
		protected override void InternalExecuteUpdate(ServerProcess AProcess, Row AOldRow, Row ANewRow, BitArray AValueFlags, bool ACheckConcurrency, bool AUnchecked)
		{
		}
		
		protected override void InternalBeforeDelete(ServerProcess AProcess, Row ARow)
		{
		}
		
		protected override void InternalAfterDelete(ServerProcess AProcess, Row ARow)
		{
		}
		
		protected override void InternalExecuteDelete(ServerProcess AProcess, Row ARow, bool ACheckConcurrency, bool AUnchecked)
		{
		}
	}
}

