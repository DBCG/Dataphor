<?xml version="1.0"?>
<chapter id="D4LGD4LanguageGuide"> 
	 <chapterinfo><date role="LastMod">Friday, June 27, 2003 5:13:57 PM</date> 
	 </chapterinfo> 
	 <title><indexterm><primary>D4 Language Guide</primary></indexterm>D4
		  Language Guide</title> 
	 <note> 
		  <para>There have been many changes in this Beta release. For the most
				current information on the D4 language see: 
				<itemizedlist> 
					 <listitem> 
						  <para>BetaNotes.rtf,</para> 
					 </listitem> 
					 <listitem> 
						  <para>DataphorReference.pdf section on the D4
								language.</para> 
					 </listitem> 
				</itemizedlist> </para> 
	 </note> 
	 <para>This chapter introduces the D4 language and discusses its intentions
		  and usage. This guide is organized as follows: 
		  <itemizedlist> 
				<listitem> 
					 <para>Introduction</para> 
				</listitem> 
				<listitem> 
					 <para>Scripts and Execution</para> 
				</listitem> 
				<listitem> 
					 <para>Lexical Elements</para> 
					 <itemizedlist> 
						  <listitem> 
								<para>Whitespace</para> 
						  </listitem> 
						  <listitem> 
								<para>Comments</para> 
						  </listitem> 
						  <listitem> 
								<para>Keywords</para> 
						  </listitem> 
						  <listitem> 
								<para>Symbols</para> 
						  </listitem> 
						  <listitem> 
								<para>Parser Literals</para> 
						  </listitem> 
						  <listitem> 
								<para>Identifiers</para> 
						  </listitem> 
						  <listitem> 
								<para>Case</para> 
						  </listitem> 
					 </itemizedlist> 
				</listitem> 
				<listitem> 
					 <para>Language Elements</para> 
					 <itemizedlist> 
						  <listitem> 
								<para>Types</para> 
						  </listitem> 
						  <listitem> 
								<para>Values</para> 
						  </listitem> 
						  <listitem> 
								<para>Variables</para> 
						  </listitem> 
						  <listitem> 
								<para>Operators</para> 
						  </listitem> 
						  <listitem> 
								<para>Statements</para> 
						  </listitem> 
						  <listitem> 
								<para>Expressions</para> 
						  </listitem> 
					 </itemizedlist> 
				</listitem> 
				<listitem> 
					 <para>Catalog Elements</para> 
					 <itemizedlist> 
						  <listitem> 
								<para>Objects</para> 
						  </listitem> 
						  <listitem> 
								<para>Domains</para> 
						  </listitem> 
						  <listitem> 
								<para>Table Variables</para> 
						  </listitem> 
						  <listitem> 
								<para>Constraints</para> 
						  </listitem> 
						  <listitem> 
								<para>References</para> 
						  </listitem> 
						  <listitem> 
								<para>Operators</para> 
						  </listitem> 
						  <listitem> 
								<para>Devices</para> 
						  </listitem> 
						  <listitem> 
								<para>Event Handlers</para> 
						  </listitem> 
						  <listitem> 
								<para>Sorts</para> 
						  </listitem> 
					 </itemizedlist> 
				</listitem> 
				<listitem> 
					 <para>Data Manipulation</para> 
					 <itemizedlist> 
						  <listitem> 
								<para>Select</para> 
						  </listitem> 
						  <listitem> 
								<para>Insert</para> 
						  </listitem> 
						  <listitem> 
								<para>Update</para> 
						  </listitem> 
						  <listitem> 
								<para>Delete</para> 
						  </listitem> 
					 </itemizedlist> 
				</listitem> 
				<listitem> 
					 <para>Table Expressions</para> 
					 <itemizedlist> 
						  <listitem> 
								<para>Restrict</para> 
						  </listitem> 
						  <listitem> 
								<para>Project and Remove</para> 
						  </listitem> 
						  <listitem> 
								<para>Add</para> 
						  </listitem> 
						  <listitem> 
								<para>Rename</para> 
						  </listitem> 
						  <listitem> 
								<para>Aggregate</para> 
						  </listitem> 
						  <listitem> 
								<para>Quota</para> 
						  </listitem> 
						  <listitem> 
								<para>Explode</para> 
						  </listitem> 
						  <listitem> 
								<para>Adorn</para> 
						  </listitem> 
						  <listitem> 
								<para>Redefine</para> 
						  </listitem> 
						  <listitem> 
								<para>Union</para> 
						  </listitem> 
						  <listitem> 
								<para>Intersect</para> 
						  </listitem> 
						  <listitem> 
								<para>Minus</para> 
						  </listitem> 
						  <listitem> 
								<para>Times</para> 
						  </listitem> 
						  <listitem> 
								<para>Join</para> 
						  </listitem> 
						  <listitem> 
								<para>Outer Join</para> 
						  </listitem> 
					 </itemizedlist> 
				</listitem> 
				<listitem> 
					 <para>Imperative Language</para> 
					 <itemizedlist> 
						  <listitem> 
								<para>Variables</para> 
						  </listitem> 
						  <listitem> 
								<para>Blocks and Scoping</para> 
						  </listitem> 
						  <listitem> 
								<para>Flow Control</para> 
						  </listitem> 
						  <listitem> 
								<para>Exception Handling</para> 
						  </listitem> 
					 </itemizedlist> 
				</listitem> 
				<listitem> 
					 <para>Programming Topics</para> 
					 <itemizedlist> 
						  <listitem> 
								<para>Using Strings</para> 
						  </listitem> 
						  <listitem> 
								<para>Using Date and Time Values</para> 
						  </listitem> 
						  <listitem> 
								<para>Using Rows</para> 
						  </listitem> 
						  <listitem> 
								<para>Using Lists</para> 
						  </listitem> 
						  <listitem> 
								<para>Using Cursors</para> 
						  </listitem> 
						  <listitem> 
								<para>Using Generators</para> 
						  </listitem> 
						  <listitem> 
								<para>Using Devices</para> 
						  </listitem> 
						  <listitem> 
								<para>Using Event Handlers</para> 
						  </listitem> 
						  <listitem> 
								<para>Dynamic Execution</para> 
						  </listitem> 
					 </itemizedlist> 
				</listitem> 
				<listitem> 
					 <para>Comparison With SQL</para> 
					 <itemizedlist> 
						  <listitem> 
								<para>Introduction</para> 
						  </listitem> 
						  <listitem> 
								<para>Common SQL</para> 
						  </listitem> 
						  <listitem> 
								<para>Vendor Dialects</para> 
						  </listitem> 
						  <listitem> 
								<para>Mapping an SQL Query Into D4</para> 
						  </listitem> 
						  <listitem> 
								<para>Data Management Differences</para> 
						  </listitem> 
					 </itemizedlist> 
				</listitem> 
		  </itemizedlist></para> 
	 <sect1 id="D4LGIntroduction"> 
		  <title><indexterm><primary>Introduction</primary></indexterm><indexterm><primary>D4
						  Language
						  Guide</primary><secondary>Introduction</secondary></indexterm>Introduction</title>
		  
		  <para>D4 provides a complete relational algebra for manipulating data,
				as well as a rich type system for describing even the most complex data. D4 is
				also computationally complete, and supports a full complement of flow control
				constructs, including exception handling, to provide a complete development
				language with data manipulation capabilities. Using D4, the impedance mismatch
				that traditionally exists between the database access language and the host
				programming language is eliminated, enabling a single data access and
				development paradigm.</para> 
		  <sect2 id="D4LGPurposeoftheD4Language"> 
				<title><indexterm><primary>Purpose of the D4
								Language</primary></indexterm><indexterm><primary>Introduction</primary><secondary>Purpose
								of the D4 Language</secondary></indexterm>Purpose of the D4 Language</title> 
				<para>The DAE uses a simple, yet powerful data access and
					 manipulation language called D4. All manipulation of the business model and its
					 data are done using this language. There are three broad categories of
					 statements in D4: Structural, Manipulative, and Imperative.</para> 
				<para> 
					 <itemizedlist mark="bullet"> 
						  <listitem> 
								<para><emphasis role="strong">Structural
									 statements</emphasis> (also called Data Definition Language (DDL)) manipulate
									 the definition of the data model. These are used to describe the nature of the
									 data to be stored.</para> 
						  </listitem> 
						  <listitem> 
								<para> <emphasis role="strong">Manipulative
									 statements</emphasis> (also called Data Manipulation Language (DML)) manipulate
									 the actual data in the database. These are used to insert, update and delete
									 data in the database, as well as retrieve it for presentation and
									 analysis.</para> 
						  </listitem> 
						  <listitem> 
								<para> <emphasis role="strong">Imperative
									 statements</emphasis> provide the framework for execution in D4. These
									 statements include variable declaration and assignment, flow control, and
									 exception handling.</para> 
						  </listitem> 
					 </itemizedlist> </para> 
				<para>D4 is a relationally complete language based on the
					 relational algebra. The syntax of the language is designed to allow the
					 developer to express queries naturally and easily.</para> 
		  </sect2> 
		  <sect2 id="D4LGSyntacticConventions"> 
				<title><indexterm><primary>Syntactic
								Conventions</primary></indexterm><indexterm><primary>Introduction</primary><secondary>Syntactic
								Conventions</secondary></indexterm>Syntactic Conventions</title> 
				<para>This language guide uses a variation of Extended Backus-Naur
					 Form (EBNF) to describe the syntax of D4. The variations facilitate the
					 expression of list structures which are common in the language. EBNF is made up
					 of three types of elements: terminals, non-terminals, and symbols. These
					 elements are used to create <emphasis>production rules</emphasis>. The set of
					 production rules describing the language is called the
					 <emphasis>grammar</emphasis>. Each non-terminal in the grammar must have an
					 associated production rule.</para> 
				<para>Non-terminals in EBNF are delimited by angle brackets
					 (<symbol>&lt;</symbol> and <symbol>&gt;</symbol>). The identifier inside the
					 angle brackets is the name of the non-terminal.</para> 
				<para>Symbols are used to indicate how terminals and non-terminals
					 are grouped together. The following symbols are used in EBNF: 
					 <itemizedlist> 
						  <listitem> 
								<para>Pipe (<symbol>|</symbol>)</para> 
								<para>The pipe is used to indicate an exclusive or. For
									 example the sequence <symbol>a | b</symbol> means that the result could be
									 <symbol>a</symbol> or <symbol>b</symbol>.</para> 
						  </listitem> 
						  <listitem> 
								<para>Parentheses (<symbol>(</symbol> and
									 <symbol>)</symbol>)</para> 
								<para>Parentheses are used to force a grouping within
									 the sequence. For example the sequence <symbol>a (b | c)</symbol> produces the
									 strings <symbol>ab</symbol> and <symbol>ac</symbol>, while the sequence
									 <symbol>(a b) | c</symbol> produces the strings <symbol>ab</symbol> and
									 <symbol>c</symbol>.</para> 
						  </listitem> 
						  <listitem> 
								<para>Brackets (<symbol>[</symbol> and
									 <symbol>]</symbol>)</para> 
								<para>Brackets are used to indicate that a given
									 sequence is optional. For example <symbol>a [ b ]</symbol> means that the
									 result could be <symbol>a</symbol> or <symbol>ab</symbol>.</para> 
						  </listitem> 
						  <listitem> 
								<para>Braces (<symbol>{</symbol> and
									 <symbol>}</symbol>)</para> 
								<para>Braces are used to indicate that a given sequence
									 may appear as many times as desired, including none. For example <symbol>a { b
									 }</symbol> means that the result could be <symbol>a</symbol>, or
									 <symbol>ab</symbol>, or <symbol>abb</symbol>, etc.,.</para> 
						  </listitem> 
						  <listitem> 
								<para>Double Quotes (<symbol>"</symbol>)</para> 
								<para>Double quotes are used to indicate that a
									 character that would normally be a symbol should be treated as a terminal. For
									 example <symbol>a "{" b "}"</symbol> means that the result should be <symbol>a
									 { b }</symbol>.</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>Every other character in EBNF is a terminal. Terminals should
					 appear in the result exactly as written in the production rules.</para> 
				<para>Production rules consist of a non-terminal followed by the
					 symbol <symbol>::=</symbol> and then a sequence of characters consisting of
					 terminals, non-terminals, and symbols. Non-terminals appearing in the body of a
					 production rule may be replaced with the body of the production rule
					 corresponding to the name of the non-terminal. This process is repeated until
					 there are no non-terminals in the string, and a valid sentence of the language
					 is formed.</para> 
				<para>For example, consider the following simple grammar: 
					 <programlisting>&lt;identifier&gt; ::=
	( _ | &lt;letter&gt; ) { _ | &lt;digit&gt; | &lt;letter&gt; }</programlisting> </para> 
				<para>The non-terminals <emphasis>letter</emphasis> and
					 <emphasis>digit</emphasis> have the obvious interpretation. This production
					 rule indicates that an <emphasis>identifier</emphasis> is defined as an
					 underscore or a letter, followed by any number of characters that can be an
					 underscore, a digit, or a letter. The following strings are valid words in the
					 language described by this grammar: 
					 <programlisting>_Identifier
_2222222
My_Identifier
Foo</programlisting>While the following strings are not words in the language
					 described by this grammar: 
					 <programlisting>12345
Ident#12</programlisting></para> 
				<para>In addition to basic EBNF, the notation used in the guide has
					 the following extensions: 
					 <itemizedlist> 
						  <listitem> 
								<para>Lists</para> 
								<para>The word <emphasis>list</emphasis> appearing at
									 the end of the name of a non-terminal indicates the existence of an implicit
									 production rule given by: 
									 <programlisting>&lt;XYZ list&gt; ::= { &lt;XYZ&gt; }</programlisting></para> 
						  </listitem> 
						  <listitem> 
								<para>Comma separated lists</para> 
								<para>The word <emphasis>commalist</emphasis> appearing
									 at the end of the name of a non-terminal indicates the existence of an implicit
									 production rule given by: 
									 <programlisting>&lt;XYZ commalist&gt; ::= [ &lt;XYZ&gt; {, &lt;XYZ&gt; } ]</programlisting></para> 
						  </listitem> 
						  <listitem> 
								<para>Non-empty lists</para> 
								<para>The word <emphasis>ne</emphasis> appearing at the
									 beginning of the name of a non-terminal with the word <emphasis>list</emphasis>
									 or <emphasis>commalist</emphasis> appearing at the end of the non-terminal
									 indicates the existence of an implicit production rule given by: 
									 <programlisting>&lt;ne XYZ list&gt; ::= &lt;XYZ&gt; { &lt;XYZ&gt; }
&lt;ne XYZ commalist&gt; ::= &lt;XYZ&gt; {, &lt;XYZ&gt; }</programlisting></para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>These extensions are the same as those used in reference
					 [3].</para> 
		  </sect2> 
	 </sect1> 
	 <sect1 id="D4LGScriptsandExecution"> 
		  <title><indexterm><primary>Scripts and
						  Execution</primary></indexterm><indexterm><primary>D4 Language
						  Guide</primary><secondary>Scripts and Execution</secondary></indexterm>Scripts
				and Execution</title> 
		  <para> Formally, a D4 script is any string of characters that can be
				formed using the production rules of the D4 grammar. Informally, it is a set of
				instructions that tell the DAE to perform a particular task or set of tasks. A
				script can be as simple as a single operator invocation that does not return a
				result, or it can be an entire sequence of complicated instructions. </para> 
		  <para>Each script is broken down by the compiler into a set of batches.
				Each top-level statement in the script is considered a separate batch, and is
				compiled and executed separately. Each batch is either a statement, i.e. it has
				no return value, or an expression that returns a value. For more information on
				how the DAE processes batches, see the section on Plans in the DAE as a DBMS
				chapter.</para> 
		  <para>The syntax for a D4 script is: 
				<programlisting>&lt;script&gt; ::=
	&lt;terminated statement list&gt;

&lt;terminated statement&gt; ::=
	[&lt;statement&gt;];</programlisting></para> 
		  <para>See the Statements section for a detailed description of the
				<emphasis>statement</emphasis> production rule.</para> 
	 </sect1> 
	 <sect1 id="D4LGLexicalElements"> 
		  <title><indexterm><primary>Lexical
						  Elements</primary></indexterm><indexterm><primary>D4 Language
						  Guide</primary><secondary>Lexical Elements</secondary></indexterm>Lexical
				Elements</title> 
		  <para>The lexical elements of the D4 language allow special symbols (or
				tokens) in an input string to be recognized. These tokens help the parser
				determine the syntax of a given statement. A complete BNF reference for the D4
				lexical analyzer is found in 
				<citetitle>Part III</citetitle> of this manual.</para> 
		  <sect2 id="D4LGWhitespace"> 
				<title><indexterm><primary>Whitespace</primary></indexterm><indexterm><primary>Lexical
								Elements</primary><secondary>Whitespace</secondary></indexterm>Whitespace</title>
				
				<para>The D4 language, like most computer languages, reserves
					 certain characters as "whitespace". This means that the characters are only
					 used to delimit tokens. The following D4 statements are syntactically
					 equivalent:</para> 
				<para> 
					 <programlisting>X := 5 * 3; 

X:=	5*		3		; 

X := 
5 
* 
3;

X:=5*3;		 </programlisting> </para> 
				<para>The following Unicode character values are considered
					 whitespace in D4: 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 0x0085, 0x2028, and
					 0x2029.</para> 
		  </sect2> 
		  <sect2 id="D4LGComments"> 
				<title><indexterm><primary>Comments</primary></indexterm><indexterm><primary>Lexical
								Elements</primary><secondary>Comments</secondary></indexterm>Comments</title> 
				<para>Comments are sections of text within D4 code that are ignored
					 by the compiler. Block comments allow for multi-line annotations, whereas line
					 comments are terminated by the line break. Block comments in D4 can be nested,
					 which allows for sections of code to be easily and temporarily "commented out".
					 The following are some examples of D4 comments:</para> 
				<para> 
					 <programlisting>/* This is a multi
   line... /* nested */ ...comment */

X := 5; // Assigns 5 to variable X</programlisting> </para> 
		  </sect2> 
		  <sect2 id="D4LGKeywords"> 
				<title><indexterm><primary>Keywords</primary></indexterm><indexterm><primary>Lexical
								Elements</primary><secondary>Keywords</secondary></indexterm>Keywords</title> 
				<para>A <emphasis>keyword</emphasis> is a special symbol used by
					 the parser to delimit syntactic structure. For example, the keyword
					 <symbol>begin</symbol> is used to delimit the beginning of a statement block.
					 To avoid ambiguity while parsing, some keywords are also <emphasis>reserved
					 words</emphasis>. Reserved words are keywords that cannot be used as
					 identifiers because the parser would not be able to distinguish between the
					 identifier and the keyword.</para> 
				<para>The following is a list of all keywords in D4. Keywords with
					 an asterisk (*) denote reserved words. 
					 <simplelist type="vert" columns="4"> 
						  <member>*add</member> 
						  <member>*adorn</member> 
						  <member>after</member> 
						  <member>aggregate</member> 
						  <member>aggregation</member> 
						  <member>all</member> 
						  <member>*alter</member> 
						  <member>*and</member> 
						  <member>*as</member> 
						  <member>asc</member> 
						  <member>*attach</member> 
						  <member>attributes</member> 
						  <member>bag</member> 
						  <member>before</member> 
						  <member>*begin</member> 
						  <member>*between</member> 
						  <member>*break</member> 
						  <member>browse</member> 
						  <member>by</member> 
						  <member>capabilities</member> 
						  <member>cascade</member> 
						  <member>*case</member> 
						  <member>change</member> 
						  <member>class</member> 
						  <member>clear</member> 
						  <member>column</member> 
						  <member>*comment</member> 
						  <member>*const</member> 
						  <member>*constraint</member> 
						  <member>*continue</member> 
						  <member>*create</member> 
						  <member>*cursor</member> 
						  <member>default</member> 
						  <member>*delete</member> 
						  <member>desc</member> 
						  <member>*detach</member> 
						  <member>device</member> 
						  <member>distinct</member> 
						  <member>*div</member> 
						  <member>*divide</member> 
						  <member>*do</member> 
						  <member>domain</member> 
						  <member>*downto</member> 
						  <member>*drop</member> 
						  <member>*else</member> 
						  <member>*end</member> 
						  <member>*entry</member> 
						  <member>*except</member> 
						  <member>*exists</member> 
						  <member>*exit</member> 
						  <member>*explode</member> 
						  <member>false</member> 
						  <member>finalization</member> 
						  <member>*finally</member> 
						  <member>*for</member> 
						  <member>from</member> 
						  <member>generic</member> 
						  <member>*group</member> 
						  <member>*if</member> 
						  <member>*in</member> 
						  <member>*include</member> 
						  <member>initialization</member> 
						  <member>*insert</member> 
						  <member>*intersect</member> 
						  <member>into</member> 
						  <member>*is</member> 
						  <member>isolation</member> 
						  <member>*join</member> 
						  <member>*key</member> 
						  <member>*left</member> 
						  <member>level</member> 
						  <member>*like</member> 
						  <member>*list</member> 
						  <member>*lookup</member> 
						  <member>master</member> 
						  <member>*matches</member> 
						  <member>*minus</member> 
						  <member>*mod</member> 
						  <member>mode</member> 
						  <member>new</member> 
						  <member>*not</member> 
						  <member>old</member> 
						  <member>*on</member> 
						  <member>operator</member> 
						  <member>*or</member> 
						  <member>*order</member> 
						  <member>*over</member> 
						  <member>*parent</member> 
						  <member>*presentation</member> 
						  <member>*raise</member> 
						  <member>read</member> 
						  <member>reconciliation</member> 
						  <member>*redefine</member> 
						  <member>*reference</member> 
						  <member>references</member> 
						  <member>*remove</member> 
						  <member>*rename</member> 
						  <member>*repeat</member> 
						  <member>representation</member> 
						  <member>require</member> 
						  <member>result</member> 
						  <member>*return</member> 
						  <member>*right</member> 
						  <member>*row</member> 
						  <member>rowexists</member> 
						  <member>*select</member> 
						  <member>sequence</member> 
						  <member>set</member> 
						  <member>sort</member> 
						  <member>special</member> 
						  <member>*step</member> 
						  <member>*table</member> 
						  <member>*tags</member> 
						  <member>then</member> 
						  <member>*times</member> 
						  <member>*to</member> 
						  <member>true</member> 
						  <member>*try</member> 
						  <member>type</member> 
						  <member>*typeof</member> 
						  <member>*union</member> 
						  <member>*until</member> 
						  <member>*update</member> 
						  <member>validate</member> 
						  <member>*value</member> 
						  <member>*var</member> 
						  <member>view</member> 
						  <member>when</member> 
						  <member>*where</member> 
						  <member>*while</member> 
						  <member>*with</member> 
						  <member>write</member> 
						  <member>*xor</member> 
					 </simplelist> </para> 
		  </sect2> 
		  <sect2 id="D4LGSymbols"> 
				<title><indexterm><primary>Symbols</primary></indexterm><indexterm><primary>Lexical
								Elements</primary><secondary>Symbols</secondary></indexterm>Symbols</title> 
				<para>The D4 language also includes several special symbols that
					 are used by the parser to delimit syntatic structure. These include
					 parentheses, brackets, operator symbols, and other characters that have
					 specific meaning within statements of D4. None of these symbols may be used in
					 identifier names.</para> 
				<para>The following are parser-recognized symbols in D4. 
					 <simplelist type="vert" columns="4"> 
						  <member>-</member> 
						  <member>$</member> 
						  <member>&amp;</member> 
						  <member>(</member> 
						  <member>)</member> 
						  <member>*</member> 
						  <member>**</member> 
						  <member>,</member> 
						  <member>.</member> 
						  <member>/</member> 
						  <member>:</member> 
						  <member>:=</member> 
						  <member>;</member> 
						  <member>?=</member> 
						  <member>[</member> 
						  <member>]</member> 
						  <member>^</member> 
						  <member>{</member> 
						  <member>|</member> 
						  <member>}</member> 
						  <member>~</member> 
						  <member>+</member> 
						  <member>&lt;</member> 
						  <member>&lt;&lt;</member> 
						  <member>&lt;=</member> 
						  <member>&lt;&gt;</member> 
						  <member>=</member> 
						  <member>&gt;</member> 
						  <member>&gt;=</member> 
						  <member>&gt;&gt;</member> 
					 </simplelist> </para> 
		  </sect2> 
		  <sect2 id="D4LGParserLiterals"> 
				<title><indexterm><primary>Parser
								Literals</primary></indexterm><indexterm><primary>Lexical
								Elements</primary><secondary>Parser Literals</secondary></indexterm>Parser
					 Literals</title> 
				<para>A <emphasis>parser literal</emphasis> is a value which is
					 directly understood by the lexer as a token. For example the symbol
					 <symbol>5</symbol> is a parser literal which represents the
					 <symbol>System.Integer</symbol> value 5. The following types of parser literals
					 are available in D4: 
					 <itemizedlist> 
						  <listitem> 
								<para>Boolean</para> 
						  </listitem> 
						  <listitem> 
								<para>Integer</para> 
						  </listitem> 
						  <listitem> 
								<para>Decimal</para> 
						  </listitem> 
						  <listitem> 
								<para>Money</para> 
						  </listitem> 
						  <listitem> 
								<para>String</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>Here are some examples of parser literals within D4: 
					 <programlisting>"Welcome to the ""community"" website."
'"Hello," she said.'
135
332.12d
31415926535897932e-16
$40.00
true</programlisting> </para> 
				<sect3 id="D4LGBooleanParserLiterals"> 
					 <title><indexterm><primary>Boolean Parser
									 Literals</primary></indexterm><indexterm><primary>Parser
									 Literals</primary><secondary>Boolean Parser
									 Literals</secondary></indexterm>Boolean Parser Literals</title> 
					 <para>The boolean parser literal allows values of type
						  <symbol>System.Boolean</symbol> to be represented directly within D4.</para> 
					 <para>The boolean parser literal in D4 has the following
						  syntax: 
						  <programlisting>&lt;boolean parser literal&gt; ::=
	true | false</programlisting></para> 
				</sect3> 
				<sect3 id="D4LGIntegerParserLiterals"> 
					 <title><indexterm><primary>Integer Parser
									 Literals</primary></indexterm><indexterm><primary>Parser
									 Literals</primary><secondary>Integer Parser
									 Literals</secondary></indexterm>Integer Parser Literals</title> 
					 <para>The integer parser literal allows values of type
						  <symbol>System.Integer</symbol> to be represented directly within D4. Integer
						  values can be specified as a base 10 number using decimal digits, or as a base
						  16 number using hex digits. Base 16 representations must be prefixed with the
						  symbol <symbol>0x</symbol>.</para> 
					 <para>The integer parser literal in D4 has the following
						  syntax: 
						  <programlisting>&lt;integer parser literal&gt; ::=
	&lt;digit&gt;{&lt;digit&gt;} | 0x&lt;hexdigit&gt;{&lt;hexdigit&gt;}</programlisting></para> 
				</sect3> 
				<sect3 id="D4LGDecimalParserLiterals"> 
					 <title><indexterm><primary>Decimal Parser
									 Literals</primary></indexterm><indexterm><primary>Parser
									 Literals</primary><secondary>Decimal Parser
									 Literals</secondary></indexterm>Decimal Parser Literals</title> 
					 <para>The decimal parser literal allows values of type
						  <symbol>System.Decimal</symbol> to be represented directly within D4. Note that
						  a sequence of digits alone will be interpreted as a value of type
						  <symbol>System.Intetger</symbol> so the trailing <symbol>d</symbol> must be
						  used.</para> 
					 <para>The decimal parser literal in D4 has the following
						  syntax: 
						  <programlisting>&lt;decimal parser literal&gt; ::=
	&lt;digit&gt;{&lt;digit&gt;}[.{&lt;digit&gt;}][(e|E)[+|-]{&lt;digit&gt;}][d]</programlisting></para> 
				</sect3> 
				<sect3 id="D4LGMoneyParserLiterals"> 
					 <title><indexterm><primary>Money Parser
									 Literals</primary></indexterm><indexterm><primary>Parser
									 Literals</primary><secondary>Money Parser Literals</secondary></indexterm>Money
						  Parser Literals</title> 
					 <para>The money parser literal allows values of type
						  <symbol>System.Money</symbol> to be represented directly within D4.</para> 
					 <para>The money parser literal in D4 has the following syntax: 
						  <programlisting>&lt;money parser literal&gt; ::=
	$&lt;digit&gt;{&lt;digit&gt;}[.{&lt;digit&gt;}]</programlisting></para> 
				</sect3> 
				<sect3 id="D4LGStringParserLiterals"> 
					 <title><indexterm><primary>String Parser
									 Literals</primary></indexterm><indexterm><primary>Parser
									 Literals</primary><secondary>String Parser
									 Literals</secondary></indexterm>String Parser Literals</title> 
					 <para>The string parser literal allows values of type
						  <symbol>System.String</symbol> to be represented directly within D4. Note that
						  either quote character can be used to delimit a string. Within the string, the
						  delimiting quote character can be represented by double quoting.</para> 
					 <para>The string parser literal in D4 has the following syntax:
						  
						  <programlisting>&lt;string parser literal&gt; ::=
	""{&lt;character&gt;}"" | '{&lt;character&gt;}'</programlisting></para> 
				</sect3> 
		  </sect2> 
		  <sect2 id="D4LGIdentifiers"> 
				<title><indexterm><primary>Identifiers</primary></indexterm><indexterm><primary>Lexical
								Elements</primary><secondary>Identifiers</secondary></indexterm>Identifiers</title>
				
				<para>Identifiers are user-defined names for DAE catalog objects
					 such as variables and types.</para> 
				<para>D4 identifiers have the following syntax: 
					 <programlisting>&lt;identifier&gt; ::=
	_ | &lt;letter&gt; {_ | &lt;letter&gt; | &lt;digit&gt;}</programlisting></para> 
				<para>Here is an example of a valid D4 identifier: 
					 <programlisting>Customers</programlisting> </para> 
				<sect3 id="D4LGQualifiedIdentifiers"> 
					 <title><indexterm><primary>Qualified
									 Identifiers</primary></indexterm><indexterm><primary>Identifiers</primary><secondary>Qualified
									 Identifiers</secondary></indexterm>Qualified Identifiers</title> 
					 <para>The DAE uses the concept of namespaces to allow
						  identifiers to be named more completely, yet accessed more concisely. An
						  identifier that utilizes namespaces is called a qualified identifier because it
						  is prefixed by one or more identifiers.</para> 
					 <para>Qualified identifiers have the following syntax: 
						  <programlisting>&lt;qualified identifier&gt; ::=
	[.]{&lt;identifier&gt;.}&lt;identifier&gt;</programlisting></para> 
					 <para>Name resolution with qualified identifiers is based on
						  the notion of <emphasis>name equivalence</emphasis>. A given name is equivalent
						  to another name if and only if it is equal, case-sensitively, to some
						  unqualified version of the name. Thus: 
						  <itemizedlist> 
								<listitem> 
									 <para><symbol>A</symbol> is equivalent to
										  <symbol>A</symbol></para> 
								</listitem> 
								<listitem> 
									 <para><symbol>A</symbol> is equivalent to
										  <symbol>A.A</symbol> and <symbol>B.A</symbol>, but not
										  <symbol>A.B</symbol></para> 
								</listitem> 
								<listitem> 
									 <para><symbol>A.A</symbol> is equivalent to
										  <symbol>A.A</symbol>, but not <symbol>B.A</symbol></para> 
								</listitem> 
						  </itemizedlist></para> 
					 <para>When attempting to resolve a name reference against a
						  list of names such as the catalog, if the reference is equivalent to more than
						  one name in the list, the reference is considered ambiguous.</para> 
					 <para>The following is an example of a qualified identifier: 
						  <programlisting>MyCompany.MyProduct.Customers</programlisting> </para> 
				</sect3> 
				<sect3 id="D4LGDisambiguatingIdentifiers"> 
					 <title><indexterm><primary>Disambiguating
									 Identifiers</primary></indexterm><indexterm><primary>Identifiers</primary><secondary>Disambiguating
									 Identifiers</secondary></indexterm>Disambiguating Identifiers</title> 
					 <para>Unless ambiguous, schema objects can be accessed using
						  their unqualified names. Names must be qualified only to the point where they
						  are no longer ambiguous, but may be qualified more completely if
						  desired.</para> 
					 <para>The following example illustrates the use of namespaces
						  in D4: 
						  <programlisting>var MyCompany.MyProduct.MyVariable: Integer;
var MyCompany.OtherProduct.MyVariable: Integer;
MyVariable := 5;  // Error, MyVariable must be disambiguated
OtherProduct.MyVariable := 5; // Valid
MyCompany.MyProduct.MyVariable := 6;  // Also valid </programlisting> </para> 
					 <para>The root of the namespace can be accessed using a dot
						  qualifier with no preceding identifier as follows: 
						  <programlisting>var .I : Integer;
.I := 5; </programlisting> </para> 
					 <para>It is an error to create an ambiguous identifier as shown
						  by the following example: 
						  <programlisting>var I: Integer;
var A.I: Integer;  // This is an error </programlisting> </para> 
				</sect3> 
				<sect3 id="D4LGDefaultNamespaces"> 
					 <title><indexterm><primary>Default
									 Namespaces</primary></indexterm><indexterm><primary>Identifiers</primary><secondary>Default
									 Namespaces</secondary></indexterm>Default Namespaces</title> 
					 <para>A session within the DAE has a default namespace that is
						  used when creating new catalog objects and resolving object names. Unless
						  explicitly qualified, identifiers are assumed to be qualified by the default
						  namespace. The following example assumes that the default namespace is set to
						  "A":</para> 
					 <para> 
						  <programlisting>SetDefaultNameSpace(Name("A"));

var I: Integer; // Actually "A.I" 
var .B.I : Integer; // Leading dot specifies root
I := 5; //	Assigns A.I 
.B.I := 6; </programlisting> </para> 
				</sect3> 
		  </sect2> 
		  <sect2 id="D4LGCase"> 
				<title><indexterm><primary>Case</primary></indexterm><indexterm><primary>Lexical
								Elements</primary><secondary>Case</secondary></indexterm>Case</title> 
				<para>D4 is a case-sensitive language, meaning that the symbols and
					 identifiers read by the compiler will be compared case-sensitively. In other
					 words, the symbol <symbol>A</symbol> is different than the symbol
					 <symbol>a</symbol>. The following code sample illustrates this behavior.</para>
				
				<para> 
					 <programlisting>begin
	var I : Integer;
	I := Length("Relational"); // valid reference
	i := Length("Relational"); // unknown identifier
end; </programlisting> </para> 
				<para>Because D4 is case-sensitive, Alphora recommends the use of
					 Pascal casing for all identifiers. In pascal casing, the first letter of each
					 word in the identifier is capitalized, for example
					 <symbol>PascalCasing</symbol>. This allows identifiers to have a completely
					 open identifier space because all keywords are all lower case. For example,
					 <symbol>value</symbol> is not a valid identifier because it conflicts with the
					 reserved word <symbol>value</symbol>, but <symbol>Value</symbol> is a valid
					 identifier.</para> 
				<para>Note: most SQL-based systems are case-insensitive, so be
					 careful not to rely on casing for identifier resolution, as it could lead to
					 problems when translating into the various dialects of SQL.</para> 
		  </sect2> 
	 </sect1> 
	 <sect1 id="D4LGLanguageElements"> 
		  <title><indexterm><primary>Language
						  Elements</primary></indexterm><indexterm><primary>D4 Language
						  Guide</primary><secondary>Language Elements</secondary></indexterm>Language
				Elements</title> 
		  <para>The D4 language is built from six fundamental elements. These
				elements provide the building blocks for all the functionality of the D4
				language. 
				<itemizedlist> 
					 <listitem> 
						  <para>Types</para> 
					 </listitem> 
					 <listitem> 
						  <para>Values</para> 
					 </listitem> 
					 <listitem> 
						  <para>Variables</para> 
					 </listitem> 
					 <listitem> 
						  <para>Operators</para> 
					 </listitem> 
					 <listitem> 
						  <para>Expressions</para> 
					 </listitem> 
					 <listitem> 
						  <para>Statements</para> 
					 </listitem> 
				</itemizedlist></para> 
		  <para>The following sections discuss each element in detail.</para> 
		  <sect2 id="D4LGTypes"> 
				<title><indexterm><primary>Types</primary></indexterm><indexterm><primary>Language
								Elements</primary><secondary>Types</secondary></indexterm>Types</title> 
				<para>Data types provide a mechanism for describing classes of
					 values and allow the compiler to guarantee the correctness of operations
					 against those values. D4 is a strongly typed language, meaning that every
					 variable, value, and argument has a type, and only values of the appropriate
					 type may be used in a given context. For example, only values of type
					 <symbol>System.Integer</symbol> can be assigned to a variable of declared type
					 <symbol>System.Integer</symbol>.</para> 
				<para> A type is a named set of values. Any given value has a type
					 associated with it, for example, <symbol>1</symbol> is a value of type
					 <symbol>System.Integer</symbol>, and <symbol>table { row { 5 ID } }</symbol> is
					 a table value with type <symbol>table { ID : System.Integer }</symbol>. There
					 are several different categories of types, each of which describes a specific
					 kind of value. D4 supports the following categories of types: <symbol>Scalar,
					 Row, Table, List, and Cursor</symbol>.</para> 
				<para>Types are specified in D4 using <emphasis>type
					 specifiers</emphasis>. Type specifiers have the following syntax: 
					 <programlisting>&lt;type specifier&gt; ::=
	generic |
	&lt;scalar type specifier&gt; |
	&lt;row type specifier&gt; |
	&lt;table type specifier&gt; |
	&lt;list type specifier&gt; |
	&lt;cursor type specifier&gt; |
	&lt;typeof type specifier&gt;

&lt;typeof type specifier&gt; ::=
	typeof"("&lt;expression&gt;")"</programlisting></para> 
				<para>Generic types allow operators to take as arguments values of
					 some category of type. For example, an operator may be able to operate on any
					 scalar type. The generic scalar type <symbol>System.Scalar</symbol> allows such
					 an operator to be defined. This type is specified using the keyword
					 <symbol>domain</symbol> as the type specifier. For information on how to
					 specify the generic type for each category of type, see the section for that
					 type category. The keyword <symbol>generic</symbol> can be used to specify that
					 an operator may take as argument a value of any type.</para> 
				<para>The <symbol>typeof</symbol> system operator can be used to
					 select the type of an arbitrary expression.</para> 
				<sect3 id="D4LGSystemDataTypes"> 
					 <title><indexterm><primary>System Data
									 Types</primary></indexterm><indexterm><primary>Types</primary><secondary>System
									 Data Types</secondary></indexterm>System Data Types</title> 
					 <para>The following scalar data types are made available by the
						  DAE: 
						  <itemizedlist> 
								<listitem> 
									 <para><symbol>System.Alpha</symbol></para> 
									 <para><symbol>System.Alpha</symbol> is the set of
										  all possible scalar values. The type constraint for alpha is simply
										  <symbol>true</symbol>. All scalar types are defined as some subset of the
										  values in the alpha domain.</para> 
								</listitem> 
								<listitem> 
									 <para><symbol>System.Omega</symbol></para> 
									 <para><symbol>System.Omega</symbol> is the empty
										  set of scalar values. It is not possible to have a value of type
										  <symbol>System.Omega</symbol>. The type constraint for omega is simply
										  <symbol>false</symbol>. This type is used in computing the runtime type of row
										  and table types.</para> 
								</listitem> 
								<listitem> 
									 <para><symbol>System.Decimal</symbol></para> 
									 <para><symbol>System.Decimal</symbol> is a subtype
										  of <symbol>System.Alpha</symbol> and is the set of all possible numbers. Values
										  of this domain are represented physically by a 96-bit signed scaled integer, so
										  in practice, the available values are negative
										  79,228,162,514,264,337,593,543,950,335 (-2<superscript>96</superscript>-1)
										  through positive 79,228,162,514,264,337,593,543,950,335
										  (2<superscript>96</superscript>-1).</para> 
								</listitem> 
								<listitem> 
									 <para><symbol>System.Long</symbol></para> 
									 <para><symbol>System.Long</symbol> is a subtype of
										  <symbol>System.Decimal</symbol> and is the set of all integer values in the
										  range negative 9,223,372,036,854,775,808 (-2<superscript>63</superscript>)
										  through positive 9,223,372,036,854,775,807 (2<superscript>64</superscript>-1).
										  The physical representation of this type is a signed 64-bit integer.</para> 
								</listitem> 
								<listitem> 
									 <para><symbol>System.Integer</symbol></para> 
									 <para><symbol>System.Integer</symbol> is a subtype
										  of <symbol>System.Long</symbol> and is the set of all integer values in the
										  range negative 2,147,483,648 (-2<superscript>31</superscript>) through positive
										  2,147,483,647 (2<superscript>31</superscript>-1). The physical representation
										  of this type is a signed 32-bit integer.</para> 
								</listitem> 
								<listitem> 
									 <para><symbol>System.Short</symbol></para> 
									 <para><symbol>System.Short</symbol> is a subtype of
										  <symbol>System.Integer</symbol> and is the set of all integer values in the
										  range negative 32768 (-2<superscript>15</superscript>) through positive 32767
										  (2<superscript>15</superscript>-1). The physical representation of this type is
										  a signed 16-bit integer.</para> 
								</listitem> 
								<listitem> 
									 <para><symbol>System.Byte</symbol></para> 
									 <para><symbol>System.Byte</symbol> is a subtype of
										  <symbol>System.Short</symbol> and is the set of all integer values in the range
										  0 through positive 255 (2<superscript>8</superscript>-1). The physical
										  representation of this type is an unsigned 8-bit integer.</para> 
								</listitem> 
								<listitem> 
									 <para><symbol>System.Boolean</symbol></para> 
									 <para><symbol>System.Boolean</symbol> is a subtype
										  of <symbol>System.Alpha</symbol> and consists of the truth values
										  <symbol>true</symbol> and <symbol>false</symbol>.</para> 
								</listitem> 
								<listitem> 
									 <para><symbol>System.String</symbol></para> 
									 <para><symbol>System.String</symbol> is a subtype
										  of <symbol>System.Alpha</symbol> and is the set of all case-sensitive character
										  strings. The physical representation of this type is a Unicode string with a
										  maximum length of 2<superscript>31</superscript>-1. The comparison operators
										  for this domain are defined case-sensitively.</para> 
								</listitem> 
								<listitem> 
									 <para><symbol>System.IString</symbol></para> 
									 <para><symbol>System.IString</symbol> is a subtype
										  of <symbol>System.Alpha</symbol> and is the set of all case-insensitive
										  character strings. The physical representation of this type is a Unicode string
										  with a maximum length of 2<superscript>31</superscript>-1. The comparison
										  operators for this domain are defined case-insensitively.</para> 
								</listitem> 
								<listitem> 
									 <para><symbol>System.Guid</symbol></para> 
									 <para><symbol>System.Guid</symbol> is a subtype of
										  <symbol>System.Alpha</symbol> and is the set of all possible Globally Unique
										  Identifiers (GUIDs). The physical representation for this type is a 128-bit
										  unsigned integer. The operator <symbol>NewGuid()</symbol> generates a new
										  globally unique identifier.</para> 
								</listitem> 
								<listitem> 
									 <para><symbol>System.TimeSpan</symbol></para> 
									 <para><symbol>System.TimeSpan</symbol> is a subtype
										  of <symbol>System.Alpha</symbol> and is the set of all possible lengths of
										  time. The physical representation for this type is a 64-bit signed integer
										  representing the number of <emphasis>ticks</emphasis> in the time value. A tick
										  is equal to 100 nanoseconds, which means that the range of values for this
										  domain is from negative 10675199 days, 2 hours, 48 minutes, 5.4775808 seconds
										  through positive 10675199 days, 2 hours, 48 minutes, 5.4775807 seconds.</para> 
								</listitem> 
								<listitem> 
									 <para><symbol>System.DateTime</symbol> is a subtype
										  of <symbol>System.TimeSpan</symbol> and is the set of all possible dates, or
										  times from a fixed point. The physical representation for this type is a 64-bit
										  signed integer representing the number of ticks since 12:00 midnight, January
										  1, 1 C.E. (Common Era) in the Gregorian calendar. This means that the range of
										  values for this domain is from 12:00:00 midnight, January 1, 0001 C.E. to
										  11:59:59 P.M., December 31, 9999 C.E.</para> 
								</listitem> 
								<listitem> 
									 <para><symbol>System.Money</symbol></para> 
									 <para><symbol>System.Money</symbol> is a subtype of
										  <symbol>System.Alpha</symbol> and is the set of all monetary values in the
										  range negative $79,228,162,514,264,337,593,543,950,335
										  (-$2<superscript>96</superscript>-1) through positive
										  $79,228,162,514,264,337,593,543,950,335 ($2<superscript>96</superscript>-1).
										  The physical representation of this type is 96-bit signed scaled
										  integer.</para> 
								</listitem> 
								<listitem> 
									 <para><symbol>System.Image</symbol></para> 
									 <para><symbol>System.Image</symbol> is a subtype of
										  <symbol>System.Alpha</symbol> and is the set of all byte streams of data with
										  length less than or equal to 2,147,483,647
										  (2<superscript>31</superscript>-1).</para> 
								</listitem> 
								<listitem> 
									 <para><symbol>System.Error</symbol></para> 
									 <para><symbol>System.Error</symbol> is a subtype of
										  <symbol>System.Alpha</symbol> and is the set of all error values in the DAE.
										  Values of this type are used to implement the exception-handling mechanisms of
										  D4.</para> 
								</listitem> 
						  </itemizedlist> </para> 
				</sect3> 
				<sect3 id="D4LGTypeConversions"> 
					 <title><indexterm><primary>Type
									 Conversions</primary></indexterm><indexterm><primary>Types</primary><secondary>Type
									 Conversions</secondary></indexterm>Type Conversions</title> 
					 <para> The following table lists the availabity of conversion
						  operators. The presence of an E indicates the existence of an operator of the
						  form ToYYY(AValue : XXX) where XXX represents the name of the data type along
						  the x-axis, and YYY represents the name of the data type along the y-axis,
						  which can be used to perform the desired conversion. D4 does not support
						  implicit conversions.</para> 
					 <para> 
						  <informaltable> 
								<tgroup cols="13"><tbody> 
										  <row><entry>To \
													 From</entry><entry>Boolean</entry><entry>Byte</entry><entry>Short</entry><entry>Integer</entry><entry>Long</entry><entry>Decimal</entry><entry>String</entry><entry>IString</entry><entry>Guid</entry><entry>DateTime</entry><entry>TimeSpan</entry><entry>Money</entry>
												
										  </row> 
										  <row><entry>Boolean</entry><entry>N/A</entry><entry>E</entry><entry>E</entry><entry>E</entry><entry>E</entry><entry>-</entry><entry>E</entry><entry>E</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry>
												
										  </row> 
										  <row><entry>Byte</entry><entry>E</entry><entry>N/A</entry><entry>E</entry><entry>E</entry><entry>E</entry><entry>-</entry><entry>E</entry><entry>E</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry>
												
										  </row> 
										  <row><entry>Short</entry><entry>E</entry><entry>E</entry><entry>N/A</entry><entry>E</entry><entry>E</entry><entry>-</entry><entry>E</entry><entry>E</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry>
												
										  </row> 
										  <row><entry>Integer</entry><entry>E</entry><entry>E</entry><entry>E</entry><entry>N/A</entry><entry>E</entry><entry>E</entry><entry>E</entry><entry>E</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>E</entry>
												
										  </row> 
										  <row><entry>Long</entry><entry>E</entry><entry>E</entry><entry>E</entry><entry>E</entry><entry>N/A</entry><entry>E</entry><entry>E</entry><entry>E</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>E</entry>
												
										  </row> 
										  <row><entry>Decimal</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>E</entry><entry>E</entry><entry>N/A</entry><entry>E</entry><entry>E</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>E</entry>
												
										  </row> 
										  <row><entry>String</entry><entry>E</entry><entry>E</entry><entry>E</entry><entry>E</entry><entry>E</entry><entry>E</entry><entry>N/A</entry><entry>E</entry><entry>E</entry><entry>E</entry><entry>E</entry><entry>E</entry>
												
										  </row> 
										  <row><entry>IString</entry><entry>E</entry><entry>E</entry><entry>E</entry><entry>E</entry><entry>E</entry><entry>E</entry><entry>E</entry><entry>N/A</entry><entry>E</entry><entry>E</entry><entry>E</entry><entry>E</entry>
												
										  </row> 
										  <row><entry>Guid</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>E</entry><entry>E</entry><entry>N/A</entry><entry>-</entry><entry>-</entry><entry>-</entry>
												
										  </row> 
										  <row><entry>DateTime</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>E</entry><entry>E</entry><entry>-</entry><entry>N/A</entry><entry>E</entry><entry>-</entry>
												
										  </row> 
										  <row><entry>TimeSpan</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>E</entry><entry>E</entry><entry>-</entry><entry>E</entry><entry>N/A</entry><entry>-</entry>
												
										  </row> 
										  <row><entry>Money</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>E</entry><entry>E</entry><entry>E</entry><entry>E</entry><entry>E</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>N/A</entry>
												
										  </row></tbody> 
								</tgroup> 
						  </informaltable></para> 
				</sect3> 
				<sect3 id="D4LGScalarTypes"> 
					 <title><indexterm><primary>Scalar
									 Types</primary></indexterm><indexterm><primary>Types</primary><secondary>Scalar
									 Types</secondary></indexterm>Scalar Types</title> 
					 <para>Scalar types (also called <emphasis>domains</emphasis>)
						  provide a mechanism for defining and manipulating the basic units of data in
						  D4. Scalar types are types with no user-visible components. This is in contrast
						  to a table type, for example, which very definitely has user-visible
						  components, namely the columns of the table. In other words, scalar types are
						  <emphasis>atomic</emphasis> or <emphasis>encapsulated</emphasis>. Note that the
						  term <emphasis>encapsulated</emphasis> is really synonymous with
						  <emphasis>scalar</emphasis> and as such we do not make use of it.</para> 
					 <para>Scalar type specifiers have the following syntax: 
						  <programlisting>&lt;scalar type specifier&gt; ::=
	domain | &lt;domain name&gt;</programlisting></para> 
					 <para>The <symbol>domain</symbol> keyword as a type specifier
						  indicates the generic scalar type <symbol>System.Scalar</symbol>.</para> 
					 <bridgehead renderas="sect3">See Also</bridgehead> 
					 <para> 
						  <ulink url="D4LGDomains.html"> Domains</ulink></para> 
				</sect3> 
				<sect3 id="D4LGRowTypes"> 
					 <title><indexterm><primary>Row
									 Types</primary></indexterm><indexterm><primary>Types</primary><secondary>Row
									 Types</secondary></indexterm>Row Types</title> 
					 <para>Row types describe values that are sets of named values.
						  A row type has a <emphasis>heading</emphasis> which describes the columns of
						  the row. Each column has a unique name and an associated type.</para> 
					 <para>Row type specifiers have the following syntax: 
						  <programlisting>&lt;row type specifier&gt; ::=
	row["{"&lt;named type specifier commalist&gt;"}"]

&lt;named type specifier&gt; ::=
	&lt;qualified identifier&gt; : &lt;type specifier&gt;</programlisting></para> 
					 <para>The type specifier <symbol>row</symbol> indicates the
						  generic row type <symbol>System.Row</symbol>.</para> 
				</sect3> 
				<sect3 id="D4LGTableTypes"> 
					 <title><indexterm><primary>Table
									 Types</primary></indexterm><indexterm><primary>Types</primary><secondary>Table
									 Types</secondary></indexterm>Table Types</title> 
					 <para>Table types provide a mechanism for describing table
						  values, the basic unit of persistence in D4. A table type has a
						  <emphasis>heading</emphasis> which describes the columns of the table. Each
						  column has a unique name and an associated type.</para> 
					 <para>Table type specifiers have the following syntax: 
						  <programlisting>&lt;table type specifier&gt; ::=
	table["{"&lt;named type specifier commalist&gt;"}"]

&lt;named type specifier&gt; ::=
	&lt;qualified identifier&gt; : &lt;type specifier&gt;</programlisting></para> 
					 <para>The type specifier <symbol>table</symbol> indicates the
						  generic table type <symbol>System.Table</symbol>.</para> 
				</sect3> 
				<sect3 id="D4LGListTypes"> 
					 <title><indexterm><primary>List
									 Types</primary></indexterm><indexterm><primary>Types</primary><secondary>List
									 Types</secondary></indexterm>List Types</title> 
					 <para>List types provide a mechanism for describing arbitrary
						  length lists of values of the same type.</para> 
					 <para>List type specifiers have the following syntax: 
						  <programlisting>&lt;list type specifier&gt; ::=
	list["("&lt;type specifier&gt;")"]</programlisting></para> 
					 <para>The type specifier <symbol>list</symbol> indicates the
						  generic list type <symbol>System.List</symbol>.</para> 
				</sect3> 
				<sect3 id="D4LGCursorTypes"> 
					 <title><indexterm><primary>Cursor
									 Types</primary></indexterm><indexterm><primary>Types</primary><secondary>Cursor
									 Types</secondary></indexterm>Cursor Types</title> 
					 <para>Cursor types provide a mechanism for dealing with the
						  results of a table expression a row at a time. Cursor types deal with a
						  specific table type.</para> 
					 <para>Cursor type specifiers have the following syntax: 
						  <programlisting>&lt;cursor type specifier&gt; ::=
	cursor["("&lt;type specifier&gt;")"]</programlisting></para> 
					 <para>The type specifier <symbol>cursor</symbol> indicates the
						  generic cursor type <symbol>System.Cursor</symbol>.</para> 
				</sect3> 
		  </sect2> 
		  <sect2 id="D4LGValues"> 
				<title><indexterm><primary>Values</primary></indexterm><indexterm><primary>Language
								Elements</primary><secondary>Values</secondary></indexterm>Values</title> 
				<para>A <emphasis>value</emphasis> is an individual constant that
					 has no location in time or space [3]. A value cannot be updated. Values may be
					 as simple as the integer constant 3, or as complex as a list of table values.
					 Values are the mechanism for data representation in D4.</para> 
				<para> Values are introduced into D4 expressions and statements
					 through the use of special operators called <emphasis>selectors</emphasis>.
					 Parser literals are a kind of built-in selector for certain system data types.
					 For example, the parser literal <symbol>1</symbol> is a selector for the
					 <symbol>System.Integer</symbol> value <symbol>1</symbol>. Similarly,
					 <symbol>row { 5 ID }</symbol> is a selector for the row value containing a
					 column named <symbol>ID</symbol> with the <symbol>System.Integer</symbol> value
					 <symbol>5</symbol>.</para> 
				<para>Non-scalar selectors in D4 have the following syntax: 
					 <programlisting>&lt;selector&gt; ::=
	&lt;row selector&gt; |
	&lt;table selector&gt; |
	&lt;list selector&gt; |
	&lt;cursor selector&gt;</programlisting></para> 
				<sect3 id="D4LGScalarValues"> 
					 <title><indexterm><primary>Scalar
									 Values</primary></indexterm><indexterm><primary>Values</primary><secondary>Scalar
									 Values</secondary></indexterm>Scalar Values</title> 
					 <para>A scalar value is a value with no user-visible
						  components. The type of any scalar value is a scalar type, specifically. Some
						  possible scalar values include <symbol>5</symbol>, <symbol>"String
						  Value"</symbol> or <symbol>DateTime(2002, 8, 29)</symbol>. In each case, the
						  value described is an atomic value, in that it cannot be broken down into
						  smaller components without ceasing to be a value of the type in question. For a
						  detailed discussion of scalar values, see the Domains topic.</para> 
				</sect3> 
				<sect3 id="D4LGRowValues"> 
					 <title><indexterm><primary>Row
									 Values</primary></indexterm><indexterm><primary>Values</primary><secondary>Row
									 Values</secondary></indexterm>Row Values</title> 
					 <para>A row value is set of named values. The type of a row
						  value is a row type. Each column in the row type has a corresponding value in
						  the row value of the appropriate type.</para> 
					 <para>Row selectors have the following syntax: 
						  <programlisting>&lt;row selector&gt; ::=
	row"{"&lt;named expression term commalist&gt;"}" &lt;metadata&gt;
	
&lt;named expression term&gt; ::=
	&lt;expression term&gt; &lt;column name&gt;

&lt;column name&gt; ::=
	&lt;qualified identifier&gt;</programlisting></para> 
					 <para>See the Expressions section for a detailed description of
						  the <emphasis>expression term</emphasis> production rule.</para> 
					 <para>The following example illustrates the use of the row
						  selector: 
						  <programlisting>row { 53 Age, "Green" EyeColor }</programlisting> </para> 
					 <para>For more information on using row values in D4, see the
						  Using Rows section in Programming Topics.</para> 
				</sect3> 
				<sect3 id="D4LGTableValues"> 
					 <title><indexterm><primary>Table
									 Values</primary></indexterm><indexterm><primary>Values</primary><secondary>Table
									 Values</secondary></indexterm>Table Values</title> 
					 <para> Table values are sets of row values, where each row is
						  of the same type. The heading of the table type is a set of uniquely named
						  columns and the types on which they are defined. The rows within a table value
						  must have the same heading as the table type. Note that a table value is a set
						  of row values, meaning that no two rows in the table are ever permitted to have
						  the same value for all columns. In practice, this constraint is usually
						  enforced by defining a key on some subset of the columns in the table. If a key
						  constraint is not defined in the table selector, or create table statement, the
						  key defaults to all columns in the table.</para> 
					 <para>Table selectors have the following syntax: 
						  <programlisting>&lt;table selector&gt; ::=
	table"{"&lt;table selector item commalist&gt;"}" &lt;metadata&gt;
	
&lt;table selector item&gt; ::=
	"{"&lt;named type specifier commalist&gt;"}" |
	&lt;expression&gt; |
	&lt;key definition&gt;</programlisting></para> 
					 <para>See the Expressions section for a detailed description of
						  the <emphasis>expression</emphasis> production rule.</para> 
					 <para>See the Catalog Elements section for a detailed
						  description of the <emphasis>key definition</emphasis> production rule.</para> 
					 <para>The following example illustrates the use of the table
						  selector: 
						  <programlisting>table 
{
	row { 3.14d DecimalNumber },
	row { 2.3d },
	row { 2.7d }
} </programlisting></para> 
					 <para>For more information on using table values in D4, see the
						  Table Expressions section.</para> 
				</sect3> 
				<sect3 id="D4LGListValues"> 
					 <title><indexterm><primary>List
									 Values</primary></indexterm><indexterm><primary>Values</primary><secondary>List
									 Values</secondary></indexterm>List Values</title> 
					 <para> List values are lists of values of the same type. Each
						  item in the list is addressable through an indexer by its ordinal position in
						  the list. Lists are allowed to contain duplicate values.</para> 
					 <para>List selectors have the following syntax: 
						  <programlisting>&lt;list selector&gt; ::=
	[&lt;list type specifier&gt;]"{"&lt;expression&gt;"}" &lt;metadata&gt;</programlisting></para> 
					 <para>See the Expressions section for a detailed description of
						  the <emphasis>expression</emphasis> production rule.</para> 
					 <para>For more information on using list values in D4, see the
						  Using Lists section in Programming Topics.</para> 
				</sect3> 
				<sect3 id="D4LGCursorValues"> 
					 <title><indexterm><primary>Cursor
									 Values</primary></indexterm><indexterm><primary>Values</primary><secondary>Cursor
									 Values</secondary></indexterm>Cursor Values</title> 
					 <para>Cursor values are values that provide row-at-a-time
						  cursor style access to table values. Selecting a cursor value allocates system
						  resources that must be released by calling <symbol>Close()</symbol> on the
						  cursor. See the system library reference for a detailed description of the
						  operators available for cursors.</para> 
					 <para>Cursor selectors have the following syntax: 
						  <programlisting>&lt;cursor selector&gt; ::=
	cursor"("&lt;cursor definition&gt;")" &lt;metadata&gt;</programlisting></para> 
					 <para>See the Cursor Definition section in Data Manipulation
						  Statements\Select Statement for a detailed description of the <emphasis>cursor
						  definition</emphasis> production rule.</para> 
					 <para>For more information on using cursor values in D4, see
						  the Using Cursors section in Programming Topics.</para> 
				</sect3> 
		  </sect2> 
		  <sect2 id="D4LGVariables"> 
				<title><indexterm><primary>Variables</primary></indexterm><indexterm><primary>Language
								Elements</primary><secondary>Variables</secondary></indexterm>Variables</title>
				
				<para>A variable is a holder for an appearance of a value [3].
					 Variables do have location in space and time, and the value of any given
					 variable at any given point can change. This is not to say that the value
					 changed, but that the variable contains a different value.</para> 
				<para>Variables are declared to be of some type, and this type
					 determines what values the variable can contain. For example, a variable of
					 declared type <symbol>System.Integer</symbol> can only contain values that are
					 of type <symbol>System.Integer</symbol>. This is enforced by the
					 compiler.</para> 
				<para>An important point about variables in a database management
					 system is that tables are variables. Relation variables or
					 <emphasis>relvars</emphasis> specifically. The type of such a variable is a
					 relation type, and the value at any given point is a relation value of that
					 same type. Conceptually then, all the manipulative operators of the language
					 such as <symbol>insert</symbol>, <symbol>update</symbol>, and
					 <symbol>delete</symbol> are just shorthands for some equivalent relational
					 assignment. Tables might then more appropriately have been called
					 <emphasis>table variables</emphasis>, and indeed we refer to them as such
					 throughout the documentation, but for reasons of brevity and familiarity in the
					 language, we chose the more traditional name <symbol>table</symbol>.</para> 
				<para>Variable declaration in D4 has the following syntax: 
					 <programlisting>&lt;variable declaration statement&gt; ::=
	var &lt;ne variable definition commalist&gt;
	
&lt;variable definition&gt; ::=
	&lt;qualified identifier&gt; : &lt;type specifier&gt; [:= &lt;expression&gt;]</programlisting></para> 
				<para>See the Identifiers section for a detailed description of the
					 <emphasis>qualified identifier</emphasis> production rule.</para> 
				<para>See the Types section for a detailed description of the
					 <emphasis>type specifier</emphasis> production rule.</para> 
				<para>See the Expressions section for a detailed description of the
					 <emphasis>expression</emphasis> production rule.</para> 
		  </sect2> 
		  <sect2 id="D4LGOperators"> 
				<title><indexterm><primary>Operators</primary></indexterm><indexterm><primary>Language
								Elements</primary><secondary>Operators</secondary></indexterm>Operators</title>
				
				<para> D4 operators are executable, pre-compiled subroutines. They
					 may be explicitly called, invoked using a built-in operator such as
					 <symbol>+</symbol>, or attached to system events caused by actions such as data
					 manipulation.</para> 
				<para>The DAE provides all the operators necessary to perform basic
					 manipulation of values of the system data types. These operators are covered in
					 detail in the System Library Reference. These operators are known as
					 <emphasis>system provided</emphasis> operators, but the distinction has no
					 affect on functionality.</para> 
				<para>A given D4 operator may be built-in, such as the
					 <symbol>+</symbol> operator. This means that the operator is recognized by the
					 parser and the invocation has special syntax. With very few exceptions, such as
					 the <symbol>where</symbol> operator, a parser recognized invocation has an
					 equivalent standard invocation. For example, the following invocations are
					 equivalent: 
					 <programlisting>5 + 5
iAddition(5, 5)</programlisting></para> 
				<para>A given D4 operator may be host-implemented (or external).
					 This indicates that the implementation of the operator is not a block of D4
					 code, but an external routine referenced via a class definition. For a detailed
					 discussion of this possibility, see Part II of this manual.</para> 
				<para>Every D4 operator has the following characteristics which
					 determine its behavior within the DAE: 
					 <itemizedlist> 
						  <listitem> 
								<para>Literal</para> 
						  </listitem> 
						  <listitem> 
								<para>Functional</para> 
						  </listitem> 
						  <listitem> 
								<para>Deterministic</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>A <emphasis>literal</emphasis> operator is one which does not
					 reference global state, i.e. it does not reference any catalog table variable.
					 In other words, a literal invocation is one which could be evaluated at
					 compile-time.</para> 
				<para>A <emphasis>functional</emphasis> operator is one which does
					 not change global state, i.e. it does not update any catalog table variable.
					 Functional operators are required in certain contexts such as constraint
					 expressions.</para> 
				<para>A <emphasis>deterministic</emphasis> operator is one which
					 always returns the same value for the same set of inputs. Deterministic
					 operators are required in certain contexts such as constraint
					 expressions.</para> 
		  </sect2> 
		  <sect2 id="D4LGStatements"> 
				<title><indexterm><primary>Statements</primary></indexterm><indexterm><primary>Language
								Elements</primary><secondary>Statements</secondary></indexterm>Statements</title>
				
				<para>A statement is the fundamental unit of execution in D4. All
					 statements of D4 fall into three basic categories: 
					 <itemizedlist mark="bullet"> 
						  <listitem> 
								<para>Data Definition Language (DDL)</para> 
						  </listitem> 
						  <listitem> 
								<para>Data Manipulation Language (DML)</para> 
						  </listitem> 
						  <listitem> 
								<para>Imperative</para> 
						  </listitem> 
					 </itemizedlist> </para> 
				<para>Data Definition Language statements are concerned with
					 describing the structure of the database. They allow for the creation,
					 alteration, and destruction of catalog level objects. These statements are
					 discussed in the Catalog Elements section.</para> 
				<para>Data Manipulation Language statements allow for the retrieval
					 and modification of the data in the database. These include
					 <symbol>select</symbol>, <symbol>insert</symbol>, <symbol>update</symbol>, and
					 <symbol>delete</symbol>, and are discussed in the Data Manipulation
					 section.</para> 
				<para>Imperative statements provide the execution framework for the
					 D4 language. These statements provide functionality such as variable
					 declaration, flow control, and exception handling. These statements are
					 discussed in detail in the Imperative Statements section.</para> 
				<para>Statements in D4 have the following syntax: 
					 <programlisting>&lt;statement&gt; ::=
	&lt;dml statement&gt; |
	&lt;ddl statement&gt; |
	&lt;imperative statement&gt;	</programlisting></para> 
				<para>See the Data Manipulation section for a detailed description
					 of the <emphasis>dml statement</emphasis> production rule.</para> 
				<para>See the Catalog Elements section for a detailed description
					 of the <emphasis>ddl statement</emphasis> production rule.</para> 
				<para>See the Imperative Statements section for a detailed
					 description of the <emphasis>imperative statement</emphasis> production
					 rule.</para> 
		  </sect2> 
		  <sect2 id="D4LGExpressions"> 
				<title><indexterm><primary>Expressions</primary></indexterm><indexterm><primary>Language
								Elements</primary><secondary>Expressions</secondary></indexterm>Expressions</title>
				
				<para>A D4 expression is a statement that returns a value. This
					 includes parser literals and operator invocations. Expressions are built
					 according to the <emphasis>expression</emphasis> production rule. Due to the
					 expressive power of D4 and the closure of the relational algebra, these
					 expressions can be of arbitrary complexity. The following are all valid D4
					 expressions. 
					 <programlisting>5
6 * 42
true and not (Length(MyName) = 0)</programlisting> </para> 
				<para>Just like operators, every D4 expression has the following
					 characteristics which determine its behavior within the DAE: 
					 <itemizedlist> 
						  <listitem> 
								<para>Literal</para> 
						  </listitem> 
						  <listitem> 
								<para>Functional</para> 
						  </listitem> 
						  <listitem> 
								<para>Deterministic</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>These characteristics are fixed by the compiler and are
					 determined by the structure of the expression. For example, an expression
					 containing an invocation of a non-deterministic operator is itself
					 non-deterministic.</para> 
				<para>An expression is literal if it references only literal
					 objects. In other words, if it references only parser literals and literal
					 operators. As noted before, a literal expression can be evaluated at
					 compile-time. The type and value of literals is fixed for all time [3]. Any
					 given invocation is literal if its arguments (if any) are all literals in turn
					 [3]. Clearly, any expression which references the global state of the database
					 is not literal.</para> 
				<para>The following are some examples of expressions, some of which
					 are literal: 
					 <programlisting>Days(720500d) // literal 
-5231 // literal
Length(MyString) // not literal
Error("Error: " + AMessage) // not literal </programlisting> </para> 
				<para>An expression is functional if it makes no change to the
					 global state of the database, and makes no calls to non-functional
					 operators.</para> 
				<para>An expression is deterministic if it makes no calls to
					 non-deterministic operators.</para> 
				<para>D4 expressions have the following syntax: 
					 <programlisting>&lt;expression&gt; ::= 
	&lt;expression term&gt; &lt;table operator clause list&gt;

&lt;expression term&gt; ::= 
	&lt;binary expression&gt; &lt;ternary or type operator clause list&gt;

&lt;ternary or type operator clause&gt; ::=
	&lt;between clause&gt; |
	&lt;type operator clause&gt;</programlisting></para> 
				<para>See the Data Manipulation section for a detailed description
					 of the <emphasis>table operator clause</emphasis> production rule.</para> 
				<sect3 id="D4LGOperatorPrecedence"> 
					 <title><indexterm><primary>Operator
									 Precedence</primary></indexterm><indexterm><primary>Expressions</primary><secondary>Operator
									 Precedence</secondary></indexterm>Operator Precedence</title> 
					 <para>Because many of the built-in operators in D4 are in-fix
						  or post-fix operators, operator precedence must be used to determine the order
						  of operations. Operators with a higher precedence will take arguments before
						  operators with a lower precedence. For example, the expression <symbol>2 + 2 *
						  4</symbol> is evaluated as <symbol>2 + (2 * 4)</symbol> because multiplication
						  has a higher precedence than addition. Operators with the same precedence are
						  left-associative, except for exponentiation and extraction, which are
						  right-associative. For example, the expression <symbol>2 ** 3 ** 2</symbol> is
						  evaluated as <symbol>2 ** (3 ** 2)</symbol>, but <symbol>100 / 2 / 10</symbol>
						  is evaluated as <symbol>(100 / 2) / 10</symbol>. Order of operation and
						  associativity in an expression can always be forced using parentheses
						  (<symbol>(</symbol> and <symbol>)</symbol>).</para> 
					 <para> The following table lists the built-in operators of D4
						  in order of precedence from highest to lowest: 
						  <informaltable> 
								<tgroup cols="2">
									 <colspec colwidth="*" colname="col1" colnum="1"/>
									 <colspec colwidth="*" colname="col2" colnum="2"/> 
									 <thead> 
										  <row> 
												<entry colname="col1">Operator(s)</entry> 
												<entry colname="col2">Description</entry> 
										  </row> 
									 </thead> 
									 <tbody> 
										  <row> 
												<entry colname="col1">. [] from</entry> 
												<entry colname="col2">Qualifier Indexer or
													 Extractor</entry> 
										  </row> 
										  <row> 
												<entry colname="col1">~ +(unary) -(unary)
													 not exists </entry> 
												<entry colname="col2">Unary</entry> 
										  </row> 
										  <row> 
												<entry colname="col1">** </entry> 
												<entry
												colname="col2">Exponentiation</entry> 
										  </row> 
										  <row> 
												<entry colname="col1">* / div mod</entry> 
												<entry
												colname="col2">Multiplicative</entry> 
										  </row> 
										  <row> 
												<entry colname="col1">+ - </entry> 
												<entry colname="col2">Additive</entry> 
										  </row> 
										  <row> 
												<entry colname="col1">= &lt;&gt; &lt; &gt;
													 &lt;= &gt;= ?= </entry> 
												<entry colname="col2">Comparison</entry> 
										  </row> 
										  <row> 
												<entry colname="col1">^ &amp; | &lt;&lt;
													 &gt;&gt; </entry> 
												<entry colname="col2">Bitwise
													 Binary</entry> 
										  </row> 
										  <row> 
												<entry colname="col1">and </entry> 
												<entry colname="col2">Logical And</entry> 
										  </row> 
										  <row> 
												<entry colname="col1">in or xor like
													 matches between is as</entry> 
												<entry colname="col2">Logical Binary or
													 Ternary or Type Operator</entry> 
										  </row> 
										  <row> 
												<entry colname="col1">where over remove add
													 rename group return explode on as adorn redefine union difference intersect
													 join times</entry> 
												<entry colname="col2">Relational</entry> 
										  </row> 
									 </tbody> 
								</tgroup> 
						  </informaltable></para> 
				</sect3> 
				<sect3 id="D4LGBetweenClause"> 
					 <title><indexterm><primary>Between
									 Clause</primary></indexterm><indexterm><primary>Expressions</primary><secondary>Between
									 Clause</secondary></indexterm>Between Clause</title> 
					 <para>The between expression is a ternary operator which allows
						  a value to be tested against a range of values of the same type. The expression
						  is logically equivalent to inclusive comparisons against the bounds of the
						  range. For example: 
						  <programlisting>A between B and C</programlisting>is logically equivalent to: 
						  <programlisting>A &gt;= B and A &lt;= C</programlisting></para> 
					 <para>If a between operator is not defined for the types of the
						  given values, the compiler will attempt to resolve the expression using the
						  inclusive comparisons.</para> 
					 <para>The between operator can be overloaded by using
						  <symbol>iBetween</symbol> as the operator name.</para> 
					 <para>The between clause in D4 has the following syntax: 
						  <programlisting>&lt;between clause&gt; ::=
	between &lt;arithmetic expression&gt; and &lt;arithmetic expression&gt;</programlisting></para> 
					 <para>For a description of the available between operators,
						  refer to the <symbol>iBetween</symbol> operator in the System Library
						  Reference.</para> 
				</sect3> 
				<sect3 id="D4LGTypeOperatorClause"> 
					 <title><indexterm><primary>Type Operator
									 Clause</primary></indexterm><indexterm><primary>Expressions</primary><secondary>Type
									 Operator Clause</secondary></indexterm>Type Operator Clause</title> 
					 <para>Type operators allow for run-time type testing to be
						  performed. These operators are system provided and cannot be overloaded.</para>
					 
					 <para>The type operator clause in D4 has the following syntax: 
						  <programlisting>&lt;type operator clause&gt; ::=
	&lt;type operator&gt; &lt;type specifier&gt;
	
&lt;type operator&gt; ::=
	is | as</programlisting></para> 
					 <para>The <symbol>is</symbol> operator returns a boolean value
						  indicating whether the given value is of the provided type. If the type of the
						  given value is equal to the provided type, or is some subtype of the provided
						  type, the invocation returns true, otherwise it returns false.</para> 
					 <para>The <symbol>as</symbol> operator casts the given value to
						  the provided type. An invocation of <symbol>as</symbol> will fail if the given
						  value is not of the provided type, i.e. if an invocation of <symbol>is</symbol>
						  would return false. The value returned from an <symbol>as</symbol> invocation
						  is guaranteed to be of the provided type.</para> 
				</sect3> 
				<sect3 id="D4LGBinaryExpression"> 
					 <title><indexterm><primary>Binary
									 Expression</primary></indexterm><indexterm><primary>Expressions</primary><secondary>Binary
									 Expression</secondary></indexterm>Binary Expression</title> 
					 <para>Binary expressions in D4 have the following syntax: 
						  <programlisting>&lt;binary expression&gt; ::=
	&lt;arithmetic expression&gt; {&lt;binary operator&gt; &lt;arithmetic expression&gt;}

&lt;binary operator&gt; ::=
	and | or | xor | like | matches | in
	^ | &amp; | "|" | "&lt;&lt;" | "&gt;&gt;" |
	= | "&lt;&gt;" | "&lt;" | "&gt;" | "&lt;=" | "&gt;=" | ?=</programlisting></para> 
					 <para>These operators are system provided for the system data
						  types where appropriate, but may be overloaded for other types by using the
						  operator name given by the following table: 
						  <informaltable> 
								<tgroup cols="2"><thead> 
										  <row><entry>Symbol</entry><entry>Operator
													 Name</entry> 
										  </row></thead><tbody> 
										  <row><entry><symbol>and</symbol></entry> 
												<entry><symbol>iAnd</symbol></entry> 
										  </row> 
										  <row><entry><symbol>or</symbol></entry><entry><symbol>iOr</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>xor</symbol></entry><entry><symbol>iXor</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>like</symbol></entry><entry><symbol>iLike</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>matches</symbol></entry><entry><symbol>iMatches</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>in</symbol></entry><entry><symbol>iIn</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>^</symbol></entry><entry><symbol>iBitwiseXor</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>&amp;</symbol></entry><entry><symbol>iBitwiseAnd</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>|</symbol></entry><entry><symbol>iBitwiseOr</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>&lt;&lt;</symbol></entry><entry><symbol>iShiftLeft</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>&gt;&gt;</symbol></entry><entry><symbol>iShiftRight</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>=</symbol></entry><entry><symbol>iEqual</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>&lt;&gt;</symbol></entry><entry><symbol>iNotEqual</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>&lt;</symbol></entry><entry><symbol>iLess</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>&gt;</symbol></entry><entry><symbol>iGreater</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>&lt;=</symbol></entry><entry><symbol>iInclusiveLess</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>&gt;=</symbol></entry><entry><symbol>iInclusiveGreater</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>?=</symbol></entry><entry><symbol>iCompare</symbol></entry>
												
										  </row> 
									 </tbody> 
								</tgroup> 
						  </informaltable></para> 
					 <para>For a complete description of each of these operators,
						  refer to the System Library Reference for each operator name.</para> 
					 <para>For the comparison operators (<symbol>=</symbol>,
						  <symbol>&lt;&gt;</symbol>, <symbol>&lt;</symbol>, <symbol>&gt;</symbol>,
						  <symbol>&lt;=</symbol>, <symbol>&gt;=</symbol>, and <symbol>?=</symbol>) the
						  compiler will attempt to resolve the operators as closely as possible. All
						  types must have an equal comparison defined. From this, the compiler can
						  provide a not equal comparison operator using the logical not. In addition to
						  the equal operator, if a less operator is provided, the compiler can provide
						  the rest of the comparison operators. </para> 
					 <para>The <symbol>iCompare</symbol> operator
						  (<symbol>?=</symbol>) is shorthand for a compare operation defined to be
						  equivalent to a conditional expression: 
						  <programlisting>A ?= B</programlisting>is logically equivalent to: 
						  <programlisting>if A = B then 0 else if A &lt; B then -1 else 1</programlisting></para> 
					 <para>If a given type only has a compare operator defined, the
						  compiler will provide the rest of the comparison operators using it.</para> 
				</sect3> 
				<sect3 id="D4LGArithmeticExpression"> 
					 <title><indexterm><primary>Arithmetic
									 Expression</primary></indexterm><indexterm><primary>Expressions</primary><secondary>Arithmetic
									 Expression</secondary></indexterm>Arithmetic Expression</title> 
					 <para>Arithmetic expressions in D4 have the following syntax: 
						  <programlisting>&lt;arithmetic expression&gt; ::=
	&lt;unary expression&gt; {&lt;arithmetic operator&gt; &lt;unary expression&gt;}

&lt;arithmetic operator&gt; ::=
	+ | - | * | / | div | mod | **</programlisting></para> 
					 <para>These operators are system provided for the system data
						  types where appropriate, but may be overloaded for other types by using the
						  operator name given by the following table: 
						  <informaltable> 
								<tgroup cols="2"><thead> 
										  <row><entry>Symbol</entry><entry>Operator
													 Name</entry> 
										  </row></thead><tbody> 
										  <row><entry><symbol>+</symbol></entry> 
												<entry><symbol>iAddition</symbol></entry> 
										  </row> 
										  <row><entry><symbol>-</symbol></entry><entry><symbol>iSubtraction</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>*</symbol></entry><entry><symbol>iMultiplication</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>/</symbol></entry><entry><symbol>iDivision</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>div</symbol></entry><entry><symbol>iDiv</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>mod</symbol></entry><entry><symbol>iMod</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>**</symbol></entry><entry><symbol>iPower</symbol></entry>
												
										  </row> 
									 </tbody> 
								</tgroup> 
						  </informaltable></para> 
					 <para>For a complete description of each of these operators,
						  refer to the System Library Reference for each operator name.</para> 
				</sect3> 
				<sect3 id="D4LGUnaryExpression"> 
					 <title><indexterm><primary>Unary
									 Expression</primary></indexterm><indexterm><primary>Expressions</primary><secondary>Unary
									 Expression</secondary></indexterm>Unary Expression</title> 
					 <para>Unary expressions in D4 have the following syntax: 
						  <programlisting>&lt;unary expression&gt; ::=
	{&lt;unary operator&gt;} &lt;qualifier expression&gt;
	
&lt;unary operator&gt; ::=
	+ | - | ~ | not | exists</programlisting></para> 
					 <para>These operators (except for unary plus
						  (<symbol>+</symbol>) which is eliminated by the parser) are system provided for
						  the system data types where appropriate, but may be overloaded for other types
						  by using the operator name given by the following table: 
						  <informaltable> 
								<tgroup cols="2"><thead> 
										  <row><entry>Symbol</entry><entry>Operator
													 Name</entry> 
										  </row></thead><tbody> 
										  <row><entry><symbol>-</symbol></entry><entry><symbol>iNegate</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>~</symbol></entry><entry><symbol>iBitwiseNot</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>not</symbol></entry><entry><symbol>iNot</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>exists</symbol></entry><entry><symbol>iExists</symbol></entry>
												
										  </row> 
									 </tbody> 
								</tgroup> 
						  </informaltable></para> 
					 <para>For a complete description of each of these operators,
						  refer to the System Library Reference for each operator name.</para> 
				</sect3> 
				<sect3 id="D4LGQualifierExpression"> 
					 <title><indexterm><primary>Qualifier
									 Expression</primary></indexterm><indexterm><primary>Expressions</primary><secondary>Qualifier
									 Expression</secondary></indexterm>Qualifier Expression</title> 
					 <para>Qualifier expressions in D4 have the following syntax: 
						  <programlisting>&lt;qualifier expression&gt; ::=
	[.]{&lt;indexer expression&gt;.}&lt;indexer expression&gt;</programlisting></para> 
					 <para>The qualifier operator in D4 is a system provided
						  operator and cannot be overloaded. It serves the following functions: 
						  <itemizedlist> 
								<listitem> 
									 <para>Namespace qualifier</para> 
								</listitem> 
								<listitem> 
									 <para>Property accessor</para> 
								</listitem> 
								<listitem> 
									 <para>Operator invocation</para> 
								</listitem> 
						  </itemizedlist></para> 
					 <para>For a description of how the qualifier behaves for the
						  purposes of namespace resolution, refer to the Identifiers section.</para> 
					 <para>If the target of the qualifier is a scalar-valued
						  expression, the qualifier can be used to access the properties of any possible
						  representation of that type. This type of property access can be an expression
						  or an assignment target, depending on which side of an assignment statement it
						  appears. For a complete description of possible representations and property
						  accessors, refer to the Catalog Elements section on Domains.</para> 
					 <para>If the qualifier is an unresolved operator invocation,
						  the compiler will attempt to resolve the invocation again, passing the
						  qualifier target as the first argument of the invocation. If this resolution
						  fails, the compiler will attempt to resolve the invocation with the qualifier
						  target as a <symbol>var</symbol> argument. In this way, the qualifier enables
						  OOP-style "method" invocation.</para> 
				</sect3> 
				<sect3 id="D4LGIndexerExpression"> 
					 <title><indexterm><primary>Indexer
									 Expression</primary></indexterm><indexterm><primary>Expressions</primary><secondary>Indexer
									 Expression</secondary></indexterm>Indexer Expression</title> 
					 <para>Indexer expressions in D4 have the following syntax: 
						  <programlisting>&lt;indexer expression&gt; ::=
	&lt;factor&gt;{"["&lt;expression term&gt;"]"}</programlisting></para> 
					 <para>Indexer expressions provide a mechanism for array-style
						  access. This operator is overloaded for lists and strings, but may be
						  overloaded for other types by using the operator name
						  <symbol>iIndexer</symbol>.</para> 
				</sect3> 
				<sect3 id="D4LGFactor"> 
					 <title><indexterm><primary>Factor</primary></indexterm><indexterm><primary>Expressions</primary><secondary>Factor</secondary></indexterm>Factor</title>
					 
					 <para>Factors in D4 have the following syntax: 
						  <programlisting>&lt;factor&gt; ::=
	(&lt;expression&gt;) |
	&lt;parser literal&gt; |
	&lt;identifier&gt; |
	&lt;operator invocation&gt; |
	&lt;selector&gt; |
	&lt;extractor&gt; |
	parent &lt;qualified identifier&gt; |
	&lt;conditional expression&gt;</programlisting></para> 
				</sect3> 
				<sect3 id="D4LGOperatorInvocation"> 
					 <title><indexterm><primary>Operator
									 Invocation</primary></indexterm><indexterm><primary>Expressions</primary><secondary>Operator
									 Invocation</secondary></indexterm>Operator Invocation</title> 
					 <para>Operator invocation in D4 uses parentheses to delimit the
						  argument list, and commas to separate arguments within the list. The arguments
						  in a given call expression must appear in the order they are defined in the
						  operator definition for the operator being invoked. The operator name, together
						  with the names of the types for the arguments in the order they are defined, is
						  known as the <emphasis>operator signature</emphasis> and is used by the
						  compiler to perform operator resolution. The operator most closely matching the
						  call signature is used. </para> 
					 <para>Each operand in the signature of an operator has an
						  associated modifier. If this modifier is <symbol>var</symbol>, the call must
						  use the <symbol>var</symbol> keyword to pass the argument in the invocation.
						  This helps to ensure that operator invocations which can have side effects are
						  clearly marked in the code.</para> 
					 <para>Operator invocations in D4 have the following syntax: 
						  <programlisting>&lt;operator invocation&gt; ::=
	&lt;identifier&gt;(&lt;actual parameter commalist&gt;)

&lt;actual parameter&gt; ::=
	[var] &lt;expression&gt;</programlisting></para> 
				</sect3> 
				<sect3 id="D4LGExtractor"> 
					 <title><indexterm><primary>Extractor</primary></indexterm><indexterm><primary>Expressions</primary><secondary>Extractor</secondary></indexterm>Extractor</title>
					 
					 <para>Extractors in D4 have the following syntax: 
						  <programlisting>&lt;extractor&gt; ::=
	&lt;row extractor&gt; |
	&lt;column extractor&gt;

&lt;row extractor&gt; ::=
	row from &lt;expression&gt;

&lt;column extractor&gt; ::=
	&lt;column name&gt; from &lt;expression&gt;

&lt;column name&gt; ::=
	&lt;qualified identifier&gt;</programlisting></para> 
					 <para>An extractor is a special operator used to extract a
						  value from a set of values, such as a column value from a row, or a row value
						  from a table. The system provides overloads for these operators where
						  appropriate. Extractors may not be overloaded.</para> 
					 <para>Note that the row extractor is required to operate on a
						  singleton result set, i.e. the table from which the row is to be extracted must
						  contain one and only one row.</para> 
				</sect3> 
				<sect3 id="D4LGConditionalExpression"> 
					 <title><indexterm><primary>Conditional
									 Expression</primary></indexterm><indexterm><primary>Expressions</primary><secondary>Conditional
									 Expression</secondary></indexterm>Conditional Expression</title> 
					 <para>Conditional expressions are a kind of inline function in
						  that they are equivalent to writing an operator that uses branching.</para> 
					 <para>There are two types of conditional expressions in D4, the
						  if expression and the case expression.</para> 
					 <para>These operators are system provided and cannot be
						  overloaded.</para> 
					 <para>Conditional expressions in D4 have the following syntax: 
						  <programlisting>&lt;conditional expression&gt; ::=
	&lt;if expression&gt; |
	&lt;case expression&gt;

&lt;if expression&gt; ::=
	if &lt;expression&gt; then &lt;expression&gt; else &lt;expression&gt;

&lt;case expression&gt; ::=
	case [&lt;expression&gt;]
		&lt;ne case expression item commalist&gt;
		else &lt;expression&gt;
	end
    
&lt;case expression item&gt; ::=
	when &lt;expression&gt; then &lt;expression&gt;</programlisting></para> 
					 <para>If expressions evaluate the condition, and return the
						  first given expression if it is true, otherwise the second given expression is
						  returned. Note that both these expressions are required to return values of
						  compatible types.</para> 
					 <para>Case expressions are shorthand for iterated if
						  expressions. There are two flavors of the case expression, one in which a
						  single expression is used as the comparison target for each case item, and one
						  in which no comparison target is given, rather each case item condition is a
						  boolean comparison in itself. In both versions of the expression, the final
						  unsatisfied condition is given by the else expression, and the results of all
						  case items and the else expression must return values of compatible
						  types.</para> 
				</sect3> 
		  </sect2> 
	 </sect1> 
	 <sect1 id="D4LGCatalogElements"> 
		  <title><indexterm><primary>Catalog
						  Elements</primary></indexterm><indexterm><primary>D4 Language
						  Guide</primary><secondary>Catalog Elements</secondary></indexterm>Catalog
				Elements</title> 
		  <para>The Catalog is the repository of globally scoped objects within
				the DAE. It contains the tables, views, business rules (constraints) and other
				items that constitute the database schema. The Catalog is also called the Data
				Model or the Data Dictionary. The DAE uses the Catalog to describe the business
				model which represents the core of the database application.</para> 
		  <para>Each type of catalog object has associated declarative syntax for
				creating, altering, or dropping objects in the catalog. Data definition
				language statements in D4 have the following syntax: 
				<programlisting>&lt;ddl statement&gt; ::=
	&lt;create statement&gt; |
	&lt;alter statement&gt; |
	&lt;drop statement&gt; |
	&lt;attach statement&gt; |
	&lt;detach statement&gt;

&lt;create statement&gt; ::=
	&lt;create table statement&gt; |
	&lt;create view statement&gt; |
	&lt;create constraint statement&gt; |
	&lt;create reference statement&gt; |
	&lt;create domain statement&gt; |
	&lt;create operator statement&gt; |
	&lt;create aggregate operator statement&gt; |
	&lt;create device statement&gt; |
	&lt;create sort statement&gt;

&lt;alter statement&gt; ::=
	&lt;alter table statement&gt; |
	&lt;alter view statement&gt; |
	&lt;alter constraint statement&gt; |
	&lt;alter reference statement&gt; |
	&lt;alter domain statement&gt; |
	&lt;alter operator statement&gt; |
	&lt;alter aggregate operator statement&gt; |
	&lt;alter device statement&gt; |
	&lt;alter sort statement&gt;

&lt;drop statement&gt; ::=
	&lt;drop table statement&gt; |
	&lt;drop view statement&gt; |
	&lt;drop constraint statement&gt; |
	&lt;drop reference statement&gt; |
	&lt;drop operator statement&gt; |
	&lt;drop aggregate operator statement&gt; |
	&lt;drop device statement&gt; |
	&lt;drop sort statement&gt;</programlisting></para> 
		  <para>See the topics for each type of catalog object for a complete
				description of the syntax for DML statements.</para> 
		  <para>See the Trigger Handlers section for a complete description of
				the attach and detach statements.</para> 
		  <sect2 id="D4LGObjects"> 
				<title><indexterm><primary>Objects</primary></indexterm><indexterm><primary>Catalog
								Elements</primary><secondary>Objects</secondary></indexterm>Objects</title> 
				<para>All catalog objects have certain properties in common. The
					 following list summarizes these common properties: 
					 <itemizedlist> 
						  <listitem> 
								<para>ID</para> 
								<para>Each object has an associated ID of type
									 <symbol>System.Guid</symbol>. This is a globally unique identifier which serves
									 to identify the object for all time.</para> 
						  </listitem> 
						  <listitem> 
								<para>Name</para> 
								<para>Each object has an associated Name which serves
									 as the user visible name of the object.</para> 
						  </listitem> 
						  <listitem> 
								<para>MetaData</para> 
								<para>Each object has associated meta data which is
									 used to store extra information about the object that does not pertain to the
									 logical model, but to some other application such as a frontend client.</para> 
						  </listitem> 
						  <listitem> 
								<para>Characteristics</para> 
								<para>Each object has associated characteristics such
									 as whether or not the object is a system object, and so on. These
									 characteristics are set by the system and cannot be changed.</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<sect3 id="D4LGMetaData"> 
					 <title><indexterm><primary>MetaData</primary></indexterm><indexterm><primary>Objects</primary><secondary>MetaData</secondary></indexterm>MetaData</title>
					 
					 <para>Each of the objects in the catalog may have metadata
						  associated with it. This metadata is application specific information that is
						  irrelevant to the logical model, expressed as a set of named string values.
						  This metadata is used to extend the business model beyond what can be expressed
						  through the logical objects of the catalog.</para> 
					 <para>There are several kinds of metadata in the DAE, such
						  as:</para> 
					 <para> 
						  <itemizedlist mark="bullet"> 
								<listitem> 
									 <para> <emphasis role="strong">Comments</emphasis>
										  </para> 
									 <para> A comment is represented as a string, and
										  can be used to provide a description of the catalog object.</para> 
								</listitem> 
								<listitem> 
									 <para> <emphasis role="strong">Tags</emphasis>
										  </para> 
									 <para> Tags are general purpose strings that are
										  identified by a name.</para> 
								</listitem> 
								<listitem> 
									 <para> <emphasis role="strong">Orders</emphasis>
										  </para> 
									 <para> Order information on a table variable (Table
										  or View) is considered metadata because it is ignored within the logical
										  model.</para> 
								</listitem> 
								<listitem> 
									 <para> <emphasis role="strong">Class
										  Definitions</emphasis> </para> 
									 <para> Certain structures within the DAE reference
										  host language (.NET Framework) implemented code. Again, the meaning of these
										  references has no meaning within the logical model.</para> 
								</listitem> 
						  </itemizedlist> </para> 
					 <para>Meta data in D4 has the following syntax: 
						  <programlisting>&lt;metadata&gt; ::=
	[&lt;metadata comment&gt;] [&lt;tags&gt;]
	
&lt;metadata comment&gt; ::=
	comment = &lt;string&gt;

&lt;tags&gt; ::=
	tags "{"&lt;ne tag definition commalist&gt;"}"
	
&lt;tag definition&gt; ::=
	&lt;tag name&gt; = &lt;string&gt;
	
&lt;tag name&gt; ::=
	&lt;qualified identifier&gt;</programlisting></para> 
					 <para>Alter meta data in D4 has the following syntax: 
						  <programlisting>&lt;alter metadata&gt; ::=
	[alter [comment = &lt;string&gt;] [tags "{"&lt;alter tag definition commalist&gt;"}"]]
	
&lt;alter tag definition&gt; ::=
	create &lt;tag definition&gt; | alter &lt;tag definition&gt; | drop &lt;tag name&gt;</programlisting></para> 
					 <para>Meta data is allowed to be specified in most DDL
						  statements.</para> 
				</sect3> 
				<sect3 id="D4LGClassDefinitions"> 
					 <title><indexterm><primary>Class
									 Definitions</primary></indexterm><indexterm><primary>Objects</primary><secondary>Class
									 Definitions</secondary></indexterm>Class Definitions</title> 
					 <para>Class definitions are a specific type of meta data used
						  by the DAE to describe structures in the host implementation. For a detailed
						  description of class definitions and their usage, refer to Part II of this
						  manual.</para> 
					 <para>Class definitions in D4 have the following syntax: 
						  <programlisting>&lt;class definition&gt; ::=
	class "&lt;class name&gt;" [&lt;attributes&gt;]

&lt;class name&gt; ::=
	&lt;string&gt;

&lt;attributes&gt; ::=
	attributes "{"&lt;ne attribute definition commalist&gt;"}"
	
&lt;attribute definition&gt; ::=
	&lt;attribute name&gt; = &lt;attribute value&gt;

&lt;attribute name&gt; ::=
	&lt;string&gt;

&lt;attribute value&gt; ::=
	&lt;string&gt;</programlisting></para> 
					 <para>Alter class definitions in D4 have the following syntax: 
						  <programlisting>&lt;alter class definition&gt; ::=
	alter class [&lt;class name&gt;] ["{"&lt;alter attribute definition commalist&gt;"}"]
	
&lt;alter attribute definition&gt; ::=
	create &lt;attribute definition&gt; | 
	alter &lt;attribute definition&gt; | 
	drop &lt;attribute name&gt;</programlisting></para> 
					 <para>These definitions are used throughout DDL statements to
						  specify host implementation structures.</para> 
				</sect3> 
		  </sect2> 
		  <sect2 id="D4LGDomains"> 
				<title><indexterm><primary>Domains</primary></indexterm><indexterm><primary>Catalog
								Elements</primary><secondary>Domains</secondary></indexterm>Domains</title> 
				<para>A domain (or scalar type) is a named set of values. Domains
					 are scalar in that they have no user-visible structure (also called
					 <emphasis>atomic</emphasis>. They are the fundamental units of data description
					 in the DAE. Domains provide the building blocks out of which all other data in
					 the database is built. In addition to providing a complete set of system data
					 types, the DAE allows for the creation of user-defined types of arbitrary
					 complexity.</para> 
				<para>The create domain statement in D4 has the following syntax: 
					 <programlisting>&lt;create domain statement&gt; ::=
	create domain &lt;domain name&gt; 
	[is "{"&lt;ne domain name commalist&gt;"}"]
	["{"&lt;domain definition item commalist&gt;"}"]
	[&lt;class definition&gt;]
	&lt;metadata&gt;

&lt;domain name&gt; ::=
	&lt;qualified identifier&gt;
	
&lt;domain definition item&gt; ::=
	&lt;representation definition&gt; |
	&lt;constraint definition&gt; |
	&lt;default definition&gt; |
	&lt;special definition&gt;</programlisting></para> 
				<para>The alter domain statement in D4 has the following syntax: 
					 <programlisting>&lt;alter domain statement&gt; ::=
	alter domain &lt;domain name&gt; 
		["{"&lt;alter domain definition item commalist&gt;"}"]
		&lt;alter class definition&gt;
		&lt;alter metadata&gt;

&lt;alter domain definition item&gt; ::=
	&lt;alter representation definition&gt; |
	&lt;alter constraint definition&gt; |
	&lt;alter default definition&gt; |
	&lt;alter special definition&gt;</programlisting></para> 
				<para>The drop domain statement in D4 has the following syntax: 
					 <programlisting>&lt;drop domain statement&gt; ::=
	drop domain &lt;domain name&gt;</programlisting></para> 
				<para>These statements create, alter or drop a domain named
					 <emphasis>domain name</emphasis> with the characteristics given by the rest of
					 the statements. Explanations for each of the specific portions of the
					 statements follow.</para> 
				<sect3 id="D4LGTypeConstraints"> 
					 <title><indexterm><primary>Type
									 Constraints</primary></indexterm><indexterm><primary>Domains</primary><secondary>Type
									 Constraints</secondary></indexterm>Type Constraints</title> 
					 <para>Scalar types in D4 are defined using constraints. A type
						  constraint describes the set of legal values for a given domain. Constraints
						  are enforced for all values of the domain, including local variables. A given
						  domain may have any number of constraints associated with it. The DAE will
						  verify that any value of the given type satisfies all the type constraints
						  defined. </para> 
					 <para>If a constraint is violated (if the expression evaluates
						  to false for some value), the name of the constraint is used to construct an
						  error message. In addition, if present on the constraint, the meta data tag
						  <symbol>DAE.Message</symbol> is added to the error message.</para> 
					 <para>A type constraint definition in D4 has the following
						  syntax: 
						  <programlisting>&lt;constraint definition&gt; ::=
	constraint &lt;constraint name&gt; &lt;expression&gt; &lt;metadata&gt;
	
&lt;constraint name&gt; ::=
	&lt;qualified identifier&gt;</programlisting></para> 
					 <para>An alter type constraint definition in D4 has the
						  following syntax: 
						  <programlisting>&lt;alter constraint definition&gt; ::=
	create &lt;constraint definition&gt; |
	alter constraint &lt;constraint name&gt; [&lt;expression&gt;] &lt;alter metadata&gt; |
	drop constraint &lt;constraint name&gt;</programlisting></para> 
					 <para>See the Expression section for a detailed description of
						  the <emphasis>expression</emphasis> production rule.</para> 
					 <para>The expression specified must be boolean-valued,
						  functional, and deterministic. The compiler enforces these requirements. Within
						  the expression, the implicit variable <symbol>value</symbol> is available,
						  which is the value being validated.</para> 
				</sect3> 
				<sect3 id="D4LGPossibleRepresentations"> 
					 <title><indexterm><primary>Possible
									 Representations</primary></indexterm><indexterm><primary>Domains</primary><secondary>Possible
									 Representations</secondary></indexterm>Possible Representations</title> 
					 <para>Each scalar type has a set of possible representations.
						  Each possible representation is a set of &lt;name, data type&gt; pairs called
						  properties. For each representation, a selector is provided which takes as
						  arguments all the properties of the representation. For each property, a read
						  and write accessor is provided which allows for retrieval and manipulation of
						  the individual components of the representation. It is important to note that
						  the set accessor is only shorthand for the equivalent selector invocation.
						  Values, by definition, are immutable.</para> 
					 <para>Note that a possible representation must be capable of
						  representing all the values of a given domain, indeed, if it were not, it would
						  not be a possible representation for the domain.</para> 
					 <para>If a given domain definition has no representations
						  defined, the compiler will attempt to provide a default representation based on
						  the first system type in a single inheritance type graph that uses the same
						  conveyor as this type. The representation will be built as follows: 
						  <programlisting>representation &lt;type name&gt; { &lt;type name&gt; : &lt;base type name&gt; }</programlisting>This representation will use the default selector and read and
						  write accessors as described below.</para> 
					 <para>A possible representation definition in D4 has the
						  following syntax: 
						  <programlisting>&lt;representation definition&gt; ::=
	representation &lt;representation name&gt;
		"{"&lt;ne property definition commalist&gt;"}"
		[&lt;class definition&gt;]
		&lt;metadata&gt;

&lt;representation name&gt; ::=
	&lt;qualified identifier&gt;</programlisting></para> 
					 <para>An alter possible representation definition in D4 has the
						  following syntax: 
						  <programlisting>&lt;alter representation definition&gt; ::=
	create &lt;representation definition&gt; |
	alter representation 
		&lt;representation name&gt; 
		["{"&lt;ne alter property definition commalist&gt;"}"] 
		&lt;alter class definition&gt; 
		&lt;alter metadata&gt; |
	drop representation &lt;representation name&gt;</programlisting></para> 
					 <sect4 id="D4LGSelector"> 
						  <title><indexterm><primary>Selector</primary></indexterm><indexterm><primary>Possible
										  Representations</primary><secondary>Selector</secondary></indexterm>Selector</title>
						  
						  <para>A <emphasis>selector</emphasis> is a D4 operator that
								allows the values of a domain to be selected based on values for the properties
								of that representation.</para> 
						  <para>The <emphasis>class definition</emphasis> for the
								representation specifies the host implementation class that will provide the
								selector implementation for this representation. If no selector definition is
								provided, the compiler will attempt to provide a default selector. If the
								representation has only one property, the system will use the class
								<symbol>Alphora.Dataphor.DAE.Runtime.Instructions.ScalarSelectorNode</symbol>
								in the assembly <symbol>Alphora.Dataphor.DAE</symbol> to provide the selector
								implementation. Otherwise, the compiler will raise an error stating that a
								default selector could not be provided.</para> 
						  <para>The selector operator is built based on the class
								definition determined above with the following header: 
								<programlisting>operator &lt;type name&gt;[.&lt;representation name&gt;]
	(
		const A&lt;property name&gt; : &lt;property type&gt;[, ...]
	) : &lt;type&gt;</programlisting></para> 
						  <para>Note that selectors are required to be
								host-implemented operators, as they must be able to access the physical
								representation of the value, which is unavailable in D4.</para> 
						  <para>The following example illustrates the use of the a
								selector for the <symbol>System.TimeSpan</symbol> data type: 
								<programlisting>Seconds(100); // returns a TimeSpan value						</programlisting> </para> 
					 </sect4> 
					 <sect4 id="D4LGProperties"> 
						  <title><indexterm><primary>Properties</primary></indexterm><indexterm><primary>Possible
										  Representations</primary><secondary>Properties</secondary></indexterm>Properties</title>
						  
						  <para>Properties are the individual components of a
								possible representation. Each property is a &lt;name, data type&gt; pair that
								defines the component of the representation. Each property requires two
								special-purpose operators called accessors, one to read the value for the
								property, and one to write it.</para> 
						  <para>A property definition in D4 has the following syntax:
								
								<programlisting>&lt;property definition&gt; ::=
	&lt;property name&gt; : &lt;type specifier&gt; 
		[read &lt;class definition&gt;] 
		[write &lt;class definition&gt;] 
		&lt;metadata&gt;
		
&lt;property name&gt; ::=
	&lt;qualified identifier&gt;</programlisting></para> 
						  <para>An alter property definition in D4 has the following
								syntax: 
								<programlisting>&lt;alter property definition&gt; ::=
	create &lt;property definition&gt; |
	alter &lt;property name&gt;
		[: &lt;type specifier&gt;]
		[read &lt;alter class definition&gt;]
		[write &lt;alter class definition&gt;]
		&lt;alter metadata&gt; |
	drop &lt;property name&gt;</programlisting></para> 
						  <sect5 id="D4LGReadAccessor"> 
								<title><indexterm><primary>Read
												Accessor</primary></indexterm><indexterm><primary>Properties</primary><secondary>Read
												Accessor</secondary></indexterm>Read Accessor</title> 
								<para>The read accessor is a special-purpose operator
									 built by the compiler to allow read access to the given property.</para> 
								<para>The <emphasis>read class definition</emphasis>
									 for the property specifies the host implementation class that will provide the
									 read accessor implementation for this property. If no read accessor definition
									 is provided, the compiler will attempt to provide a default read accessor. If
									 the representation has only one property, the system will use the class
									 <symbol>Alphora.Dataphor.DAE.Runtime.Instructions.ScalarReadAccessorNode</symbol>
									 in the assembly <symbol>Alphora.Dataphor.DAE</symbol> to provide the read
									 accessor implementation. Otherwise, the compiler will raise an error stating
									 that a default read accessor could not be provided.</para> 
								<para>The read accessor is built based on the class
									 definition determined above with the following header: 
									 <programlisting>operator &lt;type name&gt;.Read&lt;property name&gt;
	(
		const Avalue : &lt;type&gt;
	) : &lt;property type&gt;</programlisting></para> 
								<para>Note that read accessors are required to be
									 host-implemented operators, as they must be able to access the physical
									 representation of the value, which is unavailable in D4.</para> 
								<para>The following example illustrates the use of a
									 read accessor: 
									 <programlisting>// sets LInteger to the value of the DaysPart property of a TimeSpan
LInteger = LTimeSpan.DaysPart; </programlisting></para> 
						  </sect5> 
						  <sect5 id="D4LGWriteAccessor"> 
								<title><indexterm><primary>Write
												Accessor</primary></indexterm><indexterm><primary>Properties</primary><secondary>Write
												Accessor</secondary></indexterm>Write Accessor</title> 
								<para>The write accessor is a special-purpose operator
									 built by the compiler to allow write access to the given property.</para> 
								<para>The <emphasis>write class definition</emphasis>
									 for the property specifies the host implementation class that will provide the
									 write accessor implementation for this property. If no write accessor
									 definition is provided, the compiler will attempt to provide a default write
									 accessor. If the representation has only one property, the system will use the
									 class
									 <symbol>Alphora.Dataphor.DAE.Runtime.Instructions.ScalarWriteAccessorNode</symbol>
									 in the assembly <symbol>Alphora.Dataphor.DAE</symbol> to provide the write
									 accessor implementation. Otherwise, the compiler will raise an error stating
									 that a default write accessor could not be provided.</para> 
								<para>The write accessor is built based on the class
									 definition determined above with the following header: 
									 <programlisting>operator &lt;type name&gt;.Write&lt;property name&gt;
	(
		const Avalue : &lt;type&gt;, 
		const A&lt;property name&gt; : &lt;property type&gt;
	) : &lt;type&gt;</programlisting></para> 
								<para>Note that write accessors are required to be
									 host-implemented operators, as they must be able to access the physical
									 representation of the value, which is unavailable in D4.</para> 
								<para>The following example illustrates the use of a
									 write accessor: 
									 <programlisting>// sets the value of the DaysPart property of the LTimeSpan variable
LTimeSpan.DaysPart := 100;</programlisting></para> 
						  </sect5> 
					 </sect4> 
				</sect3> 
				<sect3 id="D4LGDefaults"> 
					 <title><indexterm><primary>Defaults</primary></indexterm><indexterm><primary>Domains</primary><secondary>Defaults</secondary></indexterm>Defaults</title>
					 
					 <para>A domain may have a <emphasis>default</emphasis>
						  associated with it, which indicates what the default value for any variable of
						  this type should be. This applies not only to columns in a table, but also to
						  local variables declared through a variable declaration statement. The default
						  must be a value of the domain.</para> 
					 <para>A domain default definition in D4 has the following
						  syntax: 
						  <programlisting>&lt;default definition&gt; ::=
	default &lt;expression&gt; &lt;metadata&gt;</programlisting></para> 
					 <para>An alter domain default definition in D4 has the
						  following syntax: 
						  <programlisting>&lt;alter default definition&gt; ::=
	create &lt;default definition&gt; |
	alter default [&lt;expression&gt;] &lt;alter metadata&gt; |
	drop default</programlisting></para> 
				</sect3> 
				<sect3 id="D4LGSpecialValues"> 
					 <title><indexterm><primary>Special
									 Values</primary></indexterm><indexterm><primary>Domains</primary><secondary>Special
									 Values</secondary></indexterm>Special Values</title> 
					 <para>A <emphasis>special</emphasis> is a named value of the
						  domain. Special values provide a solution to the problem of missing information
						  without stepping outside the bounds of the relational model.</para> 
					 <para>Special definitions in D4 have the following syntax: 
						  <programlisting>&lt;special definition&gt; ::=
	special &lt;special name&gt; &lt;expression&gt; &lt;metadata&gt;

&lt;special name&gt; ::=
	&lt;qualified identifier&gt;</programlisting></para> 
					 <para>Alter special definitions in D4 have the following
						  syntax: 
						  <programlisting>&lt;alter special definition&gt; ::=
	create &lt;special definition&gt; |
	alter special &lt;special name&gt; [&lt;expression&gt;] &lt;alter metadata&gt; |
	drop special &lt;special name&gt;</programlisting></para> 
					 <para>For each special the compiler builds two special-purpose
						  operators called the special selector and the special comparer. The special
						  selector has the heading: 
						  <programlisting>operator &lt;type name&gt;&lt;special name&gt;() : &lt;type&gt;</programlisting>and returns the value of the special. The special comparer has
						  the heading: 
						  <programlisting>operator Is&lt;special name&gt;(const AValue : &lt;type&gt;) : Boolean</programlisting>and returns true if the given value is equal to the value of
						  the special, and false otherwise.</para> 
					 <para>In addition to the operators created for each special,
						  each domain has an associated special comparer which is created even if there
						  are no specials defined for the domain. The domain special comparer has the
						  heading: 
						  <programlisting>operator IsSpecial(const AValue : &lt;type&gt;) : Boolean</programlisting>and returns true if the given value is equal to the value of
						  any special defined on the domain, and false otherwise.</para> 
				</sect3> 
				<sect3 id="D4LGScalarTypeInheritance"> 
					 <title><indexterm><primary>Scalar Type
									 Inheritance</primary></indexterm><indexterm><primary>Domains</primary><secondary>Scalar
									 Type Inheritance</secondary></indexterm>Scalar Type Inheritance</title> 
					 <para>Scalar type inheritance allows scalar types to be defined
						  as a subset of the values of other types.</para> 
					 <para>All domains are subtypes of the alpha type
						  <symbol>System.Alpha</symbol>. A subtype is a subset of values. For example,
						  <symbol>System.Integer</symbol> is a subtype of <symbol>System.Long</symbol>,
						  because every value of type <symbol>System.Integer</symbol> is also of type
						  <symbol>System.Long</symbol>. If a supertype is not specified as part of the
						  definition of a given type, it will be assumed to be a subtype of
						  <symbol>System.Alpha</symbol>. Multiple supertypes may be specified, with the
						  analogous interpretation: every value of the type is a subtype of each of its
						  supertypes.</para> 
					 <para>The create domain statement includes an optional
						  supertype list that indicates which types, if any, this type is a subtype of.
						  If no supertype is specified, the domain is assumed to be a subtype of
						  <symbol>System.Alpha</symbol>.</para> 
					 <para>For each immediate supertype of the domain, the compiler
						  builds implicit cast operators with the heading: 
						  <programlisting>operator &lt;type name&gt;(const AValue : &lt;supertype name&gt;) : &lt;type name&gt;</programlisting>These operators are used by the compiler to provide implicit
						  casting as necessary.</para> 
				</sect3> 
				<sect3 id="D4LGConveyors"> 
					 <title><indexterm><primary>Conveyors</primary></indexterm><indexterm><primary>Domains</primary><secondary>Conveyors</secondary></indexterm>Conveyors</title>
					 
					 <para>The <emphasis>class definition</emphasis> describes the
						  host implementation class that will provide the physical representation for
						  this type. This class is known as the <emphasis>conveyor</emphasis> for the
						  type. If no conveyor is specified, the system will attempt to provide a default
						  conveyor for the type in the following order: 
						  <itemizedlist> 
								<listitem> 
									 <para>If the domain has a single immediate
										  supertype, and that type has a conveyor defined, that conveyor is used.</para> 
								</listitem> 
								<listitem> 
									 <para>If the default representation for the domain
										  has a single scalar property, and the type of that property has a conveyor,
										  that conveyor is used.</para> 
								</listitem> 
								<listitem> 
									 <para>If neither of the above conditions is true,
										  the compiler will raise an exception.</para> 
								</listitem> 
						  </itemizedlist>The following table lists the conveyors for
						  the system data types. 
						  <informaltable> 
								<tgroup cols="2"><thead> 
										  <row><entry>Scalar Type</entry><entry>Conveyor
													 Class</entry> 
										  </row></thead><tbody> 
										  <row><entry><symbol>System.Error</symbol></entry><entry><symbol>ObjectConveyor</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>System.Boolean</symbol></entry><entry><symbol>BooleanConveyor</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>System.Decimal</symbol></entry><entry><symbol>DecimalConveyor</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>System.Long</symbol></entry><entry><symbol>Int64Conveyor</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>System.Integer</symbol></entry><entry><symbol>Int32Conveyor</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>System.Short</symbol></entry><entry><symbol>Int16Conveyor</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>System.Byte</symbol></entry><entry><symbol>ByteConveyor</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>System.String</symbol></entry><entry><symbol>StringConveyor</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>System.IString</symbol></entry><entry><symbol>StringConveyor</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>System.TimeSpan</symbol></entry><entry><symbol>TimeSpanConveyor</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>System.DateTime</symbol></entry><entry><symbol>DateTimeConveyor</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>System.Guid</symbol></entry><entry><symbol>GuidConveyor</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>System.Image</symbol></entry><entry><symbol>StreamConveyor</symbol></entry>
												
										  </row></tbody> 
								</tgroup> 
						  </informaltable></para> 
					 <para>These conveyors are all defined in the
						  <symbol>Alphora.Dataphor.DAE.Runtime.Streams</symbol> namespace in the
						  <symbol>Alphora.Dataphor.DAE</symbol> assembly.</para> 
				</sect3> 
				<sect3 id="D4LGMetaData1"> 
					 <title><indexterm><primary>MetaData</primary></indexterm><indexterm><primary>Domains</primary><secondary>MetaData</secondary></indexterm>MetaData</title>
					 
					 <para>The <emphasis>metadata</emphasis> describes additional
						  information that should be associated with this domain. If specified, the
						  <symbol>DAE.StaticByteSize</symbol> tag specifies the number of bytes that
						  should be colocated with a row value for values of this type. For a complete
						  description of the usage of this tag, refer to the Streams section in Part II
						  of this manual.</para> 
				</sect3> 
				<sect3 id="D4LGExamples"> 
					 <title><indexterm><primary>Examples</primary></indexterm><indexterm><primary>Domains</primary><secondary>Examples</secondary></indexterm>Examples</title>
					 
					 <para> <emphasis role="strong">Creating Domains</emphasis>
						  </para> 
					 <para>The following examples illustrate the use of the create
						  domain statement: 
						  <programlisting>create domain Date is { DateTime } 
{
	constraint DateValid value.TimePart().Ticks = 0,
	default Date(Today()),
	special	Unknown Date(DateTime(0))
};

create domain ShortID
{	
	representation ShortID { Value : String },
	constraint ShortID.Size Length(value.Value) &lt;= 3
		tags { DAE.Message = "ShortID values must be between 1 and 3 characters" }
} tags { DAE.StaticByteSize = "10" };

create domain Latitude is { Alpha }
{
	representation	Latitude
	{
		Latitude : Decimal
			read class  "LatitudeReadAccessor,MyAssembly"
			write class  "LatitudeWriteAccessor,MyAssembly"
 } class "LatitudeSelector,MyAssembly",
	representation Cartesian
	{
		Degrees : Integer	
			read class  "DegreesReadAccessor,MyAssembly"
			write class  "DegreesWriteAccessor,MyAssembly"
		Minutes : Integer
			read class  "MinutesReadAccessor,MyAssembly"
			write class  "MinutesWriteAccessor,MyAssembly"
		Seconds : Decimal
			read class  "SecondsReadAccessor,MyAssembly"
			write class  "SecondsWriteAccessor,MyAssembly"
	} class  "Cartesian,MyAssembly"
} class "LatitudeConveyor,MyAssembly";</programlisting> </para> 
					 <para>The following example illustrates the use of the alter
						  domain statement: 
						  <programlisting>alter domain Date
{
	alter default DateUnknown(),
	create special NotApplicable Date(DateTime(Days(1d)))
} alter tags { create	Frontend.Width = "10" };</programlisting> </para> 
					 <para>The following example illustrates the use of the drop
						  domain statement: 
						  <programlisting>drop domain Date; </programlisting> </para> 
				</sect3> 
		  </sect2> 
		  <sect2 id="D4LGTableVariables"> 
				<title><indexterm><primary>Table
								Variables</primary></indexterm><indexterm><primary>Catalog
								Elements</primary><secondary>Table Variables</secondary></indexterm>Table
					 Variables</title> 
				<para>Table variables are the only global variables in the catalog.
					 They represent the complete state of the database at any given point. There are
					 two types of table variables, base and derived. Base table variables in D4 are
					 called Tables, while derived table variables are called Views.</para> 
				<sect3 id="D4LGCommonCharacteristics"> 
					 <title><indexterm><primary>Common
									 Characteristics</primary></indexterm><indexterm><primary>Table
									 Variables</primary><secondary>Common
									 Characteristics</secondary></indexterm>Common Characteristics</title> 
					 <para>Table variables have several characteristics in common,
						  including keys, orders, constraints, and references. These characteristics
						  share common production rules in the grammar and so are discussed first.</para>
					 
					 <sect4 id="D4LGKeys"> 
						  <title><indexterm><primary>Keys</primary></indexterm><indexterm><primary>Common
										  Characteristics</primary><secondary>Keys</secondary></indexterm>Keys</title> 
						  <para>All table variables may have any number of associated
								keys. A <emphasis>key</emphasis> is a subset of the columns of a table variable
								that constitutes a unique identifier for any row in the table. In other words,
								no two rows in the table have the same values for all the columns of any key of
								the table. When a table variable is declared, the keys of the table variable
								may also be declared. For derived table variables, the keys specified are in
								addition to those already inferred by the compiler.</para> 
						  <para>Note that keys do not imply any ordering or indexing,
								they only declare a unique constraint for the table variable. This uniqueness
								provides the addressing mechanism for all tables.</para> 
						  <para>All tables must have at least one key. If no keys are
								specified in the table declaration, all columns will be used as a key. Note
								that a key is not required to have any columns. A key with no columns
								effectively means the table may only contain one row.</para> 
						  <para>Key definitions in D4 have the following syntax: 
								<programlisting>&lt;key definition&gt; ::=
	key "{"&lt;column name commalist&gt;"}" &lt;metadata&gt;

&lt;column name&gt; ::=
	&lt;qualified identifier&gt;</programlisting></para> 
						  <para>Alter key definitions in D4 have the following
								syntax: 
								<programlisting>&lt;alter key definition&gt; ::=
	create &lt;key definition&gt; |
	alter key "{"&lt;column name commalist&gt;"}" &lt;alter metadata&gt; |
	drop key "{"&lt;column name commalist&gt;"}"</programlisting></para> 
						  <para>Note that, as the alter syntax indicates, the columns
								in a key cannot be changed. The key must be dropped and re-created to effect a
								change of this type.</para> 
						  <para>As the syntax indicates, a key is not required to
								have any columns at all. In fact, the key with no columns is quite useful, in
								that it effectively restricts the table variable to one row.</para> 
					 </sect4> 
					 <sect4 id="D4LGOrders"> 
						  <title><indexterm><primary>Orders</primary></indexterm><indexterm><primary>Common
										  Characteristics</primary><secondary>Orders</secondary></indexterm>Orders</title>
						  
						  <para>All table variables may have any number of associated
								orders. An <emphasis>order</emphasis> is a possible ordering of the columns of
								a table. It is a kind of meta data that is used by consumers of data in the DAE
								and has no effect on the logical model. When a table variable is declared, the
								orders of the table variable may also be declared. For derived table variables,
								the orders specified are in addition to those already inferred by the
								compiler.</para> 
						  <para>Order definitions in D4 have the following syntax: 
								<programlisting>&lt;order definition&gt; ::=
	order "{"&lt;order column definition commalist&gt;"}" &lt;metadata&gt;
    
&lt;order column definition&gt; ::=
	&lt;column name&gt; [sort &lt;expression&gt;] [asc | desc]

&lt;column name&gt; ::=
	&lt;qualified identifier&gt;</programlisting></para> 
						  <para>Alter order definitions in D4 have the following
								syntax: 
								<programlisting>&lt;alter order definition&gt; ::=
	create &lt;order definition&gt; |
	alter order "{"&lt;order column definition commalist&gt;"}" &lt;alter metadata&gt; |
	drop order "{"&lt;order column definition commalist&gt;"}"</programlisting></para> 
						  <para>Note that, as the alter syntax indicates, the columns
								of an order cannot be changed. The order must be dropped and re-created to
								effect a change of this type.</para> 
						  <para>An order can consist of any subset of the columns of
								a table variable in any order. Each column can include an optional sort
								expression, and an optional ascending indicator.</para> 
						  <para>The sort expression allows the order to use an
								arbitrary condition for sorting. The sort expression must be integer-valued,
								functional and deterministic. The expression has access to the implicit
								variables <symbol>left.value</symbol> and <symbol>right.value</symbol>, which
								are the values to be compared. The expression must return -1 if
								<symbol>left.value</symbol> is less than <symbol>right.value</symbol>, 0 if the
								two values are equal, and 1 if <symbol>left.value</symbol> is greater than
								<symbol>right.value</symbol>.</para> 
						  <para>The optional ascending indicator specifies whether
								this column should be sorted ascending or descending. If no ascending indicator
								is specified, ascending is assumed.</para> 
					 </sect4> 
					 <sect4 id="D4LGRowConstraints"> 
						  <title><indexterm><primary>Row
										  Constraints</primary></indexterm><indexterm><primary>Common
										  Characteristics</primary><secondary>Row Constraints</secondary></indexterm>Row
								Constraints</title> 
						  <para>All table variables may have any number of row
								constraints associated with them. Each row constraint is validated whenever any
								insert or update is made against the table variable. If a constraint is
								violated, i.e. if the expression evaluates to false for any row, the name of
								the constraint is used to construct an error message. If present on the
								constraint, the metadata tag <symbol>DAE.Message</symbol> is also used to
								constructr the error message.</para> 
						  <para>Row constraint definitions in D4 have the following
								syntax: 
								<programlisting>&lt;constraint definition&gt; ::=
	constraint &lt;constraint name&gt; &lt;expression&gt; &lt;metadata&gt;
	
&lt;constraint name&gt; ::=
	&lt;qualified identifier&gt;</programlisting></para> 
						  <para>Alter row constraint definitions in D4 have the
								following syntax: 
								<programlisting>&lt;alter constraint definition&gt; ::=
	create &lt;constraint definition&gt; |
	alter constraint &lt;constraint name&gt; [&lt;expression&gt;] &lt;alter metadata&gt; |
	drop constraint &lt;constraint name&gt;</programlisting></para> 
						  <para>The constraint is required to be boolean-valued,
								functional and deterministic. The compiler enforces these requirements. Within
								the constraint expression, access to the columns of the row being validated is
								available by directly referencing the column names.</para> 
					 </sect4> 
					 <sect4 id="D4LGReferences"> 
						  <title><indexterm><primary>References</primary></indexterm><indexterm><primary>Common
										  Characteristics</primary><secondary>References</secondary></indexterm>References</title>
						  
						  <para>All table variables can participate in any number of
								reference constraints. These references are allowed to be declared within a
								table variable declaration for convenience. This mechanism is only shorthand
								for the equivalent reference constraint definition. For a complete description
								of references, refer to the References section in this guide.</para> 
						  <para>Reference definitions within table variable
								declarations in D4 have the following syntax: 
								<programlisting>&lt;reference definition&gt; ::=
	reference &lt;reference name&gt; 
	"{"&lt;column name commalist&gt;"}" 
	&lt;references definition&gt;
	&lt;metadata&gt;
	
&lt;reference name&gt; ::=
	&lt;qualified identifier&gt;</programlisting>Alter reference definitions within table variable declarations
								in D4 have the following syntax: 
								<programlisting>&lt;alter reference definition&gt; ::=
	create &lt;reference definition&gt; |
	alter reference &lt;reference name&gt; &lt;alter metadata&gt;
	drop &lt;reference name&gt;</programlisting></para> 
						  <para>For a complete description of the
								<emphasis>references definition</emphasis> production rule, refer to the
								References section in this guide.</para> 
					 </sect4> 
				</sect3> 
				<sect3 id="D4LGTables"> 
					 <title><indexterm><primary>Tables</primary></indexterm><indexterm><primary>Table
									 Variables</primary><secondary>Tables</secondary></indexterm>Tables</title> 
					 <para>Tables are base relation variables, that is, they
						  represent sets of unordered rows, where each row contains a value for each of
						  the columns defined by the table header. A table (variable) is the fundamental
						  unit of data persistence in the catalog. Tables, combined with views, provide
						  the mechanism for describing the data that is available in the business model.
						  Tables are defined in terms of the columns they contain.</para> 
					 <para>The create table statement in D4 has the following
						  syntax: 
						  <programlisting>&lt;create table statement&gt; ::=
	create table &lt;table name&gt;
	[in &lt;device name&gt;]
	"{"&lt;table definition item commalist&gt;"}" 
	&lt;metadata&gt;
    
&lt;table name&gt; ::=
	&lt;qualified identifier&gt;
	
&lt;device name&gt; ::=
	&lt;qualified identifier&gt;

&lt;table definition item&gt; ::=
	&lt;column definition&gt; |
 &lt;constraint definition&gt; |
	&lt;key definition&gt; |
 &lt;reference definition&gt; |
	&lt;order definition&gt;</programlisting></para> 
					 <para>The alter table statement in D4 has the following syntax:
						  
						  <programlisting>&lt;alter table statement&gt; ::=
	alter table &lt;table name&gt; 
		["{"&lt;alter table definition item commalist&gt;"}"]
		&lt;alter metadata&gt;

&lt;alter table definition item&gt; ::=
	&lt;alter column definition&gt; |
	&lt;alter constraint definition&gt; |
	&lt;alter key definition&gt; |
	&lt;alter reference definition&gt; |
	&lt;alter order definition&gt;</programlisting></para> 
					 <para>The drop table statement in D4 has the following syntax: 
						  <programlisting>&lt;drop table statement&gt; ::=
	drop table &lt;table name&gt;</programlisting></para> 
					 <para>This statement creates, alters, or drops a base table
						  variable named <emphasis>&lt;table name&gt;</emphasis> in the catalog.</para> 
					 <para>The create table statement includes an optional
						  <emphasis>in device name</emphasis> clause which indicates that the table is
						  persisted in the specified device. If no device is specified, the compiler will
						  use the default device for the table variable. The default device is determined
						  by the <symbol>DefaultDeviceName</symbol> session setting. If no default device
						  name is specified for the session, the compiler will select the
						  <symbol>System.Temp</symbol> memory device as the default device. For more
						  information on how the DAE maps table variables and operators into devices, see
						  the Using Devices discussion in the Programming Topics section of this Guide,
						  and the Storage Integration Architecture chapter in Part II of this
						  manual.</para> 
					 <para>For a description of the <emphasis>key
						  definition</emphasis>, <emphasis>order definition</emphasis>,
						  <emphasis>constraint definition</emphasis>, and <emphasis>reference
						  definition</emphasis> production rules, see the Common Characteristics
						  section.</para> 
					 <sect4 id="D4LGColumns"> 
						  <title><indexterm><primary>Columns</primary></indexterm><indexterm><primary>Tables</primary><secondary>Columns</secondary></indexterm>Columns</title>
						  
						  <para>Base table variables are defined in terms of the
								columns, or attributes, that make up the table structure. Each column has a
								name that is unique within the table variable, a data type which describes the
								legal values for this column, and possibly a default and column
								constraints.</para> 
						  <para>Note that a table variable need not have any columns
								at all. There are exactly two table values with no columns: 
								<itemizedlist> 
									 <listitem> 
										  <para><symbol>table { }</symbol></para> 
										  <para>The table value with no columns and no
												rows. The system table <symbol>System.TableDum</symbol> is a shorthand for this
												table selector.</para> 
									 </listitem> 
									 <listitem> 
										  <para><symbol>table { row { } }</symbol></para>
										  
										  <para>The table value with no columns and one
												row. The system table <symbol>System.TableDee</symbol> is a shorthand for this
												table selector.</para> 
									 </listitem> 
								</itemizedlist></para> 
						  <para>Column definitions within base table variable
								declarations in D4 have the following syntax: 
								<programlisting>&lt;column definition&gt; ::=
	&lt;column name&gt; : &lt;type specifier&gt;
		["{"&lt;ne column definition item commalist&gt;"}"
		&lt;metadata&gt;
		
&lt;column definition item&gt; ::=
	&lt;default definition&gt; |
	&lt;constraint definition&gt;
    
&lt;column name&gt; ::=
	&lt;qualified identifier&gt;
	
&lt;domain name&gt; ::=
	&lt;qualified identifier&gt;</programlisting></para> 
						  <sect5 id="D4LGColumnDefault"> 
								<title><indexterm><primary>Column
												Default</primary></indexterm><indexterm><primary>Columns</primary><secondary>Column
												Default</secondary></indexterm>Column Default</title> 
								<para>Each column in a table variable may have an
									 associated default which is used to provide a value for the column if no value
									 is specified through a given modification statement. A column level default
									 will effectively override a domain level default.</para> 
								<para>Column default definitions in D4 have the
									 following syntax: 
									 <programlisting>&lt;default definition&gt; ::=
	default &lt;expression&gt; &lt;metadata&gt;

&lt;alter default definition&gt; ::=
	create &lt;default definition&gt; |
	alter default [&lt;expression&gt;] &lt;alter metadata&gt; |
	drop default</programlisting></para> 
						  </sect5> 
						  <sect5 id="D4LGColumnConstraints"> 
								<title><indexterm><primary>Column
												Constraints</primary></indexterm><indexterm><primary>Columns</primary><secondary>Column
												Constraints</secondary></indexterm>Column Constraints</title> 
								<para>Each column in a table variable may have any
									 number of associated column constraints which are used to validate the data in
									 any given data modification statement. Note that a column constraint is merely
									 a special case of a row constraint, which is in turn a special case of a
									 database-wide integrity constraint. When a data modification is attempted which
									 causes the expression to evaluate to false, the modification is rejected and an
									 error is raised. The name of the constraint is used to construct the error
									 message. If present, the metadata tag <symbol>DAE.Message</symbol> is also
									 given in the error message.</para> 
								<para>Column constraints are validated in addition to
									 domain level constraints.</para> 
								<para>Column constraint definitions in D4 have the
									 following syntax: 
									 <programlisting>&lt;constraint definition&gt; ::=
	constraint &lt;constraint name&gt; &lt;expression&gt; &lt;metadata&gt;
	
&lt;constraint name&gt; ::=
	&lt;qualified identifier&gt;</programlisting></para> 
								<para>Alter column constraint definitions in D4 have
									 the following syntax: 
									 <programlisting>&lt;alter constraint definition&gt; ::=
	create &lt;constraint definition&gt; |
	alter constraint &lt;constraint name&gt; [&lt;expression&gt;] &lt;alter metadata&gt; |
	drop constraint &lt;constraint name&gt;</programlisting></para> 
								<para>The constraint expression must be boolean-valued,
									 functional and deterministic. The compiler enforces these requirements. Within
									 the constraint expression, the implicit variable <symbol>value</symbol> is
									 available which represents the value being validated.</para> 
						  </sect5> 
					 </sect4> 
					 <sect4 id="D4LGExamples1"> 
						  <title><indexterm><primary>Examples</primary></indexterm><indexterm><primary>Tables</primary><secondary>Examples</secondary></indexterm>Examples</title>
						  
						  <para>The following examples illustrate the use of the
								create table statement: 
								<programlisting>create table Customer
{
	ID : Integer,
	Name : String,
	IsHappy : Boolean,
	key { ID }
};

create table Customer.Phone in Temp
{
	Customer_ID : Integer,
	PhoneType_ID : Integer { default 1 },
	PhoneID : Integer { default GetNextGenerator("PhoneID") },
	PhoneNumber : String
	{	
		constraint PhoneLength Length(value) &gt;= 7
			tags { DAE.Message = "Phone Number must be	at least 7 characters" }
	} tags { Frontend.Title = "Phone Number" },
	key  { Customer_ID, PhoneType_ID },
	reference PhoneCustomer { Customer_ID } references Customer { ID }
} tags { Frontend.Title = "Customer Phone" };</programlisting> </para> 
						  <para>The following example illustrates the use of the
								alter table statement: 
								<programlisting>alter table Customer.Phone
{
	create column IsInternational : Boolean,
	create order { PhoneNumber, PhoneType_ID }
} alter tags { alter Frontend.Title = "Customer Phone #" };</programlisting> </para> 
						  <para>The following example illustrates the use of the drop
								table statement: 
								<programlisting>drop table Customer.Phone;</programlisting> </para> 
					 </sect4> 
				</sect3> 
				<sect3 id="D4LGViews"> 
					 <title><indexterm><primary>Views</primary></indexterm><indexterm><primary>Table
									 Variables</primary><secondary>Views</secondary></indexterm>Views</title> 
					 <para>Views are derived relation variables, that is, they are
						  tables in the catalog that are defined in terms of an expression against other
						  tables or views.</para> 
					 <para>Views can be modified with DML statements so long as the
						  post-modification data satisfies the predicate of the view. The predicate of
						  the view is, loosely speaking, the net expression, after accounting for keys,
						  references, and constraints. See the Table Expressions section for a discussion
						  of updatability semantics for each operator.</para> 
					 <para>The create view statement in D4 has the following syntax:
						  
						  <programlisting>&lt;create view statement&gt; ::= 
	create view &lt;view name&gt; &lt;expression&gt; 
		["{"&lt;ne view definition item commalist&gt;"}"] &lt;metadata&gt;
    
&lt;view name&gt; ::=
	&lt;qualified identifier&gt;

&lt;view definition item&gt; ::=
	&lt;constraint definition&gt; |
	&lt;key definition&gt; |
	&lt;reference definition&gt; |
	&lt;order definition&gt;</programlisting></para> 
					 <para>The alter view statement in D4 has the following syntax: 
						  <programlisting>&lt;alter view statement&gt; ::=
	alter view &lt;view name&gt; 
		["{"&lt;alter view definition item commalist&gt;"}"
		&lt;alter metadata&gt;

&lt;alter view definition item&gt; ::=
	&lt;alter constraint definition&gt; |
	&lt;alter key definition&gt; |
	&lt;alter reference definition&gt; |
	&lt;alter order definition&gt;</programlisting></para> 
					 <para>The drop view statement in D4 has the following syntax: 
						  <programlisting>&lt;drop view statement&gt; ::=
	drop view &lt;view name&gt;</programlisting></para> 
					 <para>These statements create, alter, and drop a view named
						  <emphasis>view name</emphasis> in the catalog.</para> 
					 <para>For a description of the <emphasis>key
						  definition</emphasis>, <emphasis>order definition</emphasis>,
						  <emphasis>constraint definition</emphasis>, and <emphasis>reference
						  definition</emphasis> production rules, see the Common Characteristics
						  section.</para> 
					 <para>Constraints and keys included in the definition of a view
						  become part of the definition of the view. For example, if a constraint is
						  included in the view declaration, it becomes a restriction in the view
						  definition. Note that the base table remains unaffected by this constraint, the
						  view simply excludes rows that violate the constraint, and a row that violates
						  the constraint cannot be inserted into the view, but can be inserted into the
						  base table.</para> 
					 <para>The following examples illustrate the use of the create
						  view statement: 
						  <programlisting>create view HappyDog 
	Dog where Bones &gt; 15;

create view Labrador
	Dog 
	{ 
		constraint OnlyLabs	Species = "Lab"
	} tags { Frontend.Title = "Labs" };</programlisting> </para> 
					 <para>The following example illustrates the use of the alter
						  view statement to add a reference from a view: 
						  <programlisting>alter view HappyDog { create reference HappyDog_Rainbow { Color } 
		references Rainbow { Color } };</programlisting> </para> 
					 <para>The following example illustrates the use of the drop
						  view statement: 
						  <programlisting>drop view HappyDog;</programlisting> </para> 
				</sect3> 
		  </sect2> 
		  <sect2 id="D4LGConstraints"> 
				<title><indexterm><primary>Constraints</primary></indexterm><indexterm><primary>Catalog
								Elements</primary><secondary>Constraints</secondary></indexterm>Constraints</title>
				
				<para>A <emphasis>constraint</emphasis> is a named boolean-valued
					 expression that must evaluate to true. If a data manipulation is attempted
					 which would violate the constraint, the modification is rejected. The name of
					 the constraint is used to contruct an error message when the constraint is
					 violated. If present in the meta data for the constraint, the tag
					 <symbol>DAE.Message</symbol> is also used to construct the error
					 message.</para> 
				<para>The create constraint statement in D4 has the following
					 syntax: 
					 <programlisting>&lt;create constraint statement&gt; ::=
	create constraint &lt;constraint name&gt; &lt;expression&gt; &lt;metadata&gt;
	
&lt;constraint name&gt; ::=
	&lt;qualified identifier&gt;</programlisting></para> 
				<para>The alter constraint statement in D4 has the following
					 syntax: 
					 <programlisting>&lt;alter constraint statement&gt; ::=
	alter constraint &lt;constraint name&gt; [&lt;expression&gt;] &lt;alter metadata&gt;</programlisting></para> 
				<para>The drop constraint statement in D4 has the following syntax:
					 
					 <programlisting>&lt;drop constraint statement&gt; ::=
	drop constraint &lt;constraint name&gt;</programlisting></para> 
				<para>These statements create, alter, and drop a constraint named
					 <emphasis>constraint name</emphasis> in the catalog.</para> 
				<para>The constraint expression is required to be boolean-valued,
					 functional, and deterministic. The compiler enforces these requirements.</para>
				
				<para>The following example illustrates the use of the create
					 constraint statement. The given constraint enforces that all cats have at least
					 one life: 
					 <programlisting>create constraint LivingCats
	not exists 
	( 
		(Cat where IsAlive) join 
		((Life group by { Cat_ID, ID } add { Count() Lives }) where Lives = 0) 
	);</programlisting> </para> 
				<para>The following example illustrates the use of the alter
					 constraint statement. The new constraint enforces that all cats have at most
					 nine lives: 
					 <programlisting>alter constraint LivingCats
	not exists ((Life group by { Cat_ID } add { Count() Lives }) where Lives &gt; 9);</programlisting> </para> 
				<para>The following example illustrates the use of the drop
					 constraint statement: 
					 <programlisting>drop constraint LivingCats;</programlisting> </para> 
		  </sect2> 
		  <sect2 id="D4LGReferences1"> 
				<title><indexterm><primary>References</primary></indexterm><indexterm><primary>Catalog
								Elements</primary><secondary>References</secondary></indexterm>References</title>
				
				<para>A <emphasis>reference</emphasis> is a special case of a
					 database-wide integrity constraint. A reference constraint enforces
					 <emphasis>referential integrity</emphasis>. In other words, if a reference
					 constraint is defined from a table variable <symbol>Source</symbol> to a table
					 variable <symbol>Target</symbol>, then if a row appears in
					 <symbol>Source</symbol>, it must have a matching row in
					 <symbol>Target</symbol>. A reference constraint is considered satisfied if all
					 the values of the reference columns of the row in <symbol>Source</symbol> are
					 specials. The equivalent database-wide integrity constraint for a given
					 reference constraint is then: 
					 <programlisting>// Reference constraint from Source(SourceColumn) to Target(TargetColumn)
create constraint C 
	not exists 
	(
		(Source where not(IsSpecial(SourceColumn)) over { SourceColumn }) minus 
		(Target over { TargetColumn } rename { TargetColumn SourceColumn })
	);</programlisting></para> 
				<para>References may also include specifications for actions to be
					 taken when updates or deletes are made to the target table of the reference.
					 The following list summarizes these actions: 
					 <itemizedlist> 
						  <listitem> 
								<para>Require</para> 
								<para>The require action indicates that the update or
									 delete should be rejected if there are rows in the source table which reference
									 the rows being modified. If no action is specified, this is the default.</para>
								
						  </listitem> 
						  <listitem> 
								<para>Cascade</para> 
								<para>The cascade action indicates that the update or
									 delete should be cascaded to the rows of the source table which reference the
									 rows being modified. If the modification is an update, all rows referencing the
									 old value are updated to reference the new value. If the modification is a
									 delete, all rows referencing the deleted value are deleted.</para> 
						  </listitem> 
						  <listitem> 
								<para>Clear</para> 
								<para>The clear action indicates that rows in the
									 source table which reference the rows being modified should be set to the
									 special value for the domain of the column. The domains for each column must
									 have one and only one special defined in order to use this update
									 action.</para> 
						  </listitem> 
						  <listitem> 
								<para>Set</para> 
								<para>The set action indicates that rows in the source
									 table which reference the rows being modified should be set to the given
									 expressions. Note that the values specified for these expressions must also
									 satisfy the reference constraint.</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>The create reference statement in D4 has the following
					 syntax: 
					 <programlisting>&lt;create reference statement&gt; ::=
	create reference &lt;reference name&gt;
		&lt;tablevar name&gt; "{"&lt;column name commalist&gt;"}" 
		&lt;references definition&gt;
		&lt;metadata&gt;

&lt;reference name&gt; ::=
	&lt;qualified identifier&gt;

&lt;tablevar name&gt; ::=
	&lt;qualified identifier&gt;

&lt;column name&gt; ::=
	&lt;qualified identifier&gt;

&lt;references definition&gt; ::=
	references &lt;tablevar name&gt; "{"&lt;column name commalist&gt;"}" 
	[update (require | cascade | clear | set "{"&lt;expression commalist&gt;"}")] 
	[delete (require | cascade | clear | set "{"&lt;expression commalist&gt;"}")]</programlisting></para> 
				<para>The alter reference statement in D4 has the following syntax:
					 
					 <programlisting>&lt;alter reference statement&gt; ::=
	alter reference &lt;reference name&gt; &lt;alter metadata&gt;</programlisting></para> 
				<para>The drop reference statement in D4 has the following syntax: 
					 <programlisting>&lt;drop reference statement&gt; ::=
	drop reference &lt;reference name&gt;</programlisting></para> 
				<para>These statements create, alter, and drop a reference named
					 <emphasis>reference name</emphasis> in the catalog.</para> 
				<para>The target column names of a reference must form a key in the
					 target table. The source column names of a reference may or may not form a key
					 in the source table. This means there are two combinations for references,
					 key-to-key references, and key-to-non-key references. Depending on whether a
					 reference is viewed from the source or target table variable, this gives rise
					 to four distinct types of references: 
					 <itemizedlist> 
						  <listitem> 
								<para>Extension</para> 
								<para>An extension reference is one for which the
									 columns of the reference form a key in both the source and target tables, and
									 the reference is viewed from the target table. This is a one-to-zero-or-one
									 relationship.</para> 
						  </listitem> 
						  <listitem> 
								<para>Parent</para> 
								<para>A parent reference is one for which the columns
									 of the reference form a key in both the source and target tables, and the
									 reference is viewed from the source table. This is a one-to-one
									 relationship.</para> 
						  </listitem> 
						  <listitem> 
								<para>Detail</para> 
								<para>A detail reference is one for which the columns
									 of the reference form a key in the target table, but not the source table, and
									 the reference is viewed from the target table. This is a one-to-many
									 relationship.</para> 
						  </listitem> 
						  <listitem> 
								<para>Lookup</para> 
								<para>A lookup reference is one for which the columns
									 of the reference form a key in the target table, but not the source table, and
									 the reference is viewed from the source table. This is a one-to-one
									 relationship.</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>This and other information is used by the Dataphor Frontend
					 to determine how best to present and manipulate the data model. The Frontend
					 dynamically derives the appropriate interface based on the relationships
					 described by references.</para> 
				<para>References are also derived for table expressions through a
					 process called <emphasis>reference inference</emphasis>. This process is part
					 of <emphasis>type inference</emphasis> and means that not only are references
					 known for the table variables on which they are declared, but expressions that
					 reference those table variables as well. This process becomes exteremely
					 important when a general solution to the problem of user-interface derivation
					 is approached. The solution provided by the DAE through reference inference is
					 one of the main reasons for the advanced user-interface derivation capabilities
					 of the Frontend.</para> 
				<para>The following example creates a referential integrity
					 constraint between the <symbol>Dog</symbol> and <symbol>Owner</symbol> tables.
					 This constraint ensures that there can be no row in the <symbol>Dog</symbol>
					 table for which the value in the <symbol>Owner_ID</symbol> column does not
					 appear in the <symbol>ID</symbol> column of the <symbol>Owner</symbol> table. 
					 <programlisting>create reference Dog_Owner Dog { Owner_ID } references	Owner { ID };</programlisting> </para> 
				<para>The following example alters the metadata of the
					 <symbol>Dog_Owner</symbol> reference. Only the metadata of a reference may be
					 altered. In order to change another aspect of the reference constraint, it must
					 be dropped and re-created. 
					 <programlisting>alter reference Dog_Owner
	alter comment = "Dog - Dog Owners" tags { create Frontend.Exposed = "true" };</programlisting> </para> 
				<para>The following examples drop the <symbol>Dog_Owner</symbol>
					 reference: 
					 <programlisting>// drop the constraint using the drop reference syntax
drop reference Dog_Owner; 

// drop the constraint by altering the source table variable
alter table Dog { drop reference Dog_Owner }; </programlisting> </para> 
		  </sect2> 
		  <sect2 id="D4LGOperators1"> 
				<title><indexterm><primary>Operators</primary></indexterm><indexterm><primary>Catalog
								Elements</primary><secondary>Operators</secondary></indexterm>Operators</title>
				
				<para>An <emphasis>operator</emphasis> is a pre-compiled chunk of
					 D4 code which optionally takes as operands a list of values, also called
					 <emphasis>inputs</emphasis>, and optionally returns a value of some type, also
					 called <emphasis>output</emphasis>. For a description of operators as a
					 language element in D4, refer to the Operators section of the Language Elements
					 section of this guide.</para> 
				<para>Each operator is allowed to take any number of
					 <emphasis>operands</emphasis>. Each operand must have a unique name, and a data
					 type. Each operand is available within the block of the operator as a variable
					 with the same name and data type of the operand. Additionally, each operand
					 includes a <emphasis>modifier</emphasis> which tells the compiler how to handle
					 values passed as the argument for this operand. The following table lists the
					 available modifiers: 
					 <itemizedlist> 
						  <listitem> 
								<para><symbol>in</symbol></para> 
								<para>Indicates that the value passed as an argument to
									 this operand is copied into the variable representing this operand. This is
									 known as <emphasis>pass-by-value</emphasis>. If no modifier is specified for
									 the operand, the operand is initially marked <symbol>in</symbol> as a default.
									 This may change, as described in the next modifier.</para> 
						  </listitem> 
						  <listitem> 
								<para><symbol>const</symbol></para> 
								<para>Indicates that the variable representing this
									 operand may not be assigned to within the operator block. This is known as
									 <emphasis>pass-by-reference</emphasis> with the added restriction that the
									 variable is read only. If the compiler detects that the variable for a given
									 operand is unaffected within the operator block, it will automatically mark the
									 operand <symbol>const</symbol> as an optimization.</para> 
						  </listitem> 
						  <listitem> 
								<para><symbol>var</symbol></para> 
								<para>Indicates that only variables may be passed as
									 arguments to this operand, and that the affects of assignment to the variable
									 representing this operand within the operator block will affect the variable
									 passed as the argument. This is known as
									 <emphasis>pass-by-reference</emphasis>. If an operand is marked
									 <symbol>var</symbol>, the argument in a call must also be marked
									 <symbol>var</symbol> in order to be passed to the operand. In other words, the
									 modifier is part of the signature of the operator and affects the operator
									 resolution process.</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>There are two types of operators in D4, standard operators,
					 and aggregate operators. Aggregate operators are special-purpose operators
					 which have certain restrictions on the operands and return values allowed in
					 the signature, and a specialized calling convention which allows them to be
					 used efficiently within aggregate operations in D4.</para> 
				<sect3 id="D4LGOperators2"> 
					 <title><indexterm><primary>Operators</primary></indexterm><indexterm><primary>Operators</primary><secondary>Operators</secondary></indexterm>Operators</title>
					 
					 <para>The create operator statement in D4 has the following
						  syntax: 
						  <programlisting>&lt;create operator statement&gt; ::=
	create operator
		&lt;operator name&gt;
		"("&lt;formal parameter commalist&gt;")"
		[: &lt;type specifier&gt;]
		(&lt;class definition&gt; | &lt;block&gt;)
		&lt;metadata&gt;
		
&lt;operator name&gt; ::=
	&lt;qualified identifier&gt;

&lt;formal parameter&gt; ::=
	[&lt;modifier&gt;] &lt;named type specifier&gt;

&lt;modifier&gt; ::=
	[var | const]

&lt;named type specifier&gt; ::=
	&lt;qualified identifier&gt; : &lt;type specifier&gt;</programlisting></para> 
					 <para>The alter operator statement in D4 has the following
						  syntax: 
						  <programlisting>&lt;alter operator statement&gt; ::=
	alter operator &lt;operator name&gt;"("&lt;formal parameter specifier commalist&gt;")"
		[(&lt;alter class definition&gt; | &lt;block&gt;)]
		&lt;alter metadata&gt;

&lt;formal parameter specifier&gt; ::=
	[&lt;modifier&gt;] &lt;type specifier&gt;</programlisting></para> 
					 <para>The drop operator statement in D4 has the following
						  syntax: 
						  <programlisting>&lt;drop operator statement&gt; ::=
	drop operator &lt;operator name&gt;"("&lt;formal parameter specifier commalist&gt;")"</programlisting></para> 
					 <para>These statements create, alter, and drop an operator
						  named <emphasis>operator name</emphasis> with operands given by
						  <emphasis>formal parameter specifier commalist</emphasis> in the catalog. The
						  operator optionally returns a value of the type given by <emphasis>type
						  specifier</emphasis>. The implementation of the operator is specified by either
						  the <emphasis>class definition</emphasis>, in which case the operator is a
						  <emphasis>host-implemented</emphasis> operator, or the
						  <emphasis>block</emphasis>, in which case the operator is a chunk of compiled
						  D4 statements. </para> 
					 <para>For a complete description of host-implemented operators,
						  refer to Part III of this manual. </para> 
					 <para>For a complete description of the
						  <emphasis>block</emphasis> production rule, refer to the Imperative Statements
						  section of this guide.</para> 
					 <para>The following example illustrates the use of the create
						  operator statement: 
						  <programlisting>create operator Add(A : Integer, B : Integer) : Integer
begin
	result := A + B;
end; </programlisting></para> 
					 <para>The following example illustrates the use of the alter
						  operator statement: 
						  <programlisting>alter operator Add(A : Integer, B : Integer) : Integer
begin
	var I : Integer;
	result := A;
	for I := 1 to B do
		result := result + 1;
	for I := -1 downto B do
		result := result - 1;
end; </programlisting></para> 
					 <para>The following example illustrates the use of the drop
						  operator statement: 
						  <programlisting>drop operator Add(Integer, Integer);</programlisting> </para> 
				</sect3> 
				<sect3 id="D4LGAggregateOperators"> 
					 <title><indexterm><primary>Aggregate
									 Operators</primary></indexterm><indexterm><primary>Operators</primary><secondary>Aggregate
									 Operators</secondary></indexterm>Aggregate Operators</title> 
					 <para>Aggregate operators make use of a specialized calling
						  convention which can be used efficiently by aggregation in the DAE. An
						  aggregate operator must either take no operands, or only one operand. If an
						  operand is defined it must not be marked with a modifier and the data type of
						  the operand must correspond to the type of the values to be aggregated. The
						  operator must return a value of some type, not necessarily the same type as the
						  operand. For example, a <symbol>Sum</symbol> aggregate operator for integers
						  must have the heading: 
						  <programlisting>aggregate operator Sum(AValue : System.Integer) : System.Integer</programlisting></para> 
					 <para>Aggregate operators have three blocks,
						  <emphasis>initialization</emphasis>, <emphasis>finalization</emphasis>, and
						  <emphasis>aggregation</emphasis>. Each section is allowed to be a
						  host-implemented operator, or a D4 statement block.</para> 
					 <para>The initialization section is called once before
						  aggregation begins. This allows the operator to set up any local variables that
						  will be used to compute the aggregation.</para> 
					 <para>The aggregation section is called once for each row in
						  the table value being aggregated. The value for the target aggregation column
						  for the row is available in this section as the value of the variable
						  representing the single operand defined for the aggregate operator.</para> 
					 <para>The finalization section is called once after all the
						  rows have been processed by the aggregation section. This allows the operator
						  to perform any final computations required to compute the aggregate.</para> 
					 <para>The create aggregate operator statement in D4 has the
						  following syntax: 
						  <programlisting>&lt;create aggregate operator statement&gt; ::=
	create aggregate operator
		&lt;operator name&gt;
		"("[&lt;named type specifier&gt;]")"
		: &lt;type specifier&gt;
		initialization (&lt;class definition&gt; | &lt;block&gt;)
		aggregation (&lt;class definition&gt; | &lt;block&gt;)
		finalization (&lt;class definition&gt; | &lt;block&gt;)
		&lt;metadata&gt;

&lt;operator name&gt; ::=
	&lt;qualified identifier&gt;

&lt;named type specifier&gt; ::=
	&lt;qualified identifier&gt; : &lt;type specifier&gt;</programlisting></para> 
					 <para>The alter aggregate operator statement in D4 has the
						  following syntax: 
						  <programlisting>&lt;alter aggregate operator statement&gt; ::=
	alter aggregate operator &lt;operator name&gt;"("&lt;formal parameter specifier commalist&gt;")"
		[initialization (&lt;alter class definition&gt; | &lt;block&gt;)]
		[aggregation (&lt;alter class definition&gt; | &lt;block&gt;)]
		[finalization (&lt;alter class definition&gt; | &lt;block&gt;)]
		&lt;alter metadata&gt;

&lt;formal parameter specifier&gt; ::=
	[&lt;modifier&gt;] &lt;type specifier&gt;</programlisting></para> 
					 <para>The drop aggregate operator statement in D4 has the
						  following syntax: 
						  <programlisting>&lt;drop aggregate operator statement&gt; ::=
	drop aggregate operator &lt;operator name&gt;"("&lt;formal parameter specifier commalist&gt;")"</programlisting></para> 
					 <para>These statements create, alter, and drop an aggregate
						  operator named <emphasis>operator name</emphasis> with operands given by
						  <emphasis>formal parameter specifier commalist</emphasis> in the catalog. The
						  aggregate operator must return a value of the type given by <emphasis>type
						  specifier</emphasis>. The implementation of each section is specified by either
						  the <emphasis>class definition</emphasis> in which case the section is
						  <emphasis>host-implemented</emphasis>, or the <emphasis>block</emphasis>, in
						  which case the section is a chunk of compiled D4 statements.</para> 
					 <para>For a complete description of host-implemented operators,
						  refer to Part II of this manual.</para> 
					 <para>For a complete description of the
						  <emphasis>block</emphasis> production rule, refer to the Imperative Statements
						  section of this guide.</para> 
					 <para>Outside the context of a <symbol>group</symbol> operator,
						  aggregate operators must be called by using a column extractor from a table
						  variable as the argument to the operator. For example, to compute the sum of
						  the values for a column <symbol>Data</symbol> of some table
						  <symbol>Integers</symbol>, the following expression would be used: 
						  <programlisting>Sum(Data from Integers)</programlisting></para> 
					 <para>Note that the expression <symbol>Data from
						  Integers</symbol> is invalid outside the context of an aggregate invocation
						  because a column cannot be directly extracted from a table, only a row. The
						  aggregate operator is resolved based on the type of the column being
						  aggregated. If the operator resolved is not an aggregate operator, the compiler
						  will raise an error.</para> 
					 <para>The following example creats an aggregate operator, and
						  uses it in some simple aggregate expressions: 
						  <programlisting>// aggregate operators
create aggregate operator StdDev(AValue : Decimal) : Decimal
	initialization
		begin
			var LSum : Decimal := 0d;
			var LSumOfSquares : Decimal := 0d;
			var LCount : Integer := 0;
			result := 0d;
		end
	aggregation
		begin
			LSum := LSum + AValue;
			LSumOfSquares := LSumOfSquares + (AValue ** 2d);
			LCount := LCount + 1;
		end
	finalization
		begin
			result := 
				(
					(
						(LSumOfSquares - ((LSum ** 2d) / ToDecimal(LCount))) / 
						ToDecimal(LCount - 1)
					) ** 
					0.5d
				);
		end;
		
// Invocation through the table aggregate operator
select
	table { row { 0.1d DecimalValue }, 
		row { 0.2d }, row { 0.3d }, 
		row { 0.4d }, row { 0.5d } }
		group add { StdDev(DecimalValue) Value_StdDev };

// Stand-alone invocation
select table { row { StdDev(DecimalValue from table 
	{ row { 0.1d DecimalValue }, 
	row { 0.2d } }) Value_StdDev } };</programlisting></para> 
				</sect3> 
		  </sect2> 
		  <sect2 id="D4LGDevices"> 
				<title><indexterm><primary>Devices</primary></indexterm><indexterm><primary>Catalog
								Elements</primary><secondary>Devices</secondary></indexterm>Devices</title> 
				<para>All data storage in the DAE is abstracted through the concept
					 of a Device. The DAE not only uses devices to store data, it also offloads any
					 query processing that is supported by the device. Because each data source is
					 capable of different types of data manipulation, the internal device interface
					 provides a mechanism for dynamically determining these capabilities for any
					 given expression. The DAE then uses this information to distribute query
					 processing among the different devices involved in the request. When the device
					 on which the data resides cannot perform a particular operation, the DAE takes
					 over and performs the query processing internally. The result is seamless
					 access to disparate data sources.</para> 
				<para>The storage systems represented by each device have their own
					 internal catalog, which must be synchronized with the DAE in order to be
					 utilized within D4. This process is known as <emphasis>schema
					 reconciliation</emphasis>. Settings on each device control how this process
					 occurs. For a complete description of the reconciliation process and the
					 affects of each setting on it, refer to the Using Devices discussion in the
					 Programming Topics section of this guide.</para> 
				<para>Each device may have any number of associated type and
					 operator mappings which control how catalog objects in the DAE map into the
					 device. For information on how this process occurs in general, refer to the
					 Using Devices discussion in the Programming Topics section of this guide. For
					 information on how to extend this architecture, refer to the Storage
					 Integration Architecture chapter in Part II of this manual.</para> 
				<para>Each device may also have a mapping for each user in the DAE
					 called a <emphasis>device user</emphasis>. This mapping contains the
					 credentials to be used when communicating with the storage system represented
					 by the device, as well as any user-specific settings for the device. These
					 mappings are created through the use of system library operators. For a
					 complete description of device users, refer to the Using Devices discussion in
					 the Programming Topics section of this guide.</para> 
				<para>The create device statement in D4 has the following syntax: 
					 <programlisting>&lt;create device statement&gt; ::=
	create device &lt;device name&gt;
		["{"&lt;device map item commalist&gt;"}"]
		&lt;reconciliation settings&gt;
		&lt;class definition&gt;
		&lt;metadata&gt;

&lt;device name&gt; ::=
	&lt;qualified identifier&gt;
		
&lt;device map item&gt; ::=
	&lt;device domain map&gt; |
	&lt;device operator map&gt;

&lt;device domain map&gt; ::=
	domain &lt;domain name&gt; &lt;class definition&gt;

&lt;domain name&gt; ::=
	&lt;qualified identifier&gt;
&lt;device operator map&gt; ::=
	operator &lt;operator specifier&gt; &lt;class definition&gt;

&lt;operator specifier&gt; ::=
	&lt;operator name&gt;"("&lt;formal parameter specifier commalist&gt;")"

&lt;reconciliation settings&gt; ::=
	[reconciliation "{"&lt;reconciliation settings item commalist&gt;"}"]
	
&lt;reconciliation settings item&gt; ::=
	&lt;reconciliation mode definition&gt; |
	&lt;reconciliation master&gt;
	
&lt;reconciliation mode definition&gt; ::=
	mode = "{"&lt;reconciliation mode commalist&gt;"}"
	
&lt;reconciliation mode&gt; ::=
	none |
	startup |
	command |
	automatic
	
&lt;reconciliation master&gt; ::=
	master = (server | device | both)</programlisting></para> 
				<para>The alter device statement in D4 has the following syntax: 
					 <programlisting>&lt;alter device statement&gt; ::=
	alter device &lt;device name&gt; 
		["{"&lt;alter device map item commalist&gt;"}"]
		&lt;alter reconciliation settings&gt;
		&lt;alter class definition&gt; 
		&lt;alter metadata&gt;

&lt;alter reconciliation settings&gt; ::=
	[alter reconciliation "{"&lt;reconciliation settings item commalist&gt;"}"]

&lt;alter device map item&gt; ::=
	&lt;alter device domain map&gt; |
	&lt;alter device operator map&gt;
	
&lt;alter device domain map&gt; ::=
	create &lt;device domain map&gt; | 
	alter domain &lt;domain name&gt; &lt;alter class definition&gt; | 
	drop domain &lt;domain name&gt;
	
&lt;alter device operator map&gt; ::=
	create &lt;device operator map&gt; |
	alter operator &lt;operator specifier&gt; &lt;alter class definition&gt; |
	drop operator &lt;operator specifier&gt;</programlisting></para> 
				<para>The drop device statement in D4 has the following syntax: 
					 <programlisting>&lt;drop device statement&gt; ::=
	drop device &lt;device name&gt;</programlisting></para> 
				<para>These statements create, alter, and drop a device named
					 <emphasis>device name</emphasis> in the catalog.</para> 
				<para>For a complete discussion about the use of devices within D4,
					 refer to the Using Devices section of Programming Topics in this guide.</para> 
		  </sect2> 
		  <sect2 id="D4LGEventHandlers"> 
				<title><indexterm><primary>Event
								Handlers</primary></indexterm><indexterm><primary>Catalog
								Elements</primary><secondary>Event Handlers</secondary></indexterm>Event
					 Handlers</title> 
				<para>Event handlers are operators that have been attached to
					 specific events in the system such as data modification, or proposable
					 interface calls. Event handlers can be attached to events triggered at the
					 domain level, the column level, or the table variable level. Each event has an
					 associated signature which is used to invoke the attached operator. The
					 signature of a handler must match the signature of the event to which it is
					 attached. </para> 
				<para>The following tables list the available events for different
					 types of catalog objects:</para> 
				<para>Table Variable Level Events: 
					 <informaltable> 
						  <tgroup cols="3"><thead> 
									 <row><entry>Event
												Type</entry><entry>Description</entry><entry>Signature</entry> 
									 </row></thead><tbody> 
									 <row><entry>Before Insert</entry><entry>Occurs
												before the insert of a row in a table variable.</entry><entry><symbol>(const
												row { &lt;heading&gt; })</symbol></entry> 
									 </row> 
									 <row><entry>After Insert</entry><entry>Occurs after
												the insert of a row in a table variable.</entry><entry><symbol>(const row {
												&lt;heading&gt; })</symbol></entry> 
									 </row> 
									 <row><entry>Before Update</entry><entry>Occurs
												before the update of a row in a table variable.</entry><entry><symbol>(const
												row { &lt;heading&gt; }, const row { &lt;heading&gt; })</symbol></entry> 
									 </row> 
									 <row><entry>After Update</entry><entry>Occurs after
												the update of a row in a table variable.</entry><entry><symbol>(const row {
												&lt;heading&gt; }, const row { &lt;heading&gt; })</symbol></entry> 
									 </row> 
									 <row><entry>Before Delete</entry><entry>Occurs
												before the delete of a row in a table variable.</entry><entry><symbol>(const
												row { &lt;heading&gt; })</symbol></entry> 
									 </row> 
									 <row><entry>After Delete</entry><entry>Occurs after
												the delete of a row in a table variable.</entry><entry><symbol>(const row {
												&lt;heading&gt; })</symbol></entry> 
									 </row> 
									 <row><entry>Default</entry><entry>Occurs during a
												default proposable call from the CLI.</entry><entry><symbol>(var row {
												&lt;heading&gt; }, const string)</symbol></entry> 
									 </row> 
									 <row><entry>Change</entry><entry>Occurs during a
												change proposable call from the CLI.</entry><entry><symbol>(var row {
												&lt;heading&gt; }, const string)</symbol></entry> 
									 </row> 
									 <row><entry>Validate</entry><entry>Occurs during a
												validate proposable call from the CLI.</entry><entry><symbol>(const row {
												&lt;heading&gt; }, const string)</symbol></entry> 
									 </row></tbody> 
						  </tgroup> 
					 </informaltable></para> 
				<para>Column Level Events: 
					 <informaltable> 
						  <tgroup cols="3"> 
								<thead> 
									 <row><entry>Event
												Type</entry><entry>Description</entry><entry>Signature</entry> 
									 </row></thead><tbody> 
									 <row><entry>Default</entry><entry>Occurs during a
												default proposable call from the CLI.</entry><entry><symbol>(var &lt;column
												data type&gt;)</symbol></entry> 
									 </row> 
									 <row><entry>Change</entry><entry>Occurs during a
												change proposable call from the CLI.</entry><entry><symbol>(var entry {
												&lt;heading&gt; })</symbol></entry> 
									 </row> 
									 <row><entry>Validate</entry><entry>Occurs during a
												validate proposable call from the CLI.</entry><entry><symbol>(const entry {
												&lt;heading&gt; })</symbol></entry> 
									 </row></tbody> 
						  </tgroup> 
					 </informaltable></para> 
				<para>Domain Level Events: 
					 <informaltable> 
						  <tgroup cols="3"> 
								<thead> 
									 <row><entry>Event
												Type</entry><entry>Description</entry><entry>Signature</entry> 
									 </row></thead><tbody> 
									 <row><entry>Default</entry><entry>Occurs during a
												default proposable call from the CLI.</entry><entry><symbol>(var &lt;scalar
												type&gt;)</symbol></entry> 
									 </row> 
									 <row><entry>Change</entry><entry>Occurs during a
												change proposable call from the CLI.</entry><entry><symbol>(var &lt;scalar
												type&gt;)</symbol></entry> 
									 </row> 
									 <row><entry>Validate</entry><entry>Occurs during a
												validate proposable call from the CLI.</entry><entry><symbol>(const &lt;scalar
												type&gt;)</symbol></entry> 
									 </row></tbody> 
						  </tgroup> 
					 </informaltable></para> 
				<para>Event handlers are attached and detached using the DDL
					 statements <symbol>attach</symbol> and <symbol>detach</symbol>.</para> 
				<para>The attach statement in D4 has the following syntax: 
					 <programlisting>&lt;attach statement&gt; ::=
	attach &lt;operator specifier&gt; 
		to &lt;event source specifier&gt; 
		&lt;event specifier clause&gt;

&lt;operator specifier&gt; ::=
	&lt;operator name&gt;"("&lt;formal parameter specifier commalist&gt;")"

&lt;formal parameter specifier&gt; ::=
	[&lt;modifier&gt;] &lt;type specifier&gt;

&lt;modifier&gt; ::=
	[var | const]

&lt;event source specifier&gt; ::=
	&lt;tablevar name&gt; |
	&lt;column name&gt; in &lt;tablevar name&gt; |
	&lt;domain name&gt;
&lt;event specifier clause&gt; ::=
	on "{"&lt;ne event specifier commalist&gt;"}"
	
&lt;event specifier&gt; ::=
	((before | after) (insert | update | delete)) | 
	(default | validate | change)</programlisting></para> 
				<para>This statement attaches the operator specified by
					 <emphasis>operator specifier</emphasis> to the event source specified by
					 <emphasis>event source specifier</emphasis> and the event specified by
					 <emphasis>event specifier clause</emphasis>.</para> 
				<para>The detach statement in D4 has the following syntax: 
					 <programlisting>&lt;detach statement&gt; ::=
	detach &lt;operator specifier&gt;
		from &lt;event source specifier&gt;
		&lt;event specifier clause&gt;</programlisting></para> 
				<para>This statement detaches the operator specified by
					 <emphasis>operator specifier</emphasis> from the event source specified by
					 <emphasis>event source specifier</emphasis> and the event specified by
					 <emphasis>event specifier clause</emphasis>.</para> 
		  </sect2> 
		  <sect2 id="D4LGSorts"> 
				<title><indexterm><primary>Sorts</primary></indexterm><indexterm><primary>Catalog
								Elements</primary><secondary>Sorts</secondary></indexterm>Sorts</title> 
				<para>A <emphasis>sort</emphasis> is associated with a domain
					 definition and provides the default sort expression for columns defined on the
					 given domain. A given domain may only have one sort associated with it. Note
					 that this sort serves as a default for ordering, and can always be changed
					 using the sort clause of the order column definition with an order definition
					 or order clause.</para> 
				<para>The create sort statement in D4 has the following syntax: 
					 <programlisting>&lt;create sort statement&gt; ::=
	create sort for &lt;domain name&gt; &lt;expression&gt;

&lt;domain name&gt; ::=
	&lt;qualified identifier&gt;</programlisting></para> 
				<para>The alter sort statement in D4 has the following syntax: 
					 <programlisting>&lt;alter sort statement&gt; ::=
	alter sort for &lt;domain name&gt; &lt;expression&gt;</programlisting></para> 
				<para>The drop sort statement in D4 has the following syntax: 
					 <programlisting>&lt;drop sort statement&gt; ::=
	drop sort for &lt;domain name&gt;</programlisting></para> 
				<para>These statements create, alter, and drop the sort for the
					 domain given by <emphasis>domain name</emphasis> in the catalog.</para> 
		  </sect2> 
	 </sect1> 
	 <sect1 id="D4LGDataManipulation"> 
		  <title><indexterm><primary>Data
						  Manipulation</primary></indexterm><indexterm><primary>D4 Language
						  Guide</primary><secondary>Data Manipulation</secondary></indexterm>Data
				Manipulation</title> 
		  <para>This section covers the data manipulation language statements
				available in the D4 language. These statements allow data in the database to be
				retrieved, stored, and changed.</para> 
		  <para>Data manipulation statements in D4 have the following syntax: 
				<programlisting>&lt;dml statement&gt; ::=
	&lt;select statement&gt; |
	&lt;insert statement&gt; |
	&lt;update statement&gt; |
	&lt;delete statement&gt;</programlisting></para> 
		  <para>It is important to note that these statements are set-at-a-time
				operations, meaning that they do not operate at a row level, rather on an
				entire table variable at once. Also note that each of the modification
				statements, <symbol>insert</symbol>, <symbol>update</symbol>, and
				<symbol>delete</symbol>, are shorthands for some equivalent relational
				assignment.</para> 
		  <para>The following sections consider each statement in detail.</para> 
		  <sect2 id="D4LGSelectStatement"> 
				<title><indexterm><primary>Select
								Statement</primary></indexterm><indexterm><primary>Data
								Manipulation</primary><secondary>Select Statement</secondary></indexterm>Select
					 Statement</title> 
				<para>The select statement allows for the retrieval of a specified
					 table expression. The statement allows the result set to be ordered
					 arbitrarily, and allows for the specification of cursor level properties such
					 as isolation level and cursor type. The select statement and the cursor
					 selector both use the same <emphasis>cursor definition</emphasis> production
					 rule to define their syntax.</para> 
				<para>The purpose of the select statement in the D4 language is to
					 provide a facility for parser level recognition of statements that should
					 return a result set. This is used by the Call-Level Interface (CLI) to
					 determine whether a given batch should be executed or opened. Thus, a select
					 statement should only be used to retrieve data through the CLI. For example: 
					 <programlisting>Employee;</programlisting> is a valid expression, but no data will be retrieved. On the
					 other hand the results of the following query will be retrieved through the
					 CLI: 
					 <programlisting>select Employee; </programlisting> 
					 <programlisting>ID Name 
-- ---- 
1  Joe 
2  John 
3  Josh 
4  Jeff 
5  Jake 
6  Jeff </programlisting> </para> 
				<para>The select statement in D4 has the following syntax: 
					 <programlisting>&lt;select statement&gt; ::=
	select &lt;cursor definition&gt;

&lt;cursor definition&gt; ::=
	&lt;expression&gt; 
	[&lt;order clause&gt; | &lt;browse clause&gt;] 
	[&lt;cursor capabilities&gt;] 
	[&lt;cursor isolation&gt;] 
	[&lt;cursor type&gt;]

&lt;order clause&gt; ::=
	order by 
		"{"&lt;ne order column definition commalist&gt;"}" 
		[include sequence [&lt;column name&gt;] &lt;metadata&gt;] 
		&lt;metadata&gt;

&lt;browse clause&gt; ::=
	browse by 
		"{"&lt;ne order column definition commalist&gt;"}" 
		&lt;metadata&gt;

&lt;order column definition&gt; ::=
	&lt;column name&gt; [sort &lt;expression&gt;] [asc | desc]

&lt;column name&gt; ::=
	&lt;qualified identifier&gt;

&lt;cursor capabilities&gt; ::=
	capabilities "{"&lt;cursor capability commalist&gt;"}"
	
&lt;cursor capability&gt; ::=
	navigable | 
	backwardsnavigable | 	
	bookmarkable | 
	searchable | 
	updateable | 
	truncateable | 
	countable | 
	derivable

&lt;cursor isolation&gt; ::=
	isolation (none | chaos | browse | stability | isolated)

&lt;cursor type&gt; ::=
	type (static | dynamic)</programlisting></para> 
				<para>The basis of the cursor definition is a table expression
					 specified by <emphasis>expression</emphasis>. For a detailed description of the
					 <emphasis>expression</emphasis> production rule, refer to the Expressions
					 section of the Language Elements section of this guide. For a complete
					 description of the table operators avaialable in D4, refer to the Table
					 Expressions section of this guide.</para> 
				<sect3 id="D4LGOrderingTheResultSet"> 
					 <title><indexterm><primary>Ordering The Result
									 Set</primary></indexterm><indexterm><primary>Select
									 Statement</primary><secondary>Ordering The Result
									 Set</secondary></indexterm>Ordering The Result Set</title> 
					 <para>The result set for a cursor is ordered as specified by
						  the <emphasis>order clause</emphasis> or <emphasis>browse clause</emphasis>. An
						  <emphasis>order</emphasis> specification simply indicates the requested order
						  for the result set, whereas a <emphasis>browse</emphasis> specification
						  indicates not only the requested order, but that <emphasis>navigational
						  access</emphasis> should be used to retrieve data from the cursor. A cursor
						  using navigational access enables functionality such as searching and backwards
						  scrolling by transparently transforming the expression actually used to
						  retrieve the data. This type of access enables efficient searching and
						  navigation through a cursor without requiring ad-hoc solutions to be developed
						  in client applications.</para> 
					 <para>An order can consist of any subset of the columns of a
						  table variable in any order. Each column can include an optional sort
						  expression, and an optional ascending indicator.</para> 
					 <para>The sort expression allows the order to use an arbitrary
						  condition for sorting. The sort expression must be integer-valued, functional
						  and deterministic. The expression has access to the implicit variables
						  <symbol>left.value</symbol> and <symbol>right.value</symbol>, which are the
						  values to be compared. The expression must return -1 if
						  <symbol>left.value</symbol> is less than <symbol>right.value</symbol>, 0 if the
						  two values are equal, and 1 if <symbol>left.value</symbol> is greater than
						  <symbol>right.value</symbol>.</para> 
					 <para>The optional ascending indicator specifies whether this
						  column should be sorted ascending or descending. If no ascending indicator is
						  specified, ascending is assumed.</para> 
					 <para>In addition to specifying the requested order, an order
						  clause may include an optional sequence column. This instructs the DAE to add a
						  column named <symbol>sequence</symbol>, or <emphasis>column name</emphasis> if
						  specified, to the result set which serves as a sequential indicator for the
						  row, i.e. the value of this column is set to 1 for the first row, 2 for the
						  second row, and so on. This column constitutes a candidate key in the result
						  set.</para> 
					 <para>The following example illustrates the use of the order
						  clause: 
						  <programlisting>select Employee order by { Name, ID desc };	 </programlisting> 
						  <programlisting>ID Name
-- ---- 
5  Jake 
6  Jeff 
4  Jeff 
1  Joe 
2  John
3  Josh </programlisting> </para> 
					 <para>Multiple columns can be defined as an order. If the ID
						  was missing in the order by clause above then the order of the two Jeff rows
						  would be undefined. The desc part of the ID order is a keyword which tells the
						  order to be reversed, going from the largest ID to the smallest ID, which is
						  why the Jeff with ID 6 is listed before the other Jeff.</para> 
				</sect3> 
				<sect3 id="D4LGCursorCapabilities"> 
					 <title><indexterm><primary>Cursor
									 Capabilities</primary></indexterm><indexterm><primary>Select
									 Statement</primary><secondary>Cursor Capabilities</secondary></indexterm>Cursor
						  Capabilities</title> 
					 <para>Cursor capabilities describe the behaviors available for
						  the cursor. These include items such as updatability, backwards navigation,
						  searching, and bookmarking. The DAE defines the following cursor capabilities: 
						  <itemizedlist> 
								<listitem> 
									 <para>Navigable</para> 
									 <para>Indicates that the cursor is capable of
										  forward navigation through calls like Next and Last. Also indicates that the
										  cursor supports data retrieval through the Select call. All cursors are
										  guaranteed to support this level of functionality.</para> 
								</listitem> 
								<listitem> 
									 <para>Backwards Navigable</para> 
									 <para>Indicates that the cursor is capable of
										  backward navigation through calls like Prior and First.</para> 
								</listitem> 
								<listitem> 
									 <para>Bookmarkable</para> 
									 <para>Indicates that the cursor is capable of
										  bookmarking functionality, or remembering a location in the result set for
										  quick location at a later time.</para> 
								</listitem> 
								<listitem> 
									 <para>Searchable</para> 
									 <para>Indicates that the cursor is capable of
										  performing searches through calls like FindKey and FindNearest. Note that the
										  search must be made against the same columns that were used to order the
										  result.</para> 
								</listitem> 
								<listitem> 
									 <para>Updatable</para> 
									 <para>Indicates that the cursor supports updates
										  through calls like Insert and Update.</para> 
								</listitem> 
								<listitem> 
									 <para>Truncatable</para> 
									 <para>Indicates that the cursor supports
										  truncation.</para> 
								</listitem> 
								<listitem> 
									 <para>Countable</para> 
									 <para>Indicates that the cursor supports retrieving
										  a count of the number of rows in the result.</para> 
								</listitem> 
								<listitem> 
									 <para>Elaborable</para> 
									 <para>Indicates that the cursor supports query
										  elaboration for use by application front ends.</para> 
								</listitem> 
						  </itemizedlist></para> 
					 <para>The cursor definition allows any combination of these
						  capabilities to be requested. The DAE will attempt to provide a cursor with the
						  requested capabilities. An error occurs if the requested capabilities cannot be
						  provided.</para> 
					 <para>For a complete description of each of these capabilities,
						  refer to Part II of this manual.</para> 
				</sect3> 
				<sect3 id="D4LGCursorIsolation"> 
					 <title><indexterm><primary>Cursor
									 Isolation</primary></indexterm><indexterm><primary>Select
									 Statement</primary><secondary>Cursor Isolation</secondary></indexterm>Cursor
						  Isolation</title> 
					 <para>The isolation of a cursor determines how the cursor runs
						  with respect to other active transactions in the system. The settings for this
						  behavior correspond roughly to the isolation levels available for transaction
						  processing.</para> 
					 <informaltable> 
						  <tgroup cols="2"><thead> 
									 <row><entry>Method</entry><entry>Description</entry>
										  
									 </row></thead><tbody> 
									 <row><entry>None</entry><entry>Indicates that the
												cursor runs at the isolation level of the current transaction.</entry> 
									 </row> 
									 <row><entry>Chaos</entry><entry>Indicates that the
												cursor does not lock data that it writes, and reads uncommitted data from other
												transactions.</entry> 
									 </row> 
									 <row><entry>Browse</entry><entry>Indicates that the
												cursor locks data that it writes, but may read uncommitted data from other
												transactions.</entry> 
									 </row> 
									 <row><entry>Cursor
												Stability</entry><entry>Indicates that the cursor locks data that it writes,
												and reads only committed data from other transactions.</entry> 
									 </row> 
									 <row><entry>Isolated</entry><entry>Indicates that
												the cursor runs completely isolated from other transactions.</entry> 
									 </row> 
								</tbody> 
						  </tgroup> 
					 </informaltable> 
				</sect3> 
				<sect3 id="D4LGCursorType"> 
					 <title><indexterm><primary>Cursor
									 Type</primary></indexterm><indexterm><primary>Select
									 Statement</primary><secondary>Cursor Type</secondary></indexterm>Cursor
						  Type</title> 
					 <para>The type of a cursor determines how the cursor is
						  materialized and how it behaves with respect to updates being made through the
						  cursor, and by other users of the system. Cursors may be requested either
						  static or dynamic.</para> 
					 <sect4 id="D4LGStatic"> 
						  <title><indexterm><primary>Static</primary></indexterm><indexterm><primary>Cursor
										  Type</primary><secondary>Static</secondary></indexterm>Static</title> 
						  <para>Indicates that the cursor is insensitive to updates
								made to the result set after the cursor has been opened.</para> 
						  <para>In a static cursor, updates made to rows in the
								result set, either by the user of the cursor, or updates that become visible
								based on the isolation level of the cursor from other transactions, are not
								visible. The result set is fully materialized on open, and no changes are made
								to this set.</para> 
					 </sect4> 
					 <sect4 id="D4LGDynamic"> 
						  <title><indexterm><primary>Dynamic</primary></indexterm><indexterm><primary>Cursor
										  Type</primary><secondary>Dynamic</secondary></indexterm>Dynamic</title> 
						  <para>Indicates that the cursor is sensitive to updates
								made to rows in the result set after the cursor has been opened.</para> 
						  <para>In a dynamic cursor, updates made to rows in the
								result set, either by the user of the cursor, or from other transactions that
								become visible based on the isolation level of the cursor, are visible through
								the cursor. The result set is dynamically queried for as it is requested. Note
								that this is not a guarantee that updates made by other transactions will be
								visible, only that the system is not required to exclude them. Depending on how
								the query is processed, and how the devices performing the processing
								manipulate the rows in the result set, external updates may or may not be
								visible. However, a dynamic cursor does guarantee that updates made through the
								cursor are visible.</para> 
					 </sect4> 
				</sect3> 
		  </sect2> 
		  <sect2 id="D4LGInsertStatement"> 
				<title><indexterm><primary>Insert
								Statement</primary></indexterm><indexterm><primary>Data
								Manipulation</primary><secondary>Insert Statement</secondary></indexterm>Insert
					 Statement</title> 
				<para>The insert statement allows data to be inserted into a given
					 table variable or expression.</para> 
				<para>The insert statement in D4 has the following syntax: 
					 <programlisting>&lt;insert statement&gt; ::=
	insert &lt;source&gt; into &lt;target&gt;

&lt;source&gt; ::=
	&lt;expression&gt;

&lt;target&gt; ::=
	&lt;expression&gt;</programlisting></para> 
				<para>The insert must not violate any constraint of the
					 database.</para> 
				<para>The value specified by <emphasis>source</emphasis> must be
					 assignment compatible with the variable or expression given by
					 <emphasis>target</emphasis>, with the exception that the source value need not
					 include all the columns of the target value. Columns not specified in the
					 insert are provided a default value if the corresponding column, or the domain
					 of the column, of the target has a default specification.</para> 
				<para>The expression given by <emphasis>source</emphasis> must be
					 table valued. In other words, the expression must return a table. In order to
					 insert a single row, a table selector must be used to construct a table
					 value.</para> 
				<para>The variable or expression given by
					 <emphasis>target</emphasis> need not be a table variable. The target can be a
					 table expression of arbitrary complexity. In this case, the updatability
					 mechanism for views is used to perform the insert. For more information on how
					 modifications are made to views, refer to the documentation for each table
					 operator in this guide.</para> 
				<para>Note that the insert statement is essentially shorthand for
					 an equivalent table variable assignment. For example: 
					 <programlisting>insert A into B;</programlisting>and 
					 <programlisting>B := B union A;</programlisting>are conceptually equivalent.</para> 
				<para>The following example illustrates the use of the D4 insert
					 statement: 
					 <programlisting>insert
	table
	{ 
		row { "John Smith" Name }
	} 
	into Customer; </programlisting> </para> 
		  </sect2> 
		  <sect2 id="D4LGUpdateStatement"> 
				<title><indexterm><primary>Update
								Statement</primary></indexterm><indexterm><primary>Data
								Manipulation</primary><secondary>Update Statement</secondary></indexterm>Update
					 Statement</title> 
				<para>The update statement allows the data in a given table
					 variable or expression to be changed. The update statement will also work
					 against row variables.</para> 
				<para>The update statement in D4 has the following syntax: 
					 <programlisting>&lt;update statement&gt; ::=
	update &lt;expression&gt; set "{"&lt;ne update column commalist&gt;"}" 
	[where &lt;expression term&gt;]

&lt;update column&gt; ::=
	&lt;target&gt; := &lt;expression term&gt;

&lt;target&gt; ::=
	&lt;expression term&gt;</programlisting></para> 
				<para>The update must not violate any constraint of the
					 database.</para> 
				<para>The variable or expression given by
					 <emphasis>expression</emphasis> need not be a table variable. The target can be
					 a table expression of arbitrary complexity. In this case, the updatability
					 mechanism for views is used to perform the update. For more information on how
					 modifications are made to views, refer to the documentation for each table
					 operator in this guide.</para> 
				<para>The update target may also be a row variable.</para> 
				<para>The set clause specifies a list of columns to be updated in
					 the target, and the new values for each column. The values given for each
					 column must be assignment compatible with the type of the column. The
					 expression specifying the new value for each column can access the current
					 values of the target row by name.</para> 
				<para>The update statement includes an optional
					 <emphasis>where</emphasis> specification that indicates which rows of the
					 target expression are to be updated. It is an error to specify an update
					 condition when the target is a row variable.</para> 
				<para>The following example illustrates the use of the D4 update
					 statement: 
					 <programlisting>update Customer set { Name := "Sally Johnson" } where ID = 5;</programlisting> </para> 
		  </sect2> 
		  <sect2 id="D4LGDeleteStatement"> 
				<title><indexterm><primary>Delete
								Statement</primary></indexterm><indexterm><primary>Data
								Manipulation</primary><secondary>Delete Statement</secondary></indexterm>Delete
					 Statement</title> 
				<para>The delete statement allows the data in a given table
					 variable or expression to be removed.</para> 
				<para>The delete statement in D4 has the following syntax: 
					 <programlisting>&lt;delete statement&gt; ::=
	delete &lt;expression&gt;</programlisting></para> 
				<para>The delete must not violate any constraint of the
					 database.</para> 
				<para>The variable or expression given by
					 <emphasis>expression</emphasis> need not be a table variable. The target can be
					 a table expression of arbitrary complexity. In this case, the updatability
					 mechanism for views is used to perform the delete. For more information on how
					 modifications are made to views, refer to the documentation for each table
					 operator in this guide.</para> 
				<para>The following examples illustrate the use of the D4 delete
					 statement: 
					 <programlisting>// deletes all employees with an ID greater than 3
delete Employee where ID &gt; 3;

delete Employee; // deletes all employees</programlisting> </para> 
		  </sect2> 
	 </sect1> 
	 <sect1 id="D4LGTableExpressions"> 
		  <title><indexterm><primary>Table
						  Expressions</primary></indexterm><indexterm><primary>D4 Language
						  Guide</primary><secondary>Table Expressions</secondary></indexterm>Table
				Expressions</title> 
		  <para>This section covers the various table operators available in D4.
				Type inference as well as updatability is covered for each of the
				operators.</para> 
		  <para>The table operator clause in D4 has the following syntax: 
				<programlisting>&lt;table operator clause&gt; ::=
	&lt;where clause&gt; |
	&lt;over clause&gt; |
	&lt;remove clause&gt; |
	&lt;add clause&gt; |
	&lt;rename clause&gt; |
	&lt;aggregate clause&gt; |
	&lt;quota clause&gt; |
	&lt;explode clause&gt; |
	&lt;adorn clause&gt; |
	&lt;redefine clause&gt; |
	&lt;union clause&gt; |
	&lt;intersect clause&gt; |
	&lt;minus clause&gt; |
	&lt;times clause&gt; |
	&lt;join clause&gt; |
	&lt;outer join clause&gt;</programlisting></para> 
		  <para>All D4 table operators are fully atomic and produce a new table.
				This property is known as <emphasis>closure</emphasis> and allows the results
				of one table operator to be used as the argument to another. This allows
				operators within expressions to be <emphasis>nested</emphasis> as often as
				necessary, and in any order. This is in stark contrast to SQL in which queries
				are required to be formed in terms of a strict
				<emphasis>select-from-where</emphasis> template.</para> 
		  <para>The ever present <emphasis>select * from</emphasis> portions of
				an SQL query are not required in D4. Each section of an SQL query serves a
				specific purpose in describing the desired result set. For example, the select
				list portion of an SQL query performs several different operations including
				projection, extension, renaming, and even aggregation (this latter task is done
				in conjunction with the <emphasis>group by</emphasis> and
				<emphasis>having</emphasis> clauses, a fact which serves to complicate matters
				even further). In D4, each of these tasks is relegated to a separate operator
				which can be used anywhere within the query. For instance, in SQL to restrict a
				result set after a <emphasis>group by</emphasis>, the
				<emphasis>having</emphasis> clause must be used. In D4, because no restrictions
				are made about where an operator can appear, another <symbol>where</symbol> is
				simply added to the query. For a complete comparison of the data manipulation
				capabilities of the two languages, refer to the Comparison with SQL section of
				this guide.</para> 
		  <para>The following sections cover each table operator in detail. The
				sample database provided will be used throughout the examples in this section: 
				<programlisting>create table Employee
{ 
	ID : Integer,
	Name : String,
	key { ID }
}; 

insert 
	table	
	{
		row { 1 ID, "Joe" Name },
		row { 2, "John" },
		row { 3, "Josh" },
		row { 4, "Jeff" },
		row { 5, "Jake" },
		row { 6, "Jeff" }
	} 
	into Employee;

create table Manager
{
	Manager_ID : Integer,
	Employee_ID : Integer,
	key { Manager_ID, Employee_ID },
	reference Manager_Employee { Manager_ID } references Employee { ID },
	reference Employee_Employee { Employee_ID } references Employee { ID }
};

insert 
	table
	{
		row { 1 Manager_ID, 2 Employee_ID },
		row { 1 Manager_ID, 3 Employee_ID },
		row { 2 Manager_ID, 4 Employee_ID },
		row { 2 Manager_ID, 6 Employee_ID },
		row { 4 Manager_ID, 5 Employee_ID }
	}
	into Manager;

create table EmployeePhone 
{
	ID : Integer,
	Phone : String,
	key { ID, Phone }
};

EmployeePhone :=
	table
	{
		row { 1 ID, "555-1234" Phone },
		row { 1 ID, "555-1000" Phone }, 
		row { 2 ID, "555-4321" Phone },
		row { 4 ID, "555-4444" Phone },
		row { 5 ID, "555-5678" Phone },
		row { 10 ID, "411" Phone	},
		row { 12 ID, "911" Phone }
	};</programlisting> </para> 
		  <sect2 id="D4LGRestrict"> 
				<title><indexterm><primary>Where</primary></indexterm><indexterm><primary>Table
								Expressions</primary><secondary>Where</secondary></indexterm>Where</title> 
				<para>The where operator applies a condition to each row of the
					 input. Only rows for which the condition evaluates to true appear in the
					 result.</para> 
				<para>The where clause in D4 has the following syntax: 
					 <programlisting>&lt;where clause&gt; ::=
	where &lt;expression term&gt;</programlisting></para> 
				<para>The expression specified by <emphasis>expression
					 term</emphasis> must be boolean-valued. Within the expression, access to the
					 values of the input row are available by column name.</para> 
				<para>The result of a where has the same columns, keys, orders,
					 references, and metadata as the input table value. The restriction condition
					 becomes a constraint in the result.</para> 
				<para>Modifications to views defined using <symbol>where</symbol>
					 are allowed so long as the new row satisfies the restriction condition.</para> 
				<para>The following example illustrates the use of the where
					 operator: 
					 <programlisting>select Employee where ID &gt;= 4; </programlisting> 
					 <programlisting>ID Name
-- ---- 
4  Jeff
5  Jake
6  Jeff		</programlisting> </para> 
		  </sect2> 
		  <sect2 id="D4LGProjectandRemove"> 
				<title><indexterm><primary>Project and
								Remove</primary></indexterm><indexterm><primary>Table
								Expressions</primary><secondary>Project and Remove</secondary></indexterm>Over
					 and Remove</title> 
				<para>Projection allows a given set of columns to be removed from
					 the result. There are two methods for specifying the projection list in D4,
					 over, and remove. Over specifies the desired columns, while remove specifies
					 the unwanted columns.</para> 
				<para>The over and remove clauses in D4 have the following syntax: 
					 <programlisting>&lt;over clause&gt; ::=
	over "{"&lt;column name commalist&gt;"}"

&lt;remove clause&gt; ::=
	remove "{"&lt;column name commalist&gt;"}"

&lt;column name&gt; ::=
	&lt;qualified identifier&gt;</programlisting></para> 
				<para>The result of a projection has only the columns specified.
					 Only keys of the input which are completely included in the specified column
					 list are keys of the result. If all keys are excluded by the projection, the
					 key becomes all columns of the result, eliminating duplicates as necessary.
					 Only orders of the input which are completely included in the specified column
					 list are orders of the result. References of the input which are completely
					 included in the specified column list are references of the result.</para> 
				<para>Modification to views defined using <symbol>over</symbol> or
					 <symbol>remove</symbol> is accomplished by performing the corresponding
					 modification against the input table. An insert will be rejected if the
					 projection has excluded columns which do not have a default defined.</para> 
				<para>The following example illustrates the use of the project
					 clause: 
					 <programlisting>select Employee over { Name }; </programlisting> 
					 <programlisting>Name 
---- 
Jake 
Jeff 
Joe 
John 
Josh </programlisting> </para> 
				<para>The following query is equivalent to the above example but
					 uses the remove clause instead: 
					 <programlisting>select Employee remove { ID }; </programlisting> 
					 <programlisting>Name 
---- 
Jake 
Jeff 
Joe 
John 
Josh </programlisting> </para> 
				<para> The following examples illustrate key inference in a
					 projection: 
					 <programlisting>select Employee where Name = "Jeff";</programlisting> 
					 <programlisting>ID Name 
-- ---- 
4  Jeff 
6  Jeff </programlisting> 
					 <programlisting>select Employee where Name = "Jeff" over { Name };</programlisting> 
					 <programlisting>Name 
---- 
Jeff </programlisting> </para> 
		  </sect2> 
		  <sect2 id="D4LGAdd"> 
				<title><indexterm><primary>Add</primary></indexterm><indexterm><primary>Table
								Expressions</primary><secondary>Add</secondary></indexterm>Add</title> 
				<para>The add clause allows a table value to be extended with new
					 columns defined by expressions.</para> 
				<para>The add clause in D4 has the following syntax: 
					 <programlisting>&lt;add clause&gt; ::=
	add "{"&lt;ne named expression term commalist&gt;"}"

&lt;named expression term&gt; ::=
	&lt;expression term&gt; &lt;qualified identifier&gt;</programlisting></para> 
				<para>Expressions within the add clause have access to the values
					 of the current row by column name.</para> 
				<para>The result of an add has the same columns of the input, with
					 the additional columns as defined by <emphasis>named expression term
					 commalist</emphasis>. The result has the same keys, orders, references, and
					 metadata as the input.</para> 
				<para>Modifications to views defined using <symbol>add</symbol> are
					 allowed so long as values specified for columns added by the extension match
					 the expression definition for the column.</para> 
				<para>The following example illustrates the use of the add clause: 
					 <programlisting>select Employee 
	add { "Employee Name = " + Name NewName } 
	over { NewName }; </programlisting> 
					 <programlisting>NewName 
-------------------- 
Employee Name = Jake
Employee Name = Jeff
Employee Name = Joe
Employee Name = John
Employee Name = Josh </programlisting> </para> 
		  </sect2> 
		  <sect2 id="D4LGRename"> 
				<title><indexterm><primary>Rename</primary></indexterm><indexterm><primary>Table
								Expressions</primary><secondary>Rename</secondary></indexterm>Rename</title> 
				<para>Rename is used to rename the columns in the result. There are
					 two variations of the rename operator. One renames a specified set of columns,
					 and the other renames all the columns by qualifying each column name with a
					 given identifier.</para> 
				<para>The rename clause in D4 has the following syntax: 
					 <programlisting>&lt;rename clause&gt; ::=
	rename ("{"&lt;ne named column name commalist&gt;"}" | 
	(&lt;qualified identifier&gt; &lt;metadata&gt;))

&lt;named column name&gt; ::=
	&lt;column name&gt; &lt;column name&gt;

&lt;column name&gt; ::=
	&lt;qualified identifier&gt;</programlisting></para> 
				<para>The result of a rename operator has the same columns as the
					 input, with the names changed as specified. The keys, orders, and references
					 are included with the names of the columns involved updated
					 appropriately.</para> 
				<para>Modifications to views defined using <symbol>rename</symbol>
					 are accomplished by transforming the modification as appropriate for the name
					 changes.</para> 
				<para>The following examples illustrate the use of the rename
					 operator. 
					 <programlisting>select Employee
	rename { ID EmployeeID, Name FirstName }; </programlisting> 
					 <programlisting>EmployeeID FirstName
---------- --------- 
1          Joe 
2          John
3          Josh
4          Jeff
5          Jake
6          Jeff </programlisting> 
					 <programlisting>select Employee rename X;</programlisting> 
					 <programlisting>X.ID X.Name
---- ------
1    Joe 
2    John 
3    Josh 
4    Jeff 
5    Jake 
6    Jeff</programlisting> </para> 
		  </sect2> 
		  <sect2 id="D4LGAggregate"> 
				<title><indexterm><primary>Aggregate</primary></indexterm><indexterm><primary>Table
								Expressions</primary><secondary>Aggregate</secondary></indexterm>Aggregate</title>
				
				<para>The aggregate operator allows operations based on sets of
					 rows to be computed and added to the result set. It should be noted that
					 aggregation is not a primitive operator, as it can be expressed in terms other
					 operators. For example, the expression: 
					 <programlisting>Employee group by { Name } add { Count() NameCount }</programlisting>can also be expressed as: 
					 <programlisting>Employee over { Name } rename X
	add { Count(Employee where Name = X.Name) NameCount }</programlisting></para> 
				<para>The aggregate clause in D4 has the following syntax: 
					 <programlisting>&lt;aggregate clause&gt; ::=
	group [by "{"&lt;ne column name commalist&gt;"}"] 
	add "{"&lt;ne named aggregate expression commalist&gt;"}"

&lt;named aggregate expression&gt; ::=
	&lt;aggregate expression&gt; &lt;column name&gt;

&lt;aggregate expression&gt; ::=
	&lt;operator name&gt;"("[distinct] [&lt;column name&gt;]")"

&lt;column name&gt; ::=
	&lt;qualified identifier&gt;

&lt;operator name&gt; ::=
	&lt;qualified identifier&gt;</programlisting></para> 
				<para>The expression includes an optional by clause which specifies
					 the grouping to be used for the aggregation. If no by clause is specified, the
					 aggregation is performed for all the rows in the input. Otherwise, the input is
					 partitioned into groups based on the columns in the by clause, and the
					 aggregation is performed once for each group. The optional distinct specifier
					 in the aggregate expression indicates that duplicates should be removed from
					 the values for the source column prior to performing the aggregation.</para> 
				<para>The aggregate expression specifies the aggregate operator to
					 be invoked. This can be a system provided operator, or a user-defined operator,
					 but it must be an aggregate operator. For a complete description of aggregate
					 operators, refer to the Catalog Elements section of this guide.</para> 
				<para>The result of the group operation is a table with the columns
					 specified in the by clause and a column for each aggregate expression. The by
					 clause functions as a projection so the keys of the result are determined the
					 same as they would be for projection over the columns in the by clause. Orders
					 and references are also inferred as they are for projection.</para> 
				<para>Modification to views defined using <symbol>group</symbol> is
					 accomplished by performing the update as though the expression were written
					 longhand. In other words, the modification is propogated through the equivalent
					 projection and extension operators.</para> 
				<para>The following sections describe each of the system provided
					 aggregate operators. User-defined aggregate operators are invoked in the same
					 way.</para> 
				<sect3 id="D4LGCount"> 
					 <title><indexterm><primary>Count</primary></indexterm><indexterm><primary>Aggregate</primary><secondary>Count</secondary></indexterm>Count</title>
					 
					 <para>The <symbol>Count</symbol> aggregate operator returns an
						  integer value that is the number of rows in the input. <symbol>Count</symbol>
						  returns zero when the input contains no rows.</para> 
					 <para>The following examples illustrate the use of the
						  <symbol>Count</symbol> operator: 
						  <programlisting>select Employee
	group add { Count() EmployeeCount }; </programlisting> 
						  <programlisting>EmployeeCount
------------- 
6 </programlisting> 
						  <programlisting>select Employee 
	add { ID mod 2 IsOddID }
 group by { IsOddID }
 	add { Count() EmployeeCount }; </programlisting> 
						  <programlisting>IsOddID EmployeeCount
------- -------------
0       3
1       3 </programlisting> </para> 
				</sect3> 
				<sect3 id="D4LGSum"> 
					 <title><indexterm><primary>Sum</primary></indexterm><indexterm><primary>Aggregate</primary><secondary>Sum</secondary></indexterm>Sum</title>
					 
					 <para>The <symbol>Sum</symbol> aggregate operator computes the
						  sum of the values of a given column. <symbol>Sum</symbol> returns the zero when
						  the input contains no rows.</para> 
					 <para>The following example illustrates the use of the
						  <symbol>Sum</symbol> operator: 
						  <programlisting>select Employee
	group add { Sum(ID) EmployeeIDTotal };</programlisting> 
						  <programlisting>EmployeeIDTotal
---------------
21				  </programlisting> </para> 
				</sect3> 
				<sect3 id="D4LGMin"> 
					 <title><indexterm><primary>Min</primary></indexterm><indexterm><primary>Aggregate</primary><secondary>Min</secondary></indexterm>Min</title>
					 
					 <para>The <symbol>Min</symbol> aggregate operator returns the
						  smallest value in a given column. <symbol>Min</symbol> returns the largest
						  value for the domain of the aggregation when the input contains no rows, except
						  when invoked on a column of type <symbol>System.String</symbol>, in which case
						  an error is raised.</para> 
					 <para>The following example illustrates the use of the
						  <symbol>Min</symbol> operator: 
						  <programlisting>select Employee
	group add { Min(ID) SmallestEmployeeID }; </programlisting> 
						  <programlisting>SmallestEmployeeID
------------------ 
1	  </programlisting> </para> 
				</sect3> 
				<sect3 id="D4LGMax"> 
					 <title><indexterm><primary>Max</primary></indexterm><indexterm><primary>Aggregate</primary><secondary>Max</secondary></indexterm>Max</title>
					 
					 <para>The <symbol>Max</symbol> aggregate operator returns the
						  largest value in a given column. <symbol>Max</symbol> returns the smallest
						  value for the domain of the aggregation when the input contains no rows, except
						  when invoked on a column of type <symbol>System.String</symbol>, in which case
						  an error is raised.</para> 
					 <para>The following example illustrates the use of the
						  <symbol>Max</symbol> operator: 
						  <programlisting>select Employee
	group add { Max(ID) LargestEmployeeID }; </programlisting> 
						  <programlisting>LargestEmployeeID
-----------------
6</programlisting> </para> 
				</sect3> 
				<sect3 id="D4LGAvg"> 
					 <title><indexterm><primary>Avg</primary></indexterm><indexterm><primary>Aggregate</primary><secondary>Avg</secondary></indexterm>Avg</title>
					 
					 <para>The <symbol>Avg</symbol> aggregate operator computes the
						  average value of the values in a given column. <symbol>Avg</symbol> uses the
						  formula <symbol>Sum(&lt;values&gt;) / Count(&lt;values&gt;)</symbol> to compute
						  the average. It is an error to invoke <symbol>Avg</symbol> when the input
						  contains no rows. <symbol>Avg</symbol> returns a value of type
						  <symbol>System.Decimal</symbol>, even if the column being averaged is an
						  integer type.</para> 
					 <para>The following examples illustrate the use of the
						  <symbol>Avg</symbol> operator:</para> 
					 <para> 
						  <programlisting>select Employee
	group add { Avg(ID) AverageEmployeeID }; </programlisting> 
						  <programlisting>AverageEmployeeID 
----------------- 
3.5				  </programlisting> 
						  <programlisting>select Employee
	group add { Avg(ID) EmployeeIDAverage }
	redefine { EmployeeIDAverage := Floor(EmployeeIDAverage) };</programlisting> 
						  <programlisting>AverageEmployeeID
-----------------
3				  </programlisting> </para> 
				</sect3> 
				<sect3 id="D4LGAny"> 
					 <title><indexterm><primary>Any</primary></indexterm><indexterm><primary>Aggregate</primary><secondary>Any</secondary></indexterm>Any</title>
					 
					 <para>The <symbol>Any</symbol> aggregate operator returns true
						  if any value in the input is true, and false otherwise. <symbol>Any</symbol>
						  returns false when the input contains no rows.</para> 
					 <para>The following example illustrates the use of the
						  <symbol>Any</symbol> operator: 
						  <programlisting>select Employee add {ID &gt; 3 LargerThanThree};</programlisting> 
						  <programlisting>ID Name LargerThanThree
--   ----      -------------------
1   Joe     False
2   John   False
3   Josh   False
4   Jeff    True
5   Jake  True
6   Jeff    True	  </programlisting> 
						  <programlisting>select Employee
	add {ID &gt; 3 LargerThanThree}
	group
		add { Any(LargerThanThree) AreAnyLargerThanThree }; </programlisting> </para> 
					 <para> 
						  <programlisting>AreAnyLargerThanThree
--------------------- 
True				  </programlisting> </para> 
				</sect3> 
				<sect3 id="D4LGAll"> 
					 <title><indexterm><primary>All</primary></indexterm><indexterm><primary>Aggregate</primary><secondary>All</secondary></indexterm>All</title>
					 
					 <para>The <symbol>All</symbol> aggregate operator returns true
						  if all the values of a given column are true. <symbol>All</symbol> returns true
						  when the input contains no rows.</para> 
					 <para>The following example illustrates the use of the
						  <symbol>All</symbol> operator: 
						  <programlisting>select Employee
	add {ID &gt; 3 LargerThanThree};  </programlisting> 
						  <programlisting>ID Name LargerThanThree
--  ----       -------------------
1   Joe     False
2   John   False
3   Josh   False
4   Jeff    True
5   Jake  True
6   Jeff    True			  </programlisting> 
						  <programlisting>select Employee
	add {ID &gt; 3 LargerThanThree}
	group 
		add { All(LargerThanThree) AreAllLargerThanThree }; </programlisting> 
						  <programlisting>AreAllLargerThanThree
---------------------
False				  </programlisting> </para> 
				</sect3> 
		  </sect2> 
		  <sect2 id="D4LGQuota"> 
				<title><indexterm><primary>Quota</primary></indexterm><indexterm><primary>Table
								Expressions</primary><secondary>Quota</secondary></indexterm>Quota</title> 
				<para>The quota operator limits the result set to a given number of
					 rows based on a specified order. Note that invocation of the quota operator
					 does not guarantee that the resulting set will have the given number of rows.
					 There may be less, and there may be more, depending on the data involved, as
					 explained below.</para> 
				<para>The quota clause in D4 has the following syntax: 
					 <programlisting>&lt;quota clause&gt; ::=
	return &lt;expression term&gt; by "{"&lt;ne order column definition commalist&gt;"}"

&lt;order column definition&gt; ::=
	&lt;column name&gt; [sort &lt;expression&gt;] [asc | desc]

&lt;column name&gt; ::=
	&lt;qualified identifier&gt;</programlisting></para> 
				<para>The expression specified by <emphasis>expression
					 term</emphasis> must be integer-valued, and specifies the number of rows to be
					 returned in the result set. The actual number of rows returned may be lower if
					 the input does not have enough rows to fulfill the request. If the by clause
					 does not specify a superset of some key of the input, the actual number of rows
					 may be greater if a tie occurs among the values of the columns given in the by
					 clause.</para> 
				<para>The result of a quota operator has the same columns, keys,
					 orders, and references as the input.</para> 
				<para>Modification to views defined using <symbol>return</symbol>
					 are propogated directly to the input.</para> 
				<para>The following examples illustrate the use of the quota
					 operator: 
					 <programlisting>select Employee return 3 by {Name};</programlisting> 
					 <programlisting>ID Name
--   ----
5   Jake
4   Jeff
6   Jeff
1   Joe</programlisting> 
					 <programlisting>select Employee return 3 by {Name, ID};</programlisting> 
					 <programlisting>ID Name
--  ----
5  Jake
4  Jeff
6  Jeff				</programlisting> 
					 <programlisting>select Employee return 3 by {Name desc};		</programlisting> 
					 <programlisting>ID Name
--  ----
3  Josh
2  John
1  Joe </programlisting> </para> 
		  </sect2> 
		  <sect2 id="D4LGExplode"> 
				<title><indexterm><primary>Explode</primary></indexterm><indexterm><primary>Table
								Expressions</primary><secondary>Explode</secondary></indexterm>Explode</title> 
				<para>The explode operator allows hierarchical queries to be
					 expressed. Optional include specifications allow both the sequence within the
					 hierarchy, and the level of the hierarchy to be included in the result
					 set.</para> 
				<para>The explode clause in D4 has the following syntax: 
					 <programlisting>&lt;explode clause&gt; ::=
	explode by &lt;expression term&gt; where &lt;expression term&gt; 
		[include level [&lt;column name&gt;] &lt;metadata&gt;]
		[include sequence [&lt;column name&gt;] &lt;metadata&gt;]</programlisting></para> 
				<para>The expressions specified in the by clause and the where
					 clause must be boolean-valued. The by clause specifies the explode condition,
					 and the where clause specifies the root condition. Within the explode
					 condition, the values of the current parent row are accessible by the name of
					 the column prefixed with the <symbol>parent</symbol> keyword.</para> 
				<para>The optional include level specification indicates that a
					 column of type <symbol>System.Integer</symbol> and named
					 <symbol>level</symbol>, or <emphasis>column name</emphasis> if supplied, be
					 included in the result set. The value for this column is the nesting level for
					 the row within the hierarchy.</para> 
				<para>The optional include sequence specification indicates that a
					 column of type <symbol>System.Integer</symbol> and named
					 <symbol>sequence</symbol>, or <emphasis>column name</emphasis> if supplied, be
					 included in the result set. The value for this column is the sequence of the
					 row within the hierarchy. The sequence column becomes a key of the
					 result.</para> 
				<para>The result of an explode operator has all the columns of the
					 input plus any included columns. All the keys are preserved, plus the key for
					 the sequence, if included. The orders, references, and metadata of the input
					 are preserved.</para> 
				<para>Modifications to views defined using <symbol>explode</symbol>
					 are propogated directly to the input.</para> 
				<para>The following example illustrates the use of the explode
					 operator: 
					 <programlisting>select Manager
		join (Employee rename { ID Manager_ID, Name Manager_Name })	
		join (Employee rename { ID Employee_ID, Name Employee_Name })	
		explode 
			by Manager_ID = parent Employee_ID
			where Manager_ID = 1 		
			include level		
			include sequence;</programlisting> 
					 <programlisting>Manager_ID Employee_ID Manager_Name Employee_Name level sequence 
---------- ----------- ------------ ------------- ----- -------- 
1          2           Joe          John          1     1        
2          4           John        Jeff            2     2        
4          5           Jeff          Jake          3     3        
2          6           John        Jeff            2     4        
1          3           Joe          Josh          1     5        </programlisting></para> 
		  </sect2> 
		  <sect2 id="D4LGAdorn"> 
				<title><indexterm><primary>Adorn</primary></indexterm><indexterm><primary>Table
								Expressions</primary><secondary>Adorn</secondary></indexterm>Adorn</title> 
				<para>The adorn operator allows metadata and structural information
					 to be added to the result set.</para> 
				<para>The adorn clause in D4 has the following syntax: 
					 <programlisting>&lt;adorn clause&gt; ::=
	adorn ["{"&lt;ne adorn item definition commalist&gt;"}"] &lt;metadata&gt;

&lt;adorn item definition&gt; ::=
	&lt;adorn column&gt; |
	&lt;key definition&gt; |
	&lt;order definition&gt; |
	&lt;constraint definition&gt;
	
&lt;adorn column&gt; ::=
	&lt;column name&gt; ["{"&lt;ne column definition item commalist&gt;"}"] &lt;metadata&gt;

&lt;column name&gt; ::=
	&lt;qualified identifier&gt;</programlisting></para> 
				<para>The adorn operator allows the definition of column defaults,
					 column constraints, column metadata, keys, orders, and constraints. Each of
					 these constructs is declared exactly as they are in the corresponding DDL
					 statements.</para> 
				<para>The result of an adorn operator has the same columns, keys,
					 orders, references, and metadata as the input, with the additional structural
					 and metadata information specified by the operator.</para> 
				<para>Modification to views defined using <symbol>adorn</symbol>
					 are propogated directly to the input.</para> 
				<para>The following example illustrates the use of the adorn
					 operator: 
					 <programlisting>select Employee
	adorn
	{
		ID { default 0 } tags { Frontend.Width = "5" },
		constraint IDValid ID &gt; 5 
		tags { DAE.Message = "ID must be greater than 5" }
	};	</programlisting> 
					 <programlisting>ID Name 
-- ---- 
6  Jeff </programlisting></para> 
		  </sect2> 
		  <sect2 id="D4LGRedefine"> 
				<title><indexterm><primary>Redefine</primary></indexterm><indexterm><primary>Table
								Expressions</primary><secondary>Redefine</secondary></indexterm>Redefine</title>
				
				<para>The redefine operator is shorthand for an
					 extend-remove-rename operation. For example, the expression: 
					 <programlisting>Employee redefine { ID := ID * 2 }</programlisting>is equivalent to the following expression: 
					 <programlisting>Employee add { ID * 2 X } remove { ID } rename { X ID }</programlisting></para> 
				<para>The redefine clause in D4 has the following syntax: 
					 <programlisting>&lt;redefine clause&gt; ::=
	redefine "{"&lt;redefine column commalist&gt;"}"
	
&lt;redefine column&gt; ::=
	&lt;column name&gt; := &lt;expression term&gt;

&lt;column name&gt; ::=
	&lt;qualified identifier&gt;</programlisting></para> 
				<para>Each column is redefined in terms of an expression. Values of
					 the current row are accessible by name within the expression.</para> 
				<para>The result of a redefine operation has the same column names
					 as the input, with the specified columns redefined as specified. If any
					 redefined column participates in a key, order, or reference, that structure is
					 no longer part of the result.</para> 
				<para>Modification to views defined using <symbol>redefine</symbol>
					 has the same semantics as the equivalent <symbol>add-remove-rename</symbol>
					 expression would have.</para> 
				<para>The following example illustrates the use of the redefine
					 operator: 
					 <programlisting>select Employee redefine { ID := ID * 2 };</programlisting> 
					 <programlisting>ID Name 
--   ---- 
2   Joe  
4   John 
6   Josh 
8   Jeff 
10 Jake 
12 Jeff </programlisting></para> 
		  </sect2> 
		  <sect2 id="D4LGUnion"> 
				<title><indexterm><primary>Union</primary></indexterm><indexterm><primary>Table
								Expressions</primary><secondary>Union</secondary></indexterm>Union</title> 
				<para>The union operator allows the rows of two table values to be
					 included in a single result set. If a given row appears in both inputs, it will
					 only appear once in the result. In other words, the union operation eliminates
					 duplicates.</para> 
				<para>The union clause in D4 has the following syntax: 
					 <programlisting>union &lt;expression term&gt;</programlisting></para> 
				<para>The expression given by <emphasis>expression term</emphasis>
					 must be table-valued. Both inputs to the union operation must be of the same
					 table type.</para> 
				<para>The result of a union operation has the same type as the
					 inputs. The key of the result is all columns of the table. The result has the
					 orders, references, and metadata from both inputs.</para> 
				<para>Modifications to views defined using <symbol>union</symbol>
					 are propogated to the inputs <symbol>A</symbol> and <symbol>B</symbol> as
					 follows: 
					 <itemizedlist> 
						  <listitem> 
								<para>Insert</para> 
								<para>If the newly inserted row can be inserted into
									 <symbol>A</symbol>, it is. If the newly inserted row can be inserted into
									 <symbol>B</symbol>, and was not already inserted by the insert into
									 <symbol>A</symbol>, it is inserted into <symbol>B</symbol>.</para> 
						  </listitem> 
						  <listitem> 
								<para>Update</para> 
								<para>Update is treated as a delete of the original
									 row, followed by an insert of the new version of the row. If both operations
									 can be performed against <symbol>A</symbol>, the update is performed against
									 <symbol>A</symbol>. If both operations can be performed against
									 <symbol>B</symbol>, and the operation did not already occur in
									 <symbol>B</symbol> by the update against <symbol>A</symbol>, the update is
									 performed against <symbol>B</symbol>. Only if the modification fails against
									 both inputs is an error returned.</para> 
						  </listitem> 
						  <listitem> 
								<para>Delete</para> 
								<para>If the deleted row can be deleted from
									 <symbol>A</symbol>, it is. If the deleted row can be deleted from
									 <symbol>B</symbol>, and was not already deleted by the delete from
									 <symbol>A</symbol>, it is deleted from <symbol>B</symbol>.</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>The following example illustrates the use of the union
					 operator: 
					 <programlisting>select (Employee where ID &lt;= 4) union (Employee where ID &gt;= 3); </programlisting> 
					 <programlisting>ID Name
-- ----
1  Joe
2  John
3  Josh
4  Jeff
5  Jake
6  Jeff </programlisting> </para> 
		  </sect2> 
		  <sect2 id="D4LGIntersect"> 
				<title><indexterm><primary>Intersect</primary></indexterm><indexterm><primary>Table
								Expressions</primary><secondary>Intersect</secondary></indexterm>Intersect</title>
				
				<para>The intersect operator computes the intersection of two table
					 values. If a given row appears in both inputs, it will appear in the
					 result.</para> 
				<para>The intersect clause in D4 has the following syntax: 
					 <programlisting>intersect &lt;expression term&gt;</programlisting></para> 
				<para>The expression given by <emphasis>expression term</emphasis>
					 must be table-valued. Both inputs to the intersect operator must be of the same
					 table type.</para> 
				<para>Because intersection is a special case of join, it has the
					 same semantics for type inference and updatability. See the discussion of the
					 join operator for this information.</para> 
				<para>The following example illustrates the use of the intersect
					 operator: 
					 <programlisting>select (Employee where ID &lt;= 4) intersect (Employee where ID &gt;= 3); </programlisting> 
					 <programlisting>ID Name 
-- ---- 
3  Josh 
4  Jeff </programlisting> </para> 
		  </sect2> 
		  <sect2 id="D4LGMinus"> 
				<title><indexterm><primary>Minus</primary></indexterm><indexterm><primary>Table
								Expressions</primary><secondary>Minus</secondary></indexterm>Minus</title> 
				<para>The minus operator computes the difference of two table
					 values. Only rows appearing in the first input and not the second will appear
					 in the result.</para> 
				<para>The minus clause in D4 has the following syntax: 
					 <programlisting>minus &lt;expression term&gt;</programlisting></para> 
				<para>The expression given by <emphasis>expression term</emphasis>
					 must be table-valued. Both inputs to the minus operator must be of the same
					 table type.</para> 
				<para>The result of the minus operator has the same table type as
					 both of the inputs. Keys, orders, references, and metadata are inferred from
					 the first input.</para> 
				<para>Modifications to views defined using <symbol>minus</symbol>
					 are propogated to the inputs <symbol>A</symbol> and <symbol>B</symbol> as
					 follows: 
					 <itemizedlist> 
						  <listitem> 
								<para>Insert</para> 
								<para>If the newly inserted row can be inserted into
									 <symbol>B</symbol>, it violates the predicate of the difference, and an error
									 is returned. Otherwise, it is inserted into <symbol>A</symbol>.</para> 
						  </listitem> 
						  <listitem> 
								<para>Update</para> 
								<para>If the new version of the row can be inserted
									 into <symbol>B</symbol>, it violates the predicate of the difference, and an
									 error is returned. Otherwise, the update is performed against
									 <symbol>A</symbol>.</para> 
						  </listitem> 
						  <listitem> 
								<para>Delete</para> 
								<para>The deleted row is deleted from
									 <symbol>A</symbol>.</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>The following example illustrates the use of the minus
					 operator: 
					 <programlisting>select Employee minus (Employee where ID &gt;= 3); </programlisting> 
					 <programlisting>ID Name
-- ----
1  Joe
2  John </programlisting> </para> 
		  </sect2> 
		  <sect2 id="D4LGTimes"> 
				<title><indexterm><primary>Times</primary></indexterm><indexterm><primary>Table
								Expressions</primary><secondary>Times</secondary></indexterm>Times</title> 
				<para>The times operator computes the cartesian product of the
					 inputs. For every row in the first input, a row appears in the result for every
					 row in the second input that is the concatenation of both rows.</para> 
				<para>The times clause in D4 has the following syntax: 
					 <programlisting>times &lt;expression term&gt;</programlisting></para> 
				<para>The expression given by <emphasis>expression term</emphasis>
					 must be table-valued. Inputs must have no column names in common.</para> 
				<para>Because times is a special case of join, it has the same
					 semantics for type inference and updatability. See the discussion of the join
					 operator for this information.</para> 
				<para>The following example illustrates the use of the times
					 operator: 
					 <programlisting>select Employee times (Employee rename {Name FirstName} over {FirstName}); </programlisting> 
					 <programlisting>ID Name FirstName
-- ----        ---------
1  Joe     Jake
1  Joe     Jeff
1  Joe     Joe
1  Joe     John
1  Joe     Josh
2  John   Jake
2  John   Jeff 
2  John   Joe 
2  John   John 
2  John   Josh 
3  Josh   Jake 
3  Josh   Jeff 
3  Josh   Joe 
3  Josh   John 
3  Josh   Josh 
4  Jeff     Jake 
4  Jeff     Jeff 
4  Jeff     Joe 
4  Jeff     John 
4  Jeff     Josh 
5  Jake   Jake 
5  Jake   Jeff 
5  Jake   Joe 
5  Jake   John 
5  Jake   Josh 
6  Jeff     Jake 
6  Jeff     Jeff 
6  Jeff     Joe
6  Jeff     John 
6  Jeff     Josh </programlisting> </para> 
		  </sect2> 
		  <sect2 id="D4LGJoin"> 
				<title><indexterm><primary>Join</primary></indexterm><indexterm><primary>Table
								Expressions</primary><secondary>Join</secondary></indexterm>Join</title> 
				<para>The join operator computes the combination of two table
					 values based on the matching rows for a given set of columns. There are two
					 types of joins in D4, the <emphasis>natural join</emphasis> and the
					 <emphasis>conditioned join</emphasis>. </para> 
				<para>The natural join simply takes two table values as input and
					 uses the commonly named columns to perform the join. The conditioned join
					 includes a by clause which specifies the join condition.</para> 
				<para>Note that the two forms of the join operator are equivalent
					 in terms of expressive power. Both forms are included in D4 to allow for
					 different user preferences. The natural join lends itself to a database design
					 in which column names are unique across the database, while the conditioned
					 join lends itself to a design in which column names are only unique within
					 tables.</para> 
				<para>The join clause in D4 has the following syntax: 
					 <programlisting>&lt;join clause&gt; ::=
	join &lt;join specifier&gt;

&lt;join specifier&gt; ::=
	&lt;expression term&gt; [by &lt;expression term&gt;]</programlisting></para> 
				<para>The result of a join operator on inputs <symbol>A</symbol>
					 and <symbol>B</symbol> having column sets <symbol>X</symbol>,
					 <symbol>Y</symbol>, and <symbol>Z</symbol>, where <symbol>A</symbol> has the
					 columns <symbol>{ X, Y }</symbol> and <symbol>B</symbol> has the columns
					 <symbol>{ Y, Z }</symbol> has the columns <symbol>{ X, Y, Z }</symbol>.
					 <symbol>Y</symbol> represents the columns common to both inputs. Note that each
					 of <symbol>X</symbol>, <symbol>Y</symbol>, and <symbol>Z</symbol> may be an
					 empty set. For a conditioned join, <symbol>Y</symbol> is required to be an
					 empty set.</para> 
				<para>The body of the result has a row for each row in
					 <symbol>A</symbol> that matches the values for the columns given in
					 <symbol>Y</symbol> for natural joins, or the condition for conditioned joins,
					 for each row in <symbol>B</symbol>. The join operator is equivalent to a
					 cartesian product of the inputs, followed by a restriction using the join
					 condition.</para> 
				<para>Because the join condition specifies an equi-join, the
					 <emphasis>cardinality</emphasis> of the join may be determined. There are four
					 possibilities: 
					 <itemizedlist> 
						  <listitem> 
								<para>One-to-one:</para> 
								<para>The join columns form a unique key in both
									 inputs.</para> 
						  </listitem> 
						  <listitem> 
								<para>One-to-many:</para> 
								<para>The join columns form a unique key in the left
									 input, but not in the right.</para> 
						  </listitem> 
						  <listitem> 
								<para>Many-to-one:</para> 
								<para>The join columns form a unique key in the right
									 input, but not in the left.</para> 
						  </listitem> 
						  <listitem> 
								<para>Many-to-many:</para> 
								<para>The join columns do not form a unique key in
									 either input.</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>The keys of the result are inferred from the keys of both
					 inputs, and the cardinality of the join: 
					 <itemizedlist> 
						  <listitem> 
								<para>One-to-one:</para> 
								<para>The result has all the keys from both
									 inputs.</para> 
						  </listitem> 
						  <listitem> 
								<para>One-to-many:</para> 
								<para>The result has all the keys from the right input
									 only.</para> 
						  </listitem> 
						  <listitem> 
								<para>Many-to-one:</para> 
								<para>The result has all the keys from the left input
									 only.</para> 
						  </listitem> 
						  <listitem> 
								<para>Many-to-many:</para> 
								<para>For each key in the first input, for each key in
									 the second input, the result has a key that is the union of the columns in both
									 keys. In other words, the result has the cartesian product of the keys of both
									 inputs.</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>The result has all the orders, references, and metadata from
					 both inputs.</para> 
				<para>Modification to views defined using <symbol>join</symbol> is
					 supported by projecting the modification over the columns of each input.</para>
				
				<para>The following sections describe the natural and conditioned
					 joins.</para> 
				<sect3 id="D4LGNaturalJoins"> 
					 <title><indexterm><primary>Natural
									 Joins</primary></indexterm><indexterm><primary>Join</primary><secondary>Natural
									 Joins</secondary></indexterm>Natural Joins</title> 
					 <para>The natural join uses the commonly named columns, if any,
						  in the inputs to perform the join. A natural join is by definition an
						  <emphasis>equi-join</emphasis>. The commonly named columns are only included
						  once in the result.</para> 
					 <para>If the inputs have no column names in common, the natural
						  join degrades to times. If the inputs have all column names in common, the
						  natural join degrades to intersection. In both cases, type inference and
						  updatability are unaffected.</para> 
					 <para>The following example illustrates the use of the natural
						  join operator: 
						  <programlisting>select Employee join EmployeePhone;			  </programlisting> 
						  <programlisting>ID Name   Phone
--  ----  --------
1  Joe    555-1000 
1  Joe    555-1234 
2  John   555-4321
4  Jeff   555-4444 
5  Jake   555-5678 </programlisting> </para> 
				</sect3> 
				<sect3 id="D4LGConditionedJoins"> 
					 <title><indexterm><primary>Conditioned
									 Joins</primary></indexterm><indexterm><primary>Join</primary><secondary>Conditioned
									 Joins</secondary></indexterm>Conditioned Joins</title> 
					 <para>The conditioned join allows the join condition to be
						  specified as part of the join. The input tables must have no column names in
						  common.</para> 
					 <para>The expression specified within the by clause by
						  <emphasis>expression term</emphasis> must be boolean-valued and must specify an
						  equi-join. These requirements are enforced by the compiler. Within the
						  expression, the current values of both rows are accessible by column
						  name.</para> 
					 <para>The following example illustrates the use of the
						  conditioned join operator: 
						  <programlisting>select (Employee rename E) join 
	(EmployeePhone rename EP) by E.ID = EP.ID remove { EP.ID }; </programlisting> 
						  <programlisting>E.ID   E.Name    EP.Phone
------ --------  ----------- 
1      Joe       555-1000 
1      Joe       555-1234 
2      John      555-4321 
4      Jeff      555-4444 
5      Jake      555-5678 </programlisting> </para> 
				</sect3> 
		  </sect2> 
		  <sect2 id="D4LGOuterJoin"> 
				<title><indexterm><primary>Outer
								Join</primary></indexterm><indexterm><primary>Table
								Expressions</primary><secondary>Outer Join</secondary></indexterm>Outer
					 Join</title> 
				<para>The outer join is a specialized operator for use in building
					 a type of result set common in client applications. Strictly speaking, the
					 outer join is not a table operator. </para> 
				<para>The result of an outer join is the same as a join, except
					 that rows in one side for which no matching row was found are still included in
					 the set, with the column values for the other side set to a "&lt;no value&gt;"
					 placeholder. This placeholder is not a value of any domain, which is the reason
					 outer join is not a table operator.</para> 
				<para>In addition to specifying a natural or conditioned outer
					 join, the outer join may be left or right. Left indicates that all rows in the
					 left input should be preserved, while right indicates that all rows in the
					 right input should be preserved.</para> 
				<para>The outer join clause in D4 has the following syntax: 
					 <programlisting>&lt;outer join clause&gt; ::=
	(left | right) (join | lookup) &lt;join specifier&gt;
		[include rowexists [&lt;column name&gt;] &lt;metadata&gt;]

&lt;join specifier&gt; ::=
	&lt;expression term&gt; [by &lt;expression term&gt;]

&lt;column name&gt; ::=
	&lt;qualified identifier&gt;</programlisting></para> 
				<para>The semantics for type inference and updatability are the
					 same as for the join operator with two exceptions. First, the optional
					 rowexists column, and second, the lookup operator.</para> 
				<para>The optional rowexists column is used to indicate whether a
					 row is an actual join match, or is included in the result because the join is
					 outer. This column is boolean-valued, and will be true whenever the row is a
					 join match, and false otherwise. This column is updatable, and causes the
					 insertion or deletion of a row into the outer input of the operation. Setting
					 the rowexists column true causes a row to be inserted into the outer input,
					 while setting the rowexists column false causes a row to be deleted from the
					 outer input.</para> 
				<para>The lookup operator has the same semantics for retrieval, but
					 modifications do not propogate through the lookup. For example, in a view
					 defined by <symbol>A left lookup B</symbol>, an insert would be propogated to
					 <symbol>A</symbol>, but not to <symbol>B</symbol>. The lookup operator is used
					 primarily by client applications to control the update semantics involved in an
					 expression.</para> 
				<para>The following examples illustrate the use of the outer join
					 operator: 
					 <programlisting>select Employee left join EmployeePhone;</programlisting> 
					 <programlisting>ID  Name Phone 
-- ----  ---------- 
1  Joe   555-1000 
1  Joe   555-1234 
2  John  555-4321 
3  Josh  &lt;no value&gt; 
4  Jeff  555-4444 
5  Jake  555-5678 
6  Jeff  &lt;no value&gt; </programlisting> 
					 <programlisting>select Employee right join EmployeePhone;	  </programlisting> 
					 <programlisting>ID  Name       Phone 
--  ---------- -------- 
1   Joe        555-1000
1   Joe        555-1234 
2   John       555-4321 
4   Jeff       555-4444 
5   Jake       555-5678 
10 &lt;no value&gt;  411 
12 &lt;no value&gt;  911 </programlisting> 
					 <programlisting>select Employee left lookup EmployeePhone include rowexists Extended; </programlisting> 
					 <programlisting>ID Name Extended Phone 
-- ---- -------- ----------
1  Joe  True     555-1000 
1  Joe  True     555-1234 
2  John True     555-4321 
3  Josh False    &lt;no value&gt; 
4  Jeff True     555-4444 
5  Jake True     555-5678 
6  Jeff False    &lt;no value&gt; </programlisting> 
					 <programlisting>create view EmpWithPhone
	Employee left lookup EmployeePhone;

select EmpWithPhone; </programlisting> 
					 <programlisting>ID Name Phone
-- ---- ----------
1  Joe  555-1000
1  Joe  555-1234 
2  John 555-4321 
3  Josh &lt;no value&gt; 
4  Jeff 555-4444 
5  Jake 555-5678 
6  Jeff &lt;no value&gt; </programlisting> 
					 <programlisting>// will be ignored since phone is across lookup
update EmpWithPhone set {Phone := "1701"};
select EmpWithPhone; </programlisting> 
					 <programlisting>ID Name  Phone
-- ----  ----------
1  Joe   555-1000
1  Joe   555-1234 
2  John  555-4321 
3  Josh  &lt;no value&gt; 
4  Jeff  555-4444 
5  Jake  555-5678 
6  Jeff  &lt;no value&gt; </programlisting> </para> 
		  </sect2> 
		  <sect2 id="D4LGComparisonOperators"> 
				<title><indexterm><primary>Comparison
								Operators</primary></indexterm><indexterm><primary>Table
								Expressions</primary><secondary>Comparison
								Operators</secondary></indexterm>Comparison Operators</title> 
				<para>The following comparison operators are defined for tables: 
					 <itemizedlist> 
						  <listitem> 
								<para><symbol>iEqual</symbol>(<symbol>=</symbol>) and
									 <symbol>iNotEqual</symbol>(<symbol>&lt;&gt;</symbol>)</para> 
								<para>Returns true if the given table values are equal.
									 Two table values are equal if they are of the same table type, and they have
									 the same set of rows. For example: 
									 <programlisting>begin
	var LTable1 : table { ID : Integer } := 
		table { row { 5 ID }, row { 6 ID }, row { 7 ID } };
	var LTable2 : table { ID : Integer } := 
		table { row { 5 ID }, row { 6 ID }, row { 7 ID } };

	if not(LTable1 = LTable2) then
		raise Error("Table values are not equal");

	// equivalent formulation
	if not exists(LTable1 minus LTable2) and 
		not exists (LTable2 minus LTable1) then
		raise Error("Table values are equal");
end;</programlisting></para> 
						  </listitem> 
						  <listitem> 
								<para><symbol>iLess</symbol>(<symbol>&lt;</symbol>)</para>
								
								<para>Returns true if the first table value is a proper
									 subset of the second table value. A given table value <symbol>A</symbol> is a
									 proper subset of some table value <symbol>B</symbol> if <symbol>A</symbol> and
									 <symbol>B</symbol> are both of the same table type, and all the rows in
									 <symbol>A</symbol> are in <symbol>B</symbol>, and there is at least one row in
									 <symbol>B</symbol> that is not in <symbol>A</symbol>. For example: 
									 <programlisting>begin
	var LTable1 : table { ID : Integer } := 
		table { row { 5 ID }, row { 6 ID } };
	var LTable2 : table { ID : Integer } := 
		table { row { 5 ID }, row { 6 ID }, row { 7 ID } };

	if not(LTable1 &lt; LTable2) then
		raise Error("LTable1 is not a proper subset of LTable2");

	// equivalent formulation
	if not exists (LTable1 minus LTable2) and 
		exists (LTable2 minus LTable1) then 
		raise Error("LTable1 is a proper subset of LTable2");

	if not exists</programlisting></para> 
						  </listitem> 
						  <listitem> 
								<para><symbol>iInclusiveLess</symbol>(<symbol>&lt;=</symbol>)</para>
								
								<para>Returns true if the first table value is a
									 subset, not necessarily proper, of the second table value. A given table value
									 <symbol>A</symbol> is a subset of some table value <symbol>B</symbol> if
									 <symbol>A</symbol> and <symbol>B</symbol> are both of the same table type, and
									 all the rows in <symbol>A</symbol> are in <symbol>B</symbol>. For example: 
									 <programlisting>begin
	var LTable1 : table { ID : Integer } := 
		table { row { 5 ID }, row { 6 ID } };
	var LTable2 : table { ID : Integer } := 
		table { row { 5 ID }, row { 6 ID }, row { 7 ID } };

	if not(LTable1 &lt;= LTable2) then
		raise Error("LTable1 is not a subset of LTable2");

	// equivalent formulation
	if not exists (LTable1 minus LTable2) then 
		raise Error("LTable1 is a subset of LTable2");
end;</programlisting></para> 
						  </listitem> 
						  <listitem> 
								<para><symbol>iGreater</symbol>(<symbol>&gt;</symbol>)</para>
								
								<para>Returns true if the first table value is a proper
									 superset of the second table value. A given table value <symbol>A</symbol> is a
									 proper superset of some table value <symbol>B</symbol> if <symbol>A</symbol>
									 and <symbol>B</symbol> are both of the same table type, and all the rows in
									 <symbol>B</symbol> are in <symbol>A</symbol>, and there is at least one row in
									 <symbol>A</symbol> that is not in <symbol>B</symbol>. For example: 
									 <programlisting>begin
	var LTable1 : table { ID : Integer } := 
		table { row { 5 ID }, row { 6 ID }, row { 7 ID } };
	var LTable2 : table { ID : Integer } := 
		table { row { 5 ID }, row { 6 ID } };

	if not(LTable1 &gt; LTable2) then
		raise Error("LTable1 is not a proper superset of LTable2");

	// equivalent formulation
	if not exists (LTable2 minus LTable1) and 
		exists (LTable1 minus LTable2) then 
		raise Error("LTable1 is a proper superset of LTable2");
end;</programlisting></para> 
						  </listitem> 
						  <listitem> 
								<para><symbol>iInclusiveGreater</symbol>(<symbol>&gt;=</symbol>)</para>
								
								<para>Returns true if the first table value is a
									 superset, not necessarily proper, of the second table value. A given table
									 value <symbol>A</symbol> is a superset of some table value <symbol>B</symbol>
									 if <symbol>A</symbol> and <symbol>B</symbol> are both of the same table type,
									 and all the rows in <symbol>B</symbol> are in <symbol>A</symbol>. For example: 
									 <programlisting>begin
	var LTable1 : table { ID : Integer } := 
		table { row { 5 ID }, row { 6 ID }, row { 7 ID } };
	var LTable2 : table { ID : Integer } := 
		table { row { 5 ID }, row { 6 ID } };

	if not (LTable1 &gt;= LTable2) then
		raise Error("LTable1 is not a superset of LTable2");

	// equivalent formulation
	if not exists (LTable2 minus LTable1) then 
		raise Error("LTable1 is a superset of LTable2");
end;</programlisting></para> 
						  </listitem> 
						  <listitem> 
								<para><symbol>iCompare</symbol>(<symbol>?=</symbol>)</para>
								
								<para>The <symbol>iCompare</symbol> operator is defined
									 in terms of the other comparison operators: 
									 <programlisting>A ?= B = if A = B then 0 else if A &lt; B then -1 else 1;</programlisting></para> 
						  </listitem> 
					 </itemizedlist></para> 
		  </sect2> 
		  <sect2 id="D4LGMembershipOperators"> 
				<title><indexterm><primary>Membership
								Operators</primary></indexterm><indexterm><primary>Table
								Expressions</primary><secondary>Membership
								Operators</secondary></indexterm>Membership Operators</title> 
				<para>Two overloads of the membership operator <symbol>in</symbol>
					 are defined for use with tables: 
					 <itemizedlist> 
						  <listitem> 
								<para><symbol>iIn(System.Alpha, table)</symbol></para> 
								<para>Returns true if the given scalar value is in the
									 specified table. The table value must have a single column or the compiler will
									 report an error. For example: 
									 <programlisting>begin
	var LTable : table { ID : Integer } := 
		table { row { 1 ID }, row { 2 ID }, row { 3 ID } };
	if 1 in LTable then
		raise Error("1 is in LTable");
end;</programlisting></para> 
						  </listitem> 
						  <listitem> 
								<para><symbol>iIn(row, table)</symbol></para> 
								<para>Returns true if the given row value is in the
									 specified table. The heading for the row and table values must match. For
									 example: 
									 <programlisting>begin
	var LTable : table { ID : Integer } := 
		table { row { 1 ID }, row { 2 ID }, row { 3 ID } };
	if row { 1 ID } in LTable then
		raise Error("row { 1 ID } is in LTable");
end;</programlisting></para> 
						  </listitem> 
					 </itemizedlist></para> 
		  </sect2> 
		  <sect2 id="D4LGRowExtractor"> 
				<title><indexterm><primary>Row
								Extractor</primary></indexterm><indexterm><primary>Table
								Expressions</primary><secondary>Row Extractor</secondary></indexterm>Row
					 Extractor</title> 
				<para>The row extractor allows a single row to be extracted from a
					 table value. It is an error to use a row extractor on a table value that does
					 not have exactly one row. For example: 
					 <programlisting>begin
	var LTable : table { ID : Integer } := table { row { 1 ID } };
	var LRow : row { ID : Integer } := row from LTable;
	insert table { row { 2 ID } } into LTable;
	// this is an error because the row to be extracted cannot be determined
	LRow := row from LTable; 
end;</programlisting></para> 
		  </sect2> 
	 </sect1> 
	 <sect1 id="D4LGImperativeStatements"> 
		  <title><indexterm><primary>Imperative
						  Statements</primary></indexterm><indexterm><primary>D4 Language
						  Guide</primary><secondary>Imperative
						  Statements</secondary></indexterm>Imperative Statements</title> 
		  <para>This section covers the imperative statements available in the D4
				language. These include variable declaration and assignment, flow control
				constructs, and exception handling statements.</para> 
		  <para>Imperative statements in D4 have the following syntax: 
				<programlisting>&lt;imperative statement&gt; ::=
	&lt;block&gt; |
	&lt;expression&gt; |
	&lt;variable declaration statement&gt; |
	&lt;assignment statement&gt; |
	&lt;exit statement&gt; |
	&lt;if statement&gt; |
	&lt;while statement&gt; |
	&lt;do while statement&gt; |
	&lt;for statement&gt; |
	&lt;repeat statement&gt; |
	&lt;break statement&gt; |
	&lt;continue statement&gt; |
	&lt;case statement&gt; |
	&lt;try finally statement&gt; |
	&lt;try except statement&gt; |
	&lt;try commit statement&gt; |
	&lt;raise statement&gt;</programlisting></para> 
		  <para>The following sections cover each statement in detail.</para> 
		  <sect2 id="D4LGVariables1"> 
				<title><indexterm><primary>Variables</primary></indexterm><indexterm><primary>Imperative
								Statements</primary><secondary>Variables</secondary></indexterm>Variables</title>
				
				<para>There are two types of variables in D4, global, and local.
					 Only table variables may be global, and are declared through the data
					 definition language statements of D4. Local variables may be of any type, and
					 are only valid for the scope in which they are declared. For more information
					 on scoping, see the Blocks and Scoping section.</para> 
				<sect3 id="D4LGVariableDeclarationStatement"> 
					 <title><indexterm><primary>Variable Declaration
									 Statement</primary></indexterm><indexterm><primary>Variables</primary><secondary>Variable
									 Declaration Statement</secondary></indexterm>Variable Declaration
						  Statement</title> 
					 <para>Variable declaration statements in D4 have the following
						  syntax: 
						  <programlisting>&lt;variable declaration statement&gt; ::=
	var &lt;ne variable definition commalist&gt;
	
&lt;variable definition&gt; ::=
	&lt;qualified identifier&gt; : &lt;type specifier&gt; [:= &lt;expression&gt;]</programlisting></para> 
					 <para>Each variable definition includes an optional
						  initialization expression which is the initial value for the variable. If no
						  initialization expression is specified, the variable is assigned the default
						  value for the type. If no default is specified, the variable is uninitialized.
						  It is an error to access the value of an uninitialized variable.</para> 
				</sect3> 
				<sect3 id="D4LGAssignmentStatement"> 
					 <title><indexterm><primary>Assignment
									 Statement</primary></indexterm><indexterm><primary>Variables</primary><secondary>Assignment
									 Statement</secondary></indexterm>Assignment Statement</title> 
					 <para>Assignment statements in D4 have the following syntax: 
						  <programlisting>&lt;assignment statement&gt; ::=
	&lt;target&gt; := &lt;expression&gt;

&lt;target&gt; ::=
	&lt;expression&gt;</programlisting></para> 
					 <para>The expression specified by <emphasis>target</emphasis>
						  must be a valid assignment target. This includes properties of representations
						  of scalar values, and updatable expressions like table expressions. The
						  expression specified by <emphasis>expression</emphasis> must be
						  <emphasis>of</emphasis> the same type as the assignment target. More precisely,
						  the type of the source expression must be a subtype of the type of the
						  assignment target.</para> 
				</sect3> 
		  </sect2> 
		  <sect2 id="D4LGBlocksandScoping"> 
				<title><indexterm><primary>Blocks and
								Scoping</primary></indexterm><indexterm><primary>Imperative
								Statements</primary><secondary>Blocks and Scoping</secondary></indexterm>Blocks
					 and Scoping</title> 
				<para>Blocks are the primary means of establishing scope in D4. A
					 <emphasis>scope</emphasis> defines the lifetime of variables within the DAE.
					 Globally scoped variables are persisted with the database state, while locally
					 scoped variables are only available temporarily.</para> 
				<para>Local scopes may be nested to any level. Variables declared
					 within a local scope must be uniquely named, but may hide variables declared in
					 the global scope. Within a nested local scope, variables declared in parent
					 scopes are visible.</para> 
				<para>The following constructs also establish scope within their
					 respective blocks: 
					 <itemizedlist> 
						  <listitem> 
								<para>Do-while statements.</para> 
						  </listitem> 
						  <listitem> 
								<para>Repeat-until statements.</para> 
						  </listitem> 
						  <listitem> 
								<para>Try-except statements, in both the try block, and
									 each exception handler.</para> 
						  </listitem> 
						  <listitem> 
								<para>Try-finally statements, in both the try block,
									 and the finally block.</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>Blocks in D4 have the following syntax: 
					 <programlisting>&lt;block&gt; ::=
	begin
		&lt;terminated statement list&gt;
	end</programlisting></para> 
				<para>The following example illustrates the use of blocks in D4: 
					 <programlisting>begin
	var I : Integer := 1;
	begin
		var J : Integer := 5;
		J := J + I; // I is visible;

		// Global variables are visible
		J := J + Count(System.Objects); 
	end;
	I := I + 1; // J is out of scope
end;</programlisting></para> 
		  </sect2> 
		  <sect2 id="D4LGFlowControl"> 
				<title><indexterm><primary>Flow
								Control</primary></indexterm><indexterm><primary>Imperative
								Statements</primary><secondary>Flow Control</secondary></indexterm>Flow
					 Control</title> 
				<para>Flow control statements determine the sequence of execution
					 in a D4 program. These include branching statements and looping
					 statements.</para> 
				<sect3 id="D4LGExitStatement"> 
					 <title><indexterm><primary>Exit
									 Statement</primary></indexterm><indexterm><primary>Flow
									 Control</primary><secondary>Exit Statement</secondary></indexterm>Exit
						  Statement</title> 
					 <para>The exit statement unconditionally exits an operator.
						  Control passes immediately back to the caller. If an exit statement is used
						  within a try-finally, the finally block is executed.</para> 
					 <para>Exit statements in D4 have the following syntax: 
						  <programlisting>&lt;exit statement&gt; ::=
	exit</programlisting></para> 
					 <para>The following example illustrates the use of the exit
						  statement: 
						  <programlisting>create operator TestExit(var AValue : Integer)
begin
	if AValue &lt; 0 then
		exit;

	/* 
	   this statement will not be executed
	   if AValue is less than zero
	*/
	AValue := AValue * 10; 
end;</programlisting></para> 
				</sect3> 
				<sect3 id="D4LGBranchingStatements"> 
					 <title><indexterm><primary>Branching
									 Statements</primary></indexterm><indexterm><primary>Flow
									 Control</primary><secondary>Branching
									 Statements</secondary></indexterm>Branching Statements</title> 
					 <para>Branching statements allow for the conditional execution
						  of different blocks of code based on a specified expression.</para> 
					 <sect4 id="D4LGIfStatement"> 
						  <title><indexterm><primary>If
										  Statement</primary></indexterm><indexterm><primary>Branching
										  Statements</primary><secondary>If Statement</secondary></indexterm>If
								Statement</title> 
						  <para>The if statement allows statements to be executed
								conditionally.</para> 
						  <para>If statements in D4 have the following syntax: 
								<programlisting>&lt;if statement&gt; ::=
	if &lt;expression&gt; then
		&lt;statement&gt;
	[else &lt;statement&gt;]</programlisting></para> 
						  <para>The expression specified by
								<emphasis>expression</emphasis> must be boolean-valued. If the expression
								evaluates to true, the statement given by <emphasis>statement</emphasis> is
								executed. The if statement may include an optional else clause which specifies
								a statement to be executed if the expression evaluates to false.</para> 
						  <para>The following example illustrates the use of the if
								statement: 
								<programlisting>if Count(System.Objects) = 0 then
	raise Error("No objects defined in the system catalog")
else
	raise Error("Count of objects in the system is " + 
		Count(System.Objects).ToString());</programlisting></para> 
					 </sect4> 
					 <sect4 id="D4LGCaseStatement"> 
						  <title><indexterm><primary>Case
										  Statement</primary></indexterm><indexterm><primary>Branching
										  Statements</primary><secondary>Case Statement</secondary></indexterm>Case
								Statement</title> 
						  <para>Case statements allow the execution of a specific
								statement based on a list of conditions. Case statements are a syntactic
								shorthand for an iterated if statement.</para> 
						  <para>The case statement has two forms. One is based on an
								expression, one allows a conditional to be associated with each case
								item.</para> 
						  <para>In the first form, the case statement is based on an
								expression. Each case statement item contains a single expression which is
								compared against the case expression. If the case item expression is equal to
								the case expression, the statement associated with the item is selected. Each
								case item is compared with the case expression until a match is found. If no
								match is found, the default case item is selected.</para> 
						  <para>In the second form, the case statement is not based
								on an expression, rather, each case item contains a boolean-valued condition.
								The first case item for which the condition evaluates to true is selected. The
								default case item is selected if no case item evaluated to true.</para> 
						  <para> If no case item is selected the statement is
								effectively a no-op. The selected statement is executed, and control passes to
								the first statement following the case statement.</para> 
						  <para>Case statements in D4 have the following syntax: 
								<programlisting>&lt;case statement&gt; ::=
	case [&lt;expression&gt;]
		&lt;ne case statement item list&gt;
		[else &lt;terminated statement&gt;]
	end;

&lt;case statement item&gt; ::=
	when &lt;expression&gt; then &lt;terminated statement&gt;</programlisting></para> 
						  <para>The following examples illustrate the use of the case
								statement in D4: 
								<programlisting>create operator DigitToWords(const ADigit : Integer) : String
begin
	case ADigit
		when 0 then result := 'Zero';
		when 1 then result := 'One';
		when 2 then result := 'Two';
		when 3 then result := 'Three';
		when 4 then result := 'Four';
		when 5 then result := 'Five';
		when 6 then result := 'Six';
		when 7 then result := 'Seven';
		when 8 then result := 'Eight';
		when 9 then result := 'Nine';
		else
			raise Error("Digit out of range: " + ADigit.ToString());
	end;
end;</programlisting> 
								<programlisting>create operator DigitToWords(const ADigit : Integer) : String
begin
	case
		when ADigit = 0 then result := 'Zero';
		when ADigit = 1 then result := 'One';
		when ADigit = 2 then result := 'Two';
		when ADigit = 3 then result := 'Three';
		when ADigit = 4 then result := 'Four';
		when ADigit = 5 then result := 'Five';
		when ADigit = 6 then result := 'Six';
		when ADigit = 7 then result := 'Seven';
		when ADigit = 8 then result := 'Eight';
		when ADigit = 9 then result := 'Nine';
		else
			raise Error("Digit out of range: " + ADigit.ToString());
	end;
end;</programlisting></para> 
					 </sect4> 
				</sect3> 
				<sect3 id="D4LGLoopingStatements"> 
					 <title><indexterm><primary>Looping
									 Statements</primary></indexterm><indexterm><primary>Flow
									 Control</primary><secondary>Looping Statements</secondary></indexterm>Looping
						  Statements</title> 
					 <para>Looping statements allow for a given statement to be
						  executed multiple times. There are four types of looping statements in D4: the
						  for statement, the while statement, the do-while statement, and the
						  repeat-until statement.</para> 
					 <para>Note that all these looping constructs can be expressed
						  in terms of a simple while loop. The variations are provided to allow the
						  developer to build more readable statements, as each loop is appropriate for
						  different scenarios.</para> 
					 <sect4 id="D4LGForStatement"> 
						  <title><indexterm><primary>For
										  Statement</primary></indexterm><indexterm><primary>Looping
										  Statements</primary><secondary>For Statement</secondary></indexterm>For
								Statement</title> 
						  <para>The for statement allows a given statement to be
								executed a specified number of times.</para> 
						  <para>For statements in D4 have the following syntax: 
								<programlisting>&lt;for statement&gt; ::=
	for 
		&lt;qualified identifier&gt; [: &lt;type specifier&gt;] 
		:= &lt;expression&gt; (to | downto)
		&lt;expression&gt; 
		[step &lt;expression&gt;] 
		do &lt;statement&gt;</programlisting></para> 
						  <para>The for statement uses an <emphasis>iteration control
								variable</emphasis>, or ICV, to control statement iteration. The ICV may be an
								existing variable within the scope, or it may be declared by specifying the
								type of the variable within the for statement. In either case, the ICV must be
								initialized to the initial bound for the iteration. The final bound is then
								specified as well as the iteration direction. An optional step clause specifies
								the magnitude of the increment or decrement to the ICV. The for statement is a
								post-test loop, so the statement is run, then the ICV is tested against the
								final bound. The type of the variable used for the ICV must have addition or
								subtraction operators defined as appropriate, as well as the necessary
								comparison operators.</para> 
						  <para>The following example illustrates the use of the for
								statement: 
								<programlisting>create table Data { ID : Integer, key { ID } };

for I : Integer := 10 to 100 step 10 do
	insert table { row { I ID } } into Data;

select Data;</programlisting> 
								<programlisting>ID  
--- 
10  
20  
30  
40  
50  
60  
70  
80  
90  
100</programlisting></para> 
					 </sect4> 
					 <sect4 id="D4LGWhileStatement"> 
						  <title><indexterm><primary>While
										  Statement</primary></indexterm><indexterm><primary>Looping
										  Statements</primary><secondary>While Statement</secondary></indexterm>While
								Statement</title> 
						  <para>The while statement allows a given statement to be
								executed as long as a specified condition is true. The while statement is a
								pre-test loop, meaning that the condition is checked, and then the statement is
								executed.</para> 
						  <para>While statements in D4 have the following syntax: 
								<programlisting>&lt;while statement&gt; ::=
	while &lt;expression&gt; do &lt;statement&gt;</programlisting></para> 
						  <para>The expression specified by
								<emphasis>expression</emphasis> must be boolean-valued.</para> 
						  <para>The following example illustrates the use of the
								while statement: 
								<programlisting>begin
	var I : Integer := 0;
	while I &lt; 20 do
		I := I + 1;
end;</programlisting></para> 
					 </sect4> 
					 <sect4 id="D4LGDoWhileStatement"> 
						  <title><indexterm><primary>Do While
										  Statement</primary></indexterm><indexterm><primary>Looping
										  Statements</primary><secondary>Do While Statement</secondary></indexterm>Do
								While Statement</title> 
						  <para>The do-while statement allows a given block to be
								executed as long as a specified condition is true. The do-while statement is a
								post-test loop, meaning that the statement is executed, then the condition is
								tested.</para> 
						  <para>Do while statements in D4 have the following syntax: 
								<programlisting>&lt;do while statement&gt; ::=
	do &lt;terminated statement list&gt; while &lt;expression&gt;</programlisting></para> 
						  <para>The expression specified by
								<emphasis>expression</emphasis> must be boolean-valued.</para> 
						  <para>The following example illustrates the use of the
								do-while statement: 
								<programlisting>begin
	var I : Integer := 0;
	do
		I := I + 1;
	while I &lt; 20;
end;</programlisting></para> 
					 </sect4> 
					 <sect4 id="D4LGRepeatUntilStatement"> 
						  <title><indexterm><primary>Repeat Until
										  Statement</primary></indexterm><indexterm><primary>Looping
										  Statements</primary><secondary>Repeat Until
										  Statement</secondary></indexterm>Repeat Until Statement</title> 
						  <para>The repeat-until statement allows a given block to be
								executed until a specified condition returns true. The repeat until is a
								post-test loop, meaning that the statement is executed, then the condition is
								tested.</para> 
						  <para>Repeat until statements in D4 have the following
								syntax: 
								<programlisting>&lt;repeat statement&gt; ::=
	repeat &lt;terminated statement list&gt; until &lt;condition&gt;
	
&lt;condition&gt; ::=
	&lt;expression&gt;</programlisting></para> 
						  <para>The expression given by
								<emphasis>condition</emphasis> must be boolean-valued.</para> 
						  <para>The following example illustrates the use of the
								repeat-until statement: 
								<programlisting>begin
	var I : Integer := 0;
	repeat
		I := I + 1;
	until I &gt;= 20;
end;</programlisting></para> 
					 </sect4> 
					 <sect4 id="D4LGBreakandContinue"> 
						  <title><indexterm><primary>Break and
										  Continue</primary></indexterm><indexterm><primary>Looping
										  Statements</primary><secondary>Break and Continue</secondary></indexterm>Break
								and Continue</title> 
						  <para>Break and continue statements allow for fine grained
								control of loop iteration. The break statement breaks out of a given loop,
								passing control to the first statement after the loop. The continue statement
								jumps to the beginning of the next iteration, passing control to the beginning
								of the iterated statement.</para> 
						  <para>Break and continue statements in D4 have the
								following syntax: 
								<programlisting>&lt;break statement&gt; ::=
	break

&lt;continue statement&gt; ::=
	continue</programlisting></para> 
						  <para>It is an error to use a break or continue statement
								outside of a looping construct.</para> 
						  <para>The following examples illustrate the use of the
								break and continue statements: 
								<programlisting>while true do
	break;</programlisting> 
								<programlisting>begin
	var EvenSum : Integer := 0;
	for I : Integer := 1 to 10 do
		if I mod 2 = 0 then
			EvenSum := EvenSum + I
		else
			continue;
	raise Error("EvenSum: " + EvenSum.ToString());
end;</programlisting></para> 
					 </sect4> 
				</sect3> 
		  </sect2> 
		  <sect2 id="D4LGExceptionHandling"> 
				<title><indexterm><primary>Exception
								Handling</primary></indexterm><indexterm><primary>Imperative
								Statements</primary><secondary>Exception
								Handling</secondary></indexterm>Exception Handling</title> 
				<para>Exception handling statements allow the creation and handling
					 of exceptions. An <emphasis>exception</emphasis> is used in D4 to indicate that
					 an error has occurred. By relegating error handling to specialized statement
					 blocks, the main body of a given operation can be developed optimistically.
					 Only if something goes wrong does the error handling code get invoked.</para> 
				<para>There are three types of error handling constructs in D4: the
					 exception trap, the resource protection block, and the commit block. The
					 exception trap allows exceptions of a specific type to be handled, the resource
					 protection block ensures that a specified statement is always executed, even if
					 an exception occurs, and the commit block is a shorthand for protecting a block
					 of statements within a transaction.</para> 
				<sect3 id="D4LGRaiseStatement"> 
					 <title><indexterm><primary>Raise
									 Statement</primary></indexterm><indexterm><primary>Exception
									 Handling</primary><secondary>Raise Statement</secondary></indexterm>Raise
						  Statement</title> 
					 <para>The raise statement is used to throw a new exception.
						  Control immediately passes from the raise statement to the first exception
						  handler. If no exception handler is encountered, the exception causes the
						  termination of the process and the error message is reported to the client
						  application.</para> 
					 <para>Raise statements in D4 have the following syntax: 
						  <programlisting>&lt;raise statement&gt; ::=
	raise [&lt;expression&gt;]</programlisting></para> 
					 <para>The error value given by <emphasis>expression</emphasis>
						  must be error-valued. The expression is optional only if the raise is invoked
						  within an exception handler, in which case the error being handled is
						  re-raised.</para> 
					 <para>The following example illustrates the use of the raise
						  statement: 
						  <programlisting>if Count(TableVars) = 0 then
	raise Error("No table variables declared.");</programlisting></para> 
				</sect3> 
				<sect3 id="D4LGTryExceptStatement"> 
					 <title><indexterm><primary>Try Except
									 Statement</primary></indexterm><indexterm><primary>Exception
									 Handling</primary><secondary>Try Except Statement</secondary></indexterm>Try
						  Except Statement</title> 
					 <para>The try except statement acts as an exception filter,
						  allowing the developer to trap for specific errors and take appropriate
						  action.</para> 
					 <para>Try except statements in D4 have the following syntax: 
						  <programlisting>&lt;try except statement&gt; ::=
	try
		&lt;terminated statement list&gt;
	except
		&lt;terminated statement list&gt; | &lt;exception handler list&gt;
	end
	
&lt;exception handler&gt; ::=
	on [&lt;exception variable&gt; :] &lt;type specifier&gt; do 
		&lt;terminated statement&gt;

&lt;exception variable&gt; ::=
	&lt;qualified identifier&gt;</programlisting></para> 
					 <para>When an exception is raised within the try block, control
						  immediately passes to the except block of the statement. If the except block is
						  simply a list of statements, they are executed. If the except block is a list
						  of exception handlers, the type of the exception is compared against each
						  exception handler. Control is passed to the first exception handler matching
						  the type of the exception. If no exception handler is found, control passes to
						  the next try-except block in the program. This continues until an exception
						  handler is found, or there are no containing try-except blocks, resulting in
						  program termination.</para> 
					 <para>Once an exception handler has been found, the exception
						  is considered handled, and control passes to the first statement following the
						  try-except block. Within an except block, the raise statement may be used
						  without an argument to indicate that the exception should be re-raised from the
						  exception block.</para> 
					 <para>The following example illustrates the use of the
						  try-except statement: 
						  <programlisting>begin	
		BeginTransaction();
		try
			raise Error("An error has occurred");
			CommitTransaction();
		except
		on E : Error do
		begin
			RollbackTransaction();
			raise;
		end;
	end;
end;</programlisting></para> 
				</sect3> 
				<sect3 id="D4LGTryFinallyStatement"> 
					 <title><indexterm><primary>Try Finally
									 Statement</primary></indexterm><indexterm><primary>Exception
									 Handling</primary><secondary>Try Finally Statement</secondary></indexterm>Try
						  Finally Statement</title> 
					 <para>The try finally statement in D4 allows a specified block
						  of statements to be executed regardless of whether an exception occurs.</para> 
					 <para>Try finally statements in D4 have the following syntax: 
						  <programlisting>&lt;try finally statement&gt; ::=
	try
		&lt;terminated statement list&gt;
	finally
		&lt;terminated statement list&gt;
	end</programlisting></para> 
					 <para>If no exception occurs within the try block, the finally
						  block is executed normally. If an exception occurs within the try block,
						  control passes immediately to the first statement in the finally block. All
						  statements in the finally block are executed, and then exception processing
						  continues as described in the try-except statement.</para> 
					 <para>The following example illustrates the use of the
						  try-finally statement: 
						  <programlisting>begin
	var LCursor : cursor(table { Name : Name });
	LCursor := cursor(Objects over { Name });
	try
		// ... if an error occurs within this block
		// the cursor will still be closed
	finally
		LCursor.Close();
	end;
end;</programlisting></para> 
				</sect3> 
				<sect3> 
					 <title><indexterm><primary>Try Commit
									 Statement</primary></indexterm><indexterm><primary>Exception
									 Handling</primary><secondary>Try Commit Statement</secondary></indexterm>Try
						  Commit Statement</title> 
					 <para>The try commit statement in D4 protects a specified block
						  of statements within a transaction.</para> 
					 <para>Try commit statements in D4 have the following syntax: 
						  <programlisting>&lt;try commit statement&gt; ::=
	try
		&lt;terminated statement lisst&gt;
	commit</programlisting></para> 
					 <para> The try commit statement is shorthand for an equivalent
						  try except statement with transaction management calls. For example, the
						  following statement: 
						  <programlisting>try
	insert table { row { 6 ID, 'Jacob' Name } } into Employee;
commit;</programlisting></para> 
					 <para>Is equivalent to the following try except statement: 
						  <programlisting>begin
	BeginTransaction();
	try
		insert table { row { 6 ID, 'Jacob' Name } } into Employee;
		CommitTransaction();
	except
		RollbackTransaction();
		raise;
	end;
end;</programlisting></para> 
				</sect3> 
		  </sect2> 
	 </sect1> 
	 <sect1 id="D4LGProgrammingTopics"> 
		  <title><indexterm><primary>Programming
						  Topics</primary></indexterm><indexterm><primary>D4 Language
						  Guide</primary><secondary>Programming Topics</secondary></indexterm>Programming
				Topics</title> 
		  <para>This section discusses common programming tasks in D4. Topics
				covered include items such as cursors, generators, devices, and event handlers.
				For information on how to customize and extend the DAE environment, refer to
				Part II of this manual.</para> 
		  <sect2 id="D4LGUsingStrings"> 
				<title><indexterm><primary>Using
								Strings</primary></indexterm><indexterm><primary>Programming
								Topics</primary><secondary>Using Strings</secondary></indexterm>Using
					 Strings</title> 
				<para>This section describes how to use the
					 <symbol>System.String</symbol> and <symbol>System.IString</symbol> data types
					 to construct and manipulate string values in the DAE. To begin with, we provide
					 the definition of the <symbol>System.String</symbol> and
					 <symbol>System.IString</symbol> domains: 
					 <programlisting>create domain System.String is { System.Alpha }
{
	representation String 
	{ 
		Value : String 
			read class "ScalarReadAccessor,Alphora.Dataphor.DAE"
			write class "ScalarWriteAccessor,Alphora.Dataphor.DAE"
	} class "ScalarSelectorNode,Alphora.Dataphor.DAE",
	representation Unicode
	{
		Unicode : list(System.Integer)
			read class "SystemStringReadUnicodeNode,Alphora.Dataphor.DAE"
			write class "SystemStringWriteUnicodeNode,Alphora.Dataphor.DAE"
	} class "SystemStringUnicodeNode,Alphora.Dataphor.DAE",
	representation UTF8
	{
		UTF8 : list(System.Byte)
			read class "SystemStringReadUTF8Node,Alphora.Dataphor.DAE"
			write class "SystemStringWriteUTF8Node,Alphora.Dataphor.DAE"
	} class "SystemStringUTF8Node,Alphora.Dataphor.DAE,
	representation ASCII
	{
		ASCII : list(System.Byte)
			read class "SystemStringReadASCIINode,Alphora.Dataphor.DAE"
			write class "SystemStringWriteASCIINode,Alphora.Dataphor.DAE"
	} class "SystemStringASCIINode,Alphora.Dataphor.DAE
} class "StringConveyor,Alphora.Dataphor.DAE";

create domain System.IString is { System.Alpha }
{
	representation IString
	{
		Value : System.String
			read "ScalarReadAccessorNode,Alphora.Dataphor.DAE"
			write "ScalarWriteAccessorNode,Alphora.Dataphor.DAE"
	} class "ScalarSelectorNode,Alphora.Dataphor.DAE"
} class "StringConveyor,Alphora.Dataphor.DAE";</programlisting></para> 
				<note> 
					 <para>In the preceding code sample the class names may require
						  full qualification rather than just the class names as shown.
						  Alphora.Dataphor.DAE.Runtime.Instructions applies to the read and write
						  accessor nodes. Alphora.Dataphor.DAE.Streams applies for the conveyors.</para> 
				</note> 
				<para><symbol>System.String</symbol> has four possible
					 representations: 
					 <itemizedlist> 
						  <listitem> 
								<para>String</para> 
						  </listitem> 
						  <listitem> 
								<para>Unicode</para> 
						  </listitem> 
						  <listitem> 
								<para>UTF8</para> 
						  </listitem> 
						  <listitem> 
								<para>ASCII</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>Each possible representation has an associated selector and
					 read and write accessors for the properties of the representation. The default
					 representation <symbol>String</symbol> has a single property called
					 <symbol>Value</symbol> of type <symbol>String</symbol>. This is the native
					 representation and is required because values of type <symbol>String</symbol>
					 have a parser literal.</para> 
				<para>The <symbol>Unicode</symbol> representation of a string is a
					 list of values of type <symbol>System.Integer</symbol>, where each integer in
					 the list represents the Unicode character constant for the character in that
					 position in the string. For example, the following Unicode selector invocation:
					 
					 <programlisting>Unicode({0x41, 0x42, 0x43})</programlisting>produces the string <symbol>"ABC"</symbol>.</para> 
				<para>The <symbol>UTF8</symbol> representation of a string is a
					 list of values of type <symbol>System.Byte</symbol>, where each byte in the
					 list represents the UTF-8 character constant for the character in that position
					 in the string. For example, the following UTF8 selector invocation: 
					 <programlisting>UTF8({65 as Byte, 66 as Byte, 67 as Byte})</programlisting>produces the string <symbol>"ABC"</symbol>.</para> 
				<para>The <symbol>ASCII</symbol> representation of a string is a
					 list of values of type <symbol>System.Byte</symbol>, where each byte in the
					 list represents the ASCII character constant for the character in that position
					 in the string. For example, the following ASCII selector invocation: 
					 <programlisting>ASCII({65 as Byte, 66 as Byte, 67 as Byte})</programlisting>produces the string <symbol>"ABC"</symbol>.</para> 
				<para><symbol>System.IString</symbol> only has the default
					 representation <symbol>IString</symbol>. The following selector invocation
					 builds a case-insensitive character string: 
					 <programlisting>IString("ABC")</programlisting></para> 
				<para>The DAE provides the following string operators: 
					 <itemizedlist> 
						  <listitem> 
								<para>String Indexer</para> 
								<para>Allows a specific character in the string to be
									 addressed by its ordinal position within the string. Indexes are
									 zero-based.</para> 
						  </listitem> 
						  <listitem> 
								<para>String Concatenation</para> 
								<para>The <symbol>+</symbol> operator is used for
									 string concatenation, resulting in the string with the characters of the first
									 string prefixing the characters of the second string.</para> 
						  </listitem> 
						  <listitem> 
								<para><symbol>Length</symbol></para> 
								<para>Determines the length of the given string.</para>
								
						  </listitem> 
						  <listitem> 
								<para><symbol>Copy</symbol></para> 
								<para>Copies the characters from the given string
									 beginning at a specified index, and for a specified length.</para> 
						  </listitem> 
						  <listitem> 
								<para><symbol>Pos</symbol></para> 
								<para>Returns the index of the first position of a
									 given substring within a given string. Returns -1 if the given substring is not
									 in the given string.</para> 
						  </listitem> 
						  <listitem> 
								<para><symbol>IndexOf</symbol></para> 
								<para>Returns the index of the first position of a
									 given substring within a given string. Returns -1 if the given substring is not
									 in the given string. This operator is the same as <symbol>Pos</symbol>, with
									 the arguments reversed. This enables <symbol>IndexOf</symbol> to be invoked
									 with OOP-style method invocation.</para> 
						  </listitem> 
						  <listitem> 
								<para><symbol>Upper</symbol></para> 
								<para>Returns the string containing the characters in
									 the given string, upper-cased.</para> 
						  </listitem> 
						  <listitem> 
								<para><symbol>Lower</symbol></para> 
								<para>Returns the string containing the characters in
									 the given string, lower-cased.</para> 
						  </listitem> 
						  <listitem> 
								<para><symbol>Like</symbol></para> 
								<para>Returns true if the given pattern is found in the
									 given string.</para> 
						  </listitem> 
						  <listitem> 
								<para><symbol>Matches</symbol></para> 
								<para>Returns true if the given regular expression
									 matches the given string.</para> 
						  </listitem> 
						  <listitem> 
								<para><symbol>CompareText</symbol></para> 
								<para>Performs a case-insensitive compare of two
									 strings.</para> 
						  </listitem> 
						  <listitem> 
								<para>Aggregate Operators</para> 
								<para>The following aggregate operators are defined for
									 strings: 
									 <itemizedlist> 
										  <listitem> 
												<para><symbol>Count</symbol></para> 
												<para>Determines the cardinality of the
													 argument.</para> 
										  </listitem> 
										  <listitem> 
												<para><symbol>Min</symbol></para> 
												<para>Defined as iterated less than
													 comparison.</para> 
										  </listitem> 
										  <listitem> 
												<para><symbol>Max</symbol></para> 
												<para>Defined as iterated greater than
													 comparison.</para> 
										  </listitem> 
									 </itemizedlist></para> 
						  </listitem> 
					 </itemizedlist></para> 
		  </sect2> 
		  <sect2 id="D4LGUsingDateandTimeValues"> 
				<title><indexterm><primary>Using Date and Time
								Values</primary></indexterm><indexterm><primary>Programming
								Topics</primary><secondary>Using Date and Time
								Values</secondary></indexterm>Using Date and Time Values</title> 
				<para>This section describes how to use the
					 <symbol>System.TimeSpan</symbol> and <symbol>System.DateTime</symbol> data
					 types and their associated operators to construct and manipulate date and time
					 values in the DAE. To begin with, we provide the definition of the
					 <symbol>System.TimeSpan</symbol> and <symbol>System.DateTime</symbol> domains: 
					 <programlisting>create domain System.TimeSpan is { System.Alpha }
{
	representation TimeSpan
	{
		DaysPart : Integer
			read class "SystemTimeSpanTimeSpanReadDaysPartNode,Alphora.Dataphor.DAE"
			write class "SystemTimeSpanTimeSpanWriteDaysPartNode,Alphora.Dataphor.DAE",
		HoursPart : Integer
			read class "SystemTimeSpanTimeSapnReadHoursPartNode,Alphora.Dataphor.DAE"
			write class "SystemTimeSpanTimeSpanWriteHoursPartNode,Alphora.Dataphor.DAE",
		MinutesPart : Integer
			read class "SystemTimeSpanTimeSpanReadMinutesPartNode,Alphora.Dataphor.DAE"
			write class "SystemTimeSpanTimeSpanWriteMinutesPartNode,Alphora.Dataphor.DAE",
		SecondsPart : Integer
			read class "SystemTimeSpanTimeSpanReadSecondsPartNode,Alphora.Dataphor.DAE"
			write class "SystemTimeSpanTimeSpanWriteSecondsPartNode,Alphora.Dataphor.DAE",
		MillisecondsPart : Integer
			read class "SystemTimeSpanTimeSpanReadMillisecondsPartNode,Alphora.Dataphor.DAE"
			write class "SystemTimeSpanTimeSpanWriteMillisecondsPartNode,Alphora.Dataphor.DAE"
	} class "SystemTimeSpanTimeSpanMillisecondsSelectorNode,Alphora.Dataphor.DAE",
	representation Days
	{
		Days : Decimal
			read class "SystemTimeSpanDaysReadDaysNode,Alphora.Dataphor.DAE"
			write class "SystemTimeSpanDaysWriteDaysNode,Alphora.Dataphor.DAE"
	} class "SystemTimeSpanDaysSelectorNode,Alphora.Dataphor.DAE",
	representation Hours
	{
		Hours : Decimal
			read class "SystemTimeSpanHoursReadHoursNode,Alphora.Dataphor.DAE"
			write class "SystemTimeSpanHoursWriteHoursNode,Alphora.Dataphor.DAE"
	} class "SystemTimeSpanHoursSelectorNode,Alphora.Dataphor.DAE",
	representation Minutes
	{
		Minutes : Decimal
			read class "SystemTimeSpanMinutesReadMinutesNode,Alphora.Dataphor.DAE"
			write class "SystemTimeSpanMinutesWriteMinutesNode,Alphora.Dataphor.DAE"
	} class "SystemTimeSpanMinutesSelectorNode,Alphora.Dataphor.DAE",
	representation Seconds
	{
		Seconds : Decimal
			read class "SystemTimeSpanSecondsReadSecondsNode,Alphora.Dataphor.DAE"
			write class "SystemTimeSpanSecondsWriteSecondsNode,Alphora.Dataphor.DAE"
	} class "SystemTimeSpanSecondsSelectorNode,Alphora.Dataphor.DAE",
	representation Milliseconds
	{
		Milliseconds : Decimal
			read class "SystemTimeSpanMillisecondsReadMillisecondsNode,Alphora.Dataphor.DAE"
			write class "SystemTimeSpanMillisecondsWriteMillisecondsNode,Alphora.Dataphor.DAE"
	} class "SystemTimeSpanMillisecondsSelectorNode,Alphora.Dataphor.DAE",
	representation Ticks
	{
		Ticks : Long
			read class "SystemTimeSpanTicksReadTicksNode,Alphora.Dataphor.DAE"
			write class "SystemTimeSpanTicksWriteTicksNode,Alphora.Dataphor.DAE"
	} class "SystemTimeSpanTicksSelectorNode,Alphora.Dataphor.DAE"
} class "TimeSpanConveyor,Alphora.Dataphor.DAE";

create domain System.DateTime is { System.TimeSpan }
{
	representation DateTime
	{
		YearsPart : Integer
			read class "SystemDateTimeDateTimeReadYearsPartNode,Alphora.Dataphor.DAE"
			write class "SystemDateTimeDateTimeWriteYearsPartNode,Alphora.Dataphor.DAE",
		MonthsPart : Integer
			read class "SystemDateTimeDateTimeReadMonthsPartNode,Alphora.Dataphor.DAE"
			write class "SystemDateTimeDateTimeWriteMonthsPartNode,Alphora.Dataphor.DAE",
		DaysPart : Integer
			read class "SystemDateTimeDateTimeReadDaysPartNode,Alphora.Dataphor.DAE"
			write class "SystemDateTimeDateTimeWriteDaysPartNode,Alphora.Dataphor.DAE",
		HoursPart : Integer
			read class "SystemDateTimeDateTimeReadHoursPartNode,Alphora.Dataphor.DAE"
			write class "SystemDateTimeDateTimeWriteHoursPartNode,Alphora.Dataphor.DAE",
		MinutesPart : Integer
			read class "SystemDateTimeDateTimeReadMinutesPartNode,Alphora.Dataphor.DAE"
			write class "SystemDateTimeDateTimeWriteMinutesPartNode,Alphora.Dataphor.DAE",
		SecondsPart : Integer
			read class "SystemDateTimeDateTimeReadSecondsPartNode,Alphora.Dataphor.DAE"
			write class "SystemDateTimeDateTimeWriteSecondsPartNode,Alphora.Dataphor.DAE",
		MillisecondsPart : Integer
			read class "SystemDateTimeDateTimeReadMillisecondsPartNode,Alphora.Dataphor.DAE"
			write class "SystemDateTimeDateTimeWriteMillisecondsPartNode,Alphora.Dataphor.DAE"
	} class "SystemDateTimeDateTimeSelectorNode,Alphora.Dataphor.DAE"
} class "DateTimeConveyor,Alphora.Dataphor.DAE";</programlisting></para> 
				<note> 
					 <para>In the preceding code sample the class names may require
						  full qualification rather than just the class names as shown.
						  Alphora.Dataphor.DAE.Runtime.Instructions applies to the read and write nodes.
						  Alphora.Dataphor.DAE.Streams applies for the conveyors.</para> 
				</note> 
				<para><symbol>System.TimeSpan</symbol> has seven possible
					 representations: 
					 <itemizedlist> 
						  <listitem> 
								<para>TimeSpan</para> 
								<para>The TimeSpan representation is the default
									 representation for the TimeSpan type, and has five properties: 
									 <itemizedlist> 
										  <listitem> 
												<para>DaysPart</para> 
										  </listitem> 
										  <listitem> 
												<para>HoursPart</para> 
										  </listitem> 
										  <listitem> 
												<para>MinutesPart</para> 
										  </listitem> 
										  <listitem> 
												<para>SecondsPart</para> 
										  </listitem> 
										  <listitem> 
												<para>MillisecondsPart</para> 
										  </listitem> 
									 </itemizedlist> corresponding to the days, hours,
									 minutes, seconds, and milliseconds components of the TimeSpan,
									 respectively.</para> 
								<para>The TimeSpan selector takes a value for each of
									 these properties in order to construct a TimeSpan value. For example: 
									 <programlisting>TimeSpan(10, 2, 55, 30, 12)</programlisting>builds the TimeSpan value of 10 days, 2 hours, 55 minutes, 30
									 seconds, and 12 milliseconds. In addition to the basic selector, the DAE
									 defines overloads for the <symbol>TimeSpan</symbol> operator, which allow the
									 secondary arguments to be ommitted. A <symbol>Time</symbol> operator is also
									 provided which allows the days property to be ommitted: 
									 <programlisting>TimeSpan
	(
		ADaysPart : Integer,
		AHoursPart : Integer,
		AMinutesPart : Integer,
		ASecondsPart : Integer
	);

TimeSpan
	(
		ADaysPart : Integer,
		AHoursPart : Integer,
		AMinutesPart : Integer
	);

TimeSpan(ADaysPart : Integer, AHoursPart : Integer);

TimeSpan(ADaysPart : Integer);

Time
	(
		AHoursPart : Integer,
		AMinutesPart : Integer,
		ASecondsPart : Integer,
		AMillisecondsPart : Integer
	);

Time
	(
		AHoursPart : Integer,
		AMinutesPart : Integer,
		ASecondsPart : Integer
	);

Time(AHoursPart : Integer, AMinutesPart : Integer);

Time(AHoursPart : Integer);</programlisting></para> 
								<para>As with all possible representations, each of
									 these components can be updated independently of the others. Note that this is
									 only a shorthand for an equivalent selector invocation: 
									 <programlisting>begin
	var LTimeSpan : TimeSpan := TimeSpan(10, 5);
	LTimeSpan.Hours := 6;
	// Equivalent selector invocation
	LTimeSpan := TimeSpan(LTimeSpan.Days, 6);
end;</programlisting></para> 
						  </listitem> 
						  <listitem> 
								<para>Days</para> 
								<para>The Days representation has a single property
									 called Days which is the total number of days in the given TimeSpan expressed
									 as a decimal value. For example, the following selector invocations are
									 equivalent: 
									 <programlisting>Days(10.5);
TimeSpan(10, 12);</programlisting></para> 
						  </listitem> 
						  <listitem> 
								<para>Hours</para> 
								<para>The Hours representation has a single property
									 called Hours which is the total number of hours in the given TimeSpan expressed
									 as a decimal value.</para> 
						  </listitem> 
						  <listitem> 
								<para>Minutes</para> 
								<para>The Minutes representation has a single property
									 called Minutes which is the total number of minutes in the given TimeSpan
									 expressed as a decimal value.</para> 
						  </listitem> 
						  <listitem> 
								<para>Seconds</para> 
								<para>The Seconds representation has a single property
									 called Seconds which is the total number of seconds in the given TimeSpan
									 expressed as a decimal value.</para> 
						  </listitem> 
						  <listitem> 
								<para>Milliseconds</para> 
								<para>The Milliseconds representation has a single
									 property called Milliseconds which is the total number of milliseconds in the
									 given TimeSpan expressed as a decimal value.</para> 
						  </listitem> 
						  <listitem> 
								<para>Ticks</para> 
								<para>The Ticks representation has a single property
									 called Ticks which is the total number of ticks in the given TimeSpan expressed
									 as a long value.</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para><symbol>System.DateTime</symbol> introduces the default
					 representation <symbol>DateTime</symbol>. This representation has seven
					 properties: 
					 <itemizedlist> 
						  <listitem> 
								<para>YearsPart</para> 
						  </listitem> 
						  <listitem> 
								<para>MonthsPart</para> 
						  </listitem> 
						  <listitem> 
								<para>DaysPart</para> 
						  </listitem> 
						  <listitem> 
								<para>HoursPart</para> 
						  </listitem> 
						  <listitem> 
								<para>MinutesPart</para> 
						  </listitem> 
						  <listitem> 
								<para>SecondsPart</para> 
						  </listitem> 
						  <listitem> 
								<para>MillisecondsPart</para> 
						  </listitem> 
					 </itemizedlist> corresponding to the years, months, days,
					 hours, minutes, seconds, and milliseconds of the DateTime, respectively.</para>
				
				<para>The DateTime selector takes a value for each of these
					 properties in order to construct a DateTime value. For example: 
					 <programlisting>DateTime(2002, 9, 23, 7, 35, 15, 0);</programlisting>builds the DateTime value September 23, 2002 at 7:35:15 AM. In
					 addition to the basic selector, the DAE defines overloads for the
					 <symbol>DateTime</symbol> operator which allow the secondary arguments to be
					 ommitted: 
					 <programlisting>DateTime
	(
		AYearsPart : Integer,
		AMonthsPart : Integer,
		ADaysPart : Integer,
		AHoursPart : Integer,
		AMinutesPart : Integer,
		ASecondsPart : Integer
	);

DateTime
	(
		AYearsPart : Integer,
		AMonthsPart : Integer,
		ADaysPart : Integer,
		AHoursPart : Integer,
		AMinutesPart : Integer
	);

DateTime
	(
		AYearsPart : Integer,
		AMonthsPart : Integer,
		ADaysPart : Integer,
		AHoursPart : Integer
	);

DateTime
	(
		AYearsPart : Integer,
		AMonthsPart : Integer,
		ADaysPart : Integer
	);

DateTime(AYearsPart : Integer, AMonthsPart : Integer);

DateTime(AYearsPart : Integer);</programlisting></para> 
				<para>As with all scalar types, the properties of all possible
					 representations are available for each value of the type. For example: 
					 <programlisting>begin
	var LTimeSpan : TimeSpan := Days(10.5);
	/* 
	   HoursPart is available even though the 
	   Days selector was used to build the value
	*/
	raise Error(LTimeSpan.HoursPart.ToString()); 
end;</programlisting></para> 
				<para>The DAE provides the following date and time operators: 
					 <itemizedlist> 
						  <listitem> 
								<para><symbol>DatePart</symbol></para> 
								<para>Retrieves only the date portion of a
									 <symbol>DateTime</symbol> value.</para> 
						  </listitem> 
						  <listitem> 
								<para><symbol>TimePart</symbol></para> 
								<para>Retrieves only the time portion of a
									 <symbol>DateTime</symbol> value.</para> 
						  </listitem> 
						  <listitem> 
								<para><symbol>Now</symbol></para> 
								<para>Returns the current date and time. Note that this
									 operator returns the same value on successive invocations within the same
									 transaction.</para> 
						  </listitem> 
						  <listitem> 
								<para><symbol>Today</symbol></para> 
								<para>Returns the current date. Note that this operator
									 returns the same value on successive invocations within the same
									 transaction.</para> 
						  </listitem> 
						  <listitem> 
								<para><symbol>DayOfMonth</symbol></para> 
								<para>Returns the day of the month of a
									 <symbol>DateTime</symbol> value.</para> 
						  </listitem> 
						  <listitem> 
								<para><symbol>DayOfWeek</symbol></para> 
								<para>Returns the day of the week of a
									 <symbol>DateTime</symbol> value.</para> 
						  </listitem> 
						  <listitem> 
								<para><symbol>DayOfYear</symbol></para> 
								<para>Returns the day of the year of a
									 <symbol>DateTime</symbol> value.</para> 
						  </listitem> 
						  <listitem> 
								<para><symbol>DaysInMonth</symbol></para> 
								<para>Returns the number of days in the given month and
									 year.</para> 
						  </listitem> 
						  <listitem> 
								<para><symbol>IsLeapYear</symbol></para> 
								<para>Returns <symbol>true</symbol> if the given year
									 is a leap year, and <symbol>false</symbol> otherwise.</para> 
						  </listitem> 
						  <listitem> 
								<para><symbol>Duration</symbol></para> 
								<para>Returns the duration of a given
									 <symbol>TimeSpan</symbol>.</para> 
						  </listitem> 
						  <listitem> 
								<para><symbol>AddMonths</symbol></para> 
								<para>Adds the given number of months to a
									 <symbol>DateTime</symbol> value.</para> 
						  </listitem> 
						  <listitem> 
								<para><symbol>AddYears</symbol></para> 
								<para>Adds the given number of years to a
									 <symbol>DateTime</symbol> value.</para> 
						  </listitem> 
						  <listitem> 
								<para>Arithmetic Operators</para> 
								<itemizedlist> 
									 <listitem> 
										  <para><symbol>iAddition</symbol>(<symbol>+</symbol>)</para>
										  
										  <para>Adds two <symbol>TimeSpan</symbol> values
												together, resulting in a <symbol>TimeSpan</symbol> that is the total of
												both.</para> 
									 </listitem> 
									 <listitem> 
										  <para><symbol>iSubtraction</symbol>(<symbol>-</symbol>)</para>
										  
										  <para>Subtracts two <symbol>TimeSpan</symbol>
												values, resulting in a <symbol>TimeSpan</symbol> that is the difference between
												the first and second values.</para> 
									 </listitem> 
									 <listitem> 
										  <para><symbol>iMultiplication</symbol>(<symbol>*</symbol>)</para>
										  
										  <para>Multiplies a given
												<symbol>TimeSpan</symbol> by a <symbol>Decimal</symbol> value, resulting in a
												<symbol>TimeSpan</symbol> that is the specified number of times longer than the
												original value.</para> 
									 </listitem> 
									 <listitem> 
										  <para><symbol>iDivision</symbol>(<symbol>/</symbol>)</para>
										  
										  <para>Divides a given <symbol>TimeSpan</symbol>
												by a <symbol>Decimal</symbol> value, resulting in a <symbol>TimeSpan</symbol>
												that is the specified number of times shorter than the original value.</para> 
									 </listitem> 
									 <listitem> 
										  <para><symbol>iNegate</symbol>(unary
												<symbol>-</symbol>)</para> 
										  <para>Returns the <symbol>TimeSpan</symbol>
												that is the negative length of the original value. Just as in integer
												arithmetic, negating a negative <symbol>TimeSpan</symbol> value results in a
												positive value.</para> 
									 </listitem> 
								</itemizedlist> 
						  </listitem> 
						  <listitem> 
								<para>Comparison Operators</para> 
								<para>All the comparison operators (<symbol>=</symbol>,
									 <symbol>&lt;&gt;</symbol>, <symbol>&lt;</symbol>, <symbol>&gt;</symbol>,
									 <symbol>&lt;=</symbol>, <symbol>&gt;=</symbol>, and <symbol>?=</symbol>) are
									 defined for <symbol>TimeSpan</symbol> and <symbol>DateTime</symbol> values,
									 with the expected semantics.</para> 
						  </listitem> 
						  <listitem> 
								<para>Aggregate Operators</para> 
								<para>The following aggregate operators are defined for
									 <symbol>TimeSpan</symbol> and <symbol>DateTime</symbol> values: 
									 <itemizedlist> 
										  <listitem> 
												<para><symbol>Count</symbol></para> 
												<para>Determines the cardinality of the
													 argument.</para> 
										  </listitem> 
										  <listitem> 
												<para><symbol>Sum</symbol></para> 
												<para>Defined as iterated addition.</para> 
										  </listitem> 
										  <listitem> 
												<para><symbol>Min</symbol></para> 
												<para>Defined as iterated less than
													 comparison.</para> 
										  </listitem> 
										  <listitem> 
												<para><symbol>Max</symbol></para> 
												<para>Defined as iterated greater than
													 comparison.</para> 
										  </listitem> 
										  <listitem> 
												<para><symbol>Avg</symbol></para> 
												<para>Defined as iterated addition divided
													 by the count.</para> 
										  </listitem> 
									 </itemizedlist></para> 
						  </listitem> 
					 </itemizedlist></para> 
		  </sect2> 
		  <sect2 id="D4LGUsingRows"> 
				<title><indexterm><primary>Using
								Rows</primary></indexterm><indexterm><primary>Programming
								Topics</primary><secondary>Using Rows</secondary></indexterm>Using Rows</title>
				
				<para>This section describes how to use row selectors and the
					 system-provided operators of the DAE to construct and manipulate row
					 values.</para> 
				<para>A row is a set of named values called columns. The row type
					 specifies the name and type of each column. A row selector is used to construct
					 a value of a specified row type: 
					 <programlisting>var LRow : row { ID : Integer } := row { 5 ID };</programlisting></para> 
				<para>As the preceding example illustrates, variables are allowed
					 to be of any row type. The following operators are defined for row types: 
					 <itemizedlist> 
						  <listitem> 
								<para>Comparison Operators</para> 
								<para>The comparison operator <symbol>=</symbol> and
									 <symbol>&lt;&gt;</symbol> are defined for row values. Two row values are equal
									 if they are of the same row type and the values for each column by name are
									 equal.</para> 
						  </listitem> 
						  <listitem> 
								<para>Column Extractor</para> 
								<para>The column extraction operator retrieves the
									 value for a single column in the row.</para> 
						  </listitem> 
						  <listitem> 
								<para>Row Update</para> 
								<para>Row update allows the values for specific columns
									 within a given row to be changed. The target of a row update must be a
									 variable: 
									 <programlisting>begin
	var LRow : row { ID : Integer, Name : String } := 
		row { 5 ID, "John" Name };
	update LRow set { Name := "Jack" };
end;</programlisting></para> 
						  </listitem> 
						  <listitem> 
								<para>Row Project</para> 
								<para>Row project returns a row with only the specified
									 columns of the given row: 
									 <programlisting>begin
	var LRow1 : row { ID : Integer, Name : String } := 
		row { 5 ID, "John" Name };
	var LRow2 : row { ID : Integer } := LRow1 over { ID };
end;</programlisting></para> 
						  </listitem> 
						  <listitem> 
								<para>Row Remove</para> 
								<para>Row remove returns a row with the specified
									 columns removed from the given row: 
									 <programlisting>begin
	var LRow1 : row { ID : Integer, Name : String } := 
		row { 5 ID, "John" Name };
	var LRow2 : row { ID : Integer } := LRow1 remove { Name };
end;</programlisting></para> 
						  </listitem> 
						  <listitem> 
								<para>Row Add</para> 
								<para>Row add allows columns to be added to a given
									 row. The current values of the columns in the source row are available by
									 column name within the expressions defining the new columns: 
									 <programlisting>begin
	var LRow1 : row { ID : Integer } := row { 5 ID };
	var LRow2 : row { ID : Integer, Name : String } := 
		LRow1 add { "John" Name };
end;</programlisting></para> 
						  </listitem> 
						  <listitem> 
								<para>Row Redefine</para> 
								<para>Row redefine allows columns of a given row to be
									 redefined. The current values of the columns in the source row are avaiable by
									 column name within the expressions defining the new columns. Just as with table
									 redefine, this operator is defined as a shorthand for adding a new column
									 <symbol>X</symbol>, removing some column <symbol>Y</symbol>, and then renaming
									 <symbol>X</symbol> to <symbol>Y</symbol>: 
									 <programlisting>begin
	var LRow1 : row { ID : Integer, Name : String } := 
		row { 5 ID, "John" Name };
	LRow1 := LRow1 redefine { ID := 6 };

	// equivalent
	LRow1 := LRow1 add { 6 X } remove { ID } rename { X ID };
end;</programlisting></para> 
						  </listitem> 
						  <listitem> 
								<para>Row Rename</para> 
								<para>Row rename allows columns of a given row to be
									 renamed. The values of the renamed columns are unaffected: 
									 <programlisting>begin
	var LRow1 : row { ID : Integer, Name : String } :=
		row { 5 ID, "John" Name };
	var LRow2 : row { X : Integer, Y : String } :=
		LRow1 rename { ID X, Name Y };
end;</programlisting></para> 
						  </listitem> 
						  <listitem> 
								<para>Row Join</para> 
								<para>Row join allows two rows to be joined together.
									 If the two rows have common column names, the values for those columns in each
									 row must be the equal: 
									 <programlisting>begin
	var LRow1 : row { ID : Integer, Name : String } :=
		row { 5 ID, "John" Name };
	var LRow2 : row { ID : Integer, City : String } :=
		row { 5 ID, "Provo" City };
	var LRow3 : row { ID : Integer, City : String } :=
		row { 6 ID, "Orem" City };
	var LRow4 : row { ID : Integer, Name : String, City : String };
	LRow4 := LRow1 join LRow2;
	LRow4 := LRow1 join LRow3; // this is an error</programlisting></para> 
						  </listitem> 
					 </itemizedlist></para> 
		  </sect2> 
		  <sect2 id="D4LGUsingLists"> 
				<title><indexterm><primary>Using
								Lists</primary></indexterm><indexterm><primary>Programming
								Topics</primary><secondary>Using Lists</secondary></indexterm>Using
					 Lists</title> 
				<para>This section describes how to use list selectors and the
					 system-provided operators of the DAE to construct and manipulate list
					 values.</para> 
				<para>A list is an ordered collection of values of the same type.
					 Values in the list are distinguishable by ordinal position. The list type
					 specifies the type of values in the list. A list selector is used to construct
					 a list value: 
					 <programlisting>begin
	var LList : list(Integer) := { 12, 13, 14, 15 };
	// the type of a list value can be specified in the selector
	LList := list(Integer){};
end;</programlisting></para> 
				<para>The following operators are defined for lists: 
					 <itemizedlist> 
						  <listitem> 
								<para>Comparison Operators</para> 
								<para>The comparison operators <symbol>=</symbol> and
									 <symbol>&lt;&gt;</symbol> are defined for list values. Two lists are equal if
									 they are of the same type, have the same number of values, and the values in
									 each list are equal by ordinal position: 
									 <programlisting>begin
	var LList1 : list(Integer) := { 1, 2, 3 };
	var LList2 : list(Integer) := { 1, 2, 3 };
	if not(LList1 = LList2) then
		raise Error("Lists not equal");
end;</programlisting></para> 
						  </listitem> 
						  <listitem> 
								<para>Membership Operator</para> 
								<para>The membership operator <symbol>in</symbol> is
									 defined for lists and returns true if the given value is in the specified list:
									 
									 <programlisting>begin
	var LList : list(Integer) := { 1, 2, 3 };
	if not(3 in LList) then
		raise Error("3 is not in the list");
end;</programlisting></para> 
						  </listitem> 
						  <listitem> 
								<para>List Indexer</para> 
								<para>The indexer operator (<symbol>[]</symbol>) is
									 defined for lists and allows the values of a list to be accessed by ordinal
									 position within the list. Indexes are zero-based: 
									 <programlisting>begin
	var LList : list(Integer) := { 1, 2, 3 };
	if not(LList[0] = 1) then
		raise Error("The first item in the list is not 1");
end;</programlisting></para> 
						  </listitem> 
						  <listitem> 
								<para><symbol>Count</symbol></para> 
								<para>Returns the number of values in the given
									 list.</para> 
						  </listitem> 
						  <listitem> 
								<para><symbol>Clear</symbol></para> 
								<para>Removes all values from the specified list. The
									 target list must be a list variable.</para> 
						  </listitem> 
						  <listitem> 
								<para><symbol>Add</symbol></para> 
								<para>Adds the specified value into the given list. The
									 target list must be a list variable.</para> 
						  </listitem> 
						  <listitem> 
								<para><symbol>Insert</symbol></para> 
								<para>Inserts the specified value in the given list at
									 the desired location. The target list must be a list variable.</para> 
						  </listitem> 
						  <listitem> 
								<para><symbol>Remove</symbol></para> 
								<para>Removes the specified value from the given list.
									 The target list must be a list variable.</para> 
						  </listitem> 
						  <listitem> 
								<para><symbol>RemoveAt</symbol></para> 
								<para>Removes the value at the specified location from
									 the given list. The target list must be a list variable.</para> 
						  </listitem> 
						  <listitem> 
								<para><symbol>IndexOf</symbol></para> 
								<para>Returns the index of the specified value within
									 the given list. If the value is not in the list, -1 is returned.</para> 
						  </listitem> 
					 </itemizedlist></para> 
		  </sect2> 
		  <sect2 id="D4LGUsingCursors"> 
				<title><indexterm><primary>Using
								Cursors</primary></indexterm><indexterm><primary>Programming
								Topics</primary><secondary>Using Cursors</secondary></indexterm>Using
					 Cursors</title> 
				<para>This section describes the general usage of cursors in D4.
					 Many of the operations dealing with cursors are operators in the System
					 Library. These operators will be covered briefly. For a complete description of
					 each operator, refer to the System Library Reference.</para> 
				<para>Cursors in the DAE allow navigational access to the results
					 of a given table expression. A <emphasis>cursor selector</emphasis> is used to
					 declare and open a cursor. Declaring a cursor allocates server resources which
					 must be released. This is done using the <symbol>Close</symbol> operator.
					 </para> 
				<para>Cursors in the DAE are "cracked", meaning that the cursor can
					 be positioned before the first row (BOF), after the last row (EOF), or on some
					 row. It is an error to attempt a read or update operation against a cursor that
					 is positioned on a crack. The <symbol>BOF</symbol> and <symbol>EOF</symbol>
					 operators return true if the cursor is positioned on the BOF or EOF crack,
					 respectively. If both BOF and EOF are true, the cursor is ranging over an empty
					 set.</para> 
				<para>The functionality of a cursor is divided up into
					 <emphasis>capabilities</emphasis>. Capabilities are requested as part of the
					 cursor definition. For a complete description of cursor capabilities and other
					 cursor behaviors, refer to the Select Statement section of this guide.</para> 
				<para>Once a cursor is open, all operations against it are done
					 using the cursor operators: 
					 <itemizedlist> 
						  <listitem> 
								<para><symbol>Select(const ACursor : cursor) :
									 row</symbol></para> 
								<para>Selects the current row from the cursor specified
									 by <symbol>ACursor</symbol>. It is an error to call <symbol>Select</symbol> if
									 either <symbol>BOF</symbol> or <symbol>EOF</symbol> is true. </para> 
								<para>The row specified by <symbol>ARow</symbol> need
									 not conform to the heading for the table over which the cursor ranges. Columns
									 are matched by name with the given row.</para> 
						  </listitem> 
						  <listitem> 
								<para><symbol>Insert(const ACursor : cursor, const ARow
									 : row)</symbol></para> 
								<para>Inserts the row given by <symbol>ARow</symbol>
									 into the cursor specified by <symbol>ACursor</symbol>. The position of the
									 cursor after the insert is determined by the characteristics of the cursor. If
									 the cursor is static, the newly inserted row will not be visible in the cursor
									 and the position of the cursor is unaffected. If the cursor is dynamic, the
									 newly inserted row will be visible, and the cursor will attempt to be
									 positioned on the new row. If the cursor is searchable, the cursor will be
									 positioned on the newly inserted row, otherwise, it will be positioned as
									 though <symbol>Reset</symbol> had been called. </para> 
								<para>The row specified by <symbol>ARow</symbol> need
									 not conform to the heading for the table over which the cursor ranges. Columns
									 are matched by name with the given row.</para> 
						  </listitem> 
						  <listitem> 
								<para><symbol>Update(const ACursor : cursor, const ARow
									 : row)</symbol></para> 
								<para>Updates the current row of the cursor specified
									 by <symbol>ACursor</symbol> to the values given by <symbol>ARow</symbol>. It is
									 an error to call <symbol>Update</symbol> if either <symbol>BOF</symbol> or
									 <symbol>EOF</symbol> is true. The position of the cursor after the update is
									 determined by the characteristics of the cursor. If the cursor is static, the
									 update will not be visible in the cursor and the position of the cursor is
									 unaffected. If the cursor is dynamic, the update will be visible, and the
									 cursor will attempt to be positioned on the updated row. If the cursor is
									 searchable, the cursor will be positioned on the updated row, otherwise, it
									 will be positioned as though a <symbol>Reset</symbol> had been called.</para> 
								<para>The row specified by <symbol>ARow</symbol> need
									 not conform to the heading for the table over which the cursor ranges. Columns
									 are matched by name with the given row.</para> 
						  </listitem> 
						  <listitem> 
								<para><symbol>Delete(const ACursor :
									 cursor)</symbol></para> 
								<para>Deletes the current row of the cursor specified
									 by <symbol>ACursor</symbol>. It is an error to call <symbol>Delete</symbol> if
									 either <symbol>BOF</symbol> or <symbol>EOF</symbol> is true. The position of
									 the cursor after the delete is determined by the characteristics of the cursor.
									 If the cursor is static, the delete will not be visible in the cursor, and the
									 position of the cursor is unaffected. If the cursor is dynamic, the delete will
									 be visible in the cursor, and the cursor will attempt to be positioned as close
									 as possible to the deleted row. If the cursor is searchable, the cursor will be
									 positioned as though a <symbol>FindNearest</symbol> had been called on the
									 deleted row. Otherwise, it will be positioned as though a
									 <symbol>Reset</symbol> had been called.</para> 
								<para>The row specified by <symbol>ARow</symbol> need
									 not conform to the heading for the table over which the cursor ranges. Columns
									 are matched by name with the given row.</para> 
						  </listitem> 
						  <listitem> 
								<para><symbol>BOF(const ACursor : cursor) :
									 Boolean</symbol></para> 
								<para>Returns true if the cursor specified by
									 <symbol>ACursor</symbol> is positioned on the BOF crack, or before the first
									 row in the result set, and false otherwise.</para> 
						  </listitem> 
						  <listitem> 
								<para><symbol>EOF(const ACursor : cursor) :
									 Boolean</symbol></para> 
								<para>Returns true if the cursor specified by
									 <symbol>ACursor</symbol> is positioned on the EOF crack, or after the last row
									 in the result set, and false otherwise.</para> 
						  </listitem> 
						  <listitem> 
								<para><symbol>IsEmpty(const ACursor : cursor) :
									 Boolean</symbol></para> 
								<para>Returns true if both <symbol>BOF</symbol> and
									 <symbol>EOF</symbol> are true for the cursor specified by
									 <symbol>ACursor</symbol> and false otherwise. This state indicates that the
									 cursor is ranging over an empty result set.</para> 
						  </listitem> 
						  <listitem> 
								<para><symbol>First(const ACursor :
									 cursor)</symbol></para> 
								<para>Positions the cursor specified by
									 <symbol>ACursor</symbol> on the BOF crack. <symbol>BOF</symbol> is guaranteed
									 to be true after a call to <symbol>First</symbol>.</para> 
						  </listitem> 
						  <listitem> 
								<para><symbol>Prior(const ACursor : cursor) :
									 Boolean</symbol></para> 
								<para>Navigates the cursor specified by
									 <symbol>ACursor</symbol> to the prior row in the result set. If the navigation
									 is successful, i.e. the cursor is positioned on a row, the operator returns
									 true. Otherwise, the operator returns false.</para> 
						  </listitem> 
						  <listitem> 
								<para><symbol>Next(const ACursor : cursor) :
									 Boolean</symbol></para> 
								<para>Navigates the cursor specified by
									 <symbol>ACursor</symbol> to the next row in the result set. If the navigation
									 is successful, i.e. the cursor is positioned on a row, the operator returns
									 true. Otherwise, the operator returns false.</para> 
						  </listitem> 
						  <listitem> 
								<para><symbol>Last(const ACursor :
									 cursor)</symbol></para> 
								<para>Positions the cursor specified by
									 <symbol>ACursor</symbol> on the EOF crack. <symbol>EOF</symbol> is guaranteed
									 to be true after a call to <symbol>Last</symbol>.</para> 
						  </listitem> 
						  <listitem> 
								<para><symbol>Reset(const ACursor :
									 cursor)</symbol></para> 
								<para>Refreshes the result set for the cursor specified
									 by <symbol>ACursor</symbol> from the underlying database and positions the
									 cursor on the BOF crack. Note that even a static cursor will be refreshed after
									 a call to <symbol>Reset</symbol>. <symbol>BOF</symbol> is guaranteed to be true
									 after a call to <symbol>Reset</symbol>.</para> 
						  </listitem> 
						  <listitem> 
								<para><symbol>GetKey(const ACursor : cursor) :
									 row</symbol></para> 
								<para>Gets the key value for the current row of the
									 cursor specified by <symbol>ACursor</symbol>. This row can be used in
									 subsequent calls to <symbol>FindKey</symbol> and
									 <symbol>FindNearest</symbol>.</para> 
						  </listitem> 
						  <listitem> 
								<para><symbol>FindKey(const ACursor : cursor, ARow :
									 row) : Boolean</symbol></para> 
								<para>Finds the key value given by
									 <symbol>ARow</symbol> in the cursor specified by <symbol>ACursor</symbol>. If
									 the find is successful, the operator returns true, indicating that the cursor
									 is positioned on a row with a key value matching that specified by
									 <symbol>ARow</symbol>. Otherwise, the operator returns false, and the position
									 of the cursor is unaffected. Note that if the key value specified by
									 <symbol>ARow</symbol> is a partial key, then the cursor is not guaranteed to be
									 on any particular row within the set of rows matching the partial key.</para> 
						  </listitem> 
						  <listitem> 
								<para><symbol>FindNearest(const ACursor : cursor, ARow
									 : row)</symbol></para> 
								<para>Finds the row most closely matching the key value
									 given by <symbol>ARow</symbol> in the cursor specified by
									 <symbol>ACursor</symbol>. No guarantees are made about the position of the
									 cursor after a call to <symbol>FindNearest</symbol>. As specified for the
									 <symbol>FindKey</symbol> operator, if the key value given by
									 <symbol>ARow</symbol> is a partial key, then the cursor is not guaranteed to be
									 on any particular row within the set of rows matching the partial key.</para> 
						  </listitem> 
						  <listitem> 
								<para><symbol>Refresh(const ACursor : cursor, ARow :
									 row)</symbol></para> 
								<para>Refreshes the result set for the cursor specified
									 by <symbol>ACursor</symbol> and attempts to position the cursor on the row
									 given by <symbol>ARow</symbol>. This operator is conceptually equivalent to
									 calling <symbol>Reset</symbol> followed by <symbol>FindNearest</symbol>.</para>
								
						  </listitem> 
						  <listitem> 
								<para><symbol>GetBookmark(const ACursor : cursor) :
									 row</symbol></para> 
								<para>Gets a bookmark for the current row of the cursor
									 specified by <symbol>ACursor</symbol>. This bookmark can then be used in
									 subsequent calls to <symbol>GotoBookmark</symbol> and
									 <symbol>CompareBookmarks</symbol>. Note that the structure of the row returned
									 by <symbol>GetBookmark</symbol> is implementation defined and not guaranteed to
									 be meaningful. A bookmark is only guaranteed to be valid for the cursor from
									 which it was retrieved.</para> 
						  </listitem> 
						  <listitem> 
								<para><symbol>GotoBookmark(const ACursor : cursor,
									 const ABookmark : row) : Boolean</symbol></para> 
								<para>Positions the cursor specified by
									 <symbol>ACursor</symbol> on the row corresponding to the bookmark given by
									 <symbol>ABookmark</symbol>. This bookmark must have been previously retrieved
									 with a call to <symbol>GetBookmark</symbol>. The operator returns true if the
									 bookmark is valid and the cursor is positioned on the correct row. The operator
									 returns false if the bookmark is invalid, or the row could not be located. If
									 the operator returns false, the position of the cursor is unaffected.</para> 
						  </listitem> 
						  <listitem> 
								<para><symbol>CompareBookmarks(const ACursor : cursor,
									 const ABookmark1 : row, const ABookmark2 : row) : Integer</symbol></para> 
								<para>Compares the bookmarks given by
									 <symbol>ABookmark1</symbol> and <symbol>ABookmark2</symbol> using the cursor
									 specified by <symbol>ACursor</symbol>. The given bookmarks must have been
									 previously retrieved with a call to <symbol>GetBookmark</symbol>. The operator
									 returns -1 if <symbol>ABookmark1</symbol> is less than
									 <symbol>ABookmark2</symbol>, 0 if they are equal, and 1 if
									 <symbol>ABookmark1</symbol> is greater than <symbol>ABookmark2</symbol>.</para>
								
						  </listitem> 
						  <listitem> 
								<para><symbol>Close(const ACursor :
									 cursor)</symbol></para> 
								<para>Closes the cursor specified by
									 <symbol>ACursor</symbol> and deallocates any associated resources. All cursors
									 opened using a cursor selector must be closed with this operator.</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>The following examples illustrate the use of cursors in D4: 
					 <programlisting>// Use a cursor to build a list of names of objects in the system.
begin
	var LCursor : cursor(table { Name : Name }) := 
		cursor(Objects over { Name });
	var LNameList : String := "";
	try
		while LCursor.Next() do
		begin
			if LNameList.Length() &gt; 0 then
				LNameList := LNameList + ", ";
			LNameList := 
				LNameList + (Name from LCursor.Select()).Value;
		end;
		if LNameList.Length() &gt; 0 then
			LNameList := LNameList + ".";
		raise Error("Object Names: " + LNameList);
	finally
		LCursor.Close();
	end;
end;</programlisting> 
					 <programlisting>// Find a specific object name in the system.
begin
	var LCursor : cursor(table { Name : Name }) :=
		cursor(Objects over { Name } capabilities { Navigable, Searchable });
	try
		if not LCursor.FindKey(row { Name("System.Integer") Name }) then
			raise Error("System.Integer data type not found");
	finally
		LCursor.Close();
	end;
end;</programlisting> 
					 <programlisting>// Find the closest match to a given name in the system
begin
	var LCursor : cursor(table { Name : Name }) :=
		cursor(Objects over { Name } capabilities { Navigable, Searchable });
	try
		LCursor.FindNearest(row { Name("System.FindKey") Name });
		raise Error((Name from LCursor.Select()).Value);
	finally
		LCursor.Close();
	end;
end;</programlisting> 
					 <programlisting>// Use bookmarks to reposition the cursor
begin
	var LCursor : cursor(table { Name : Name }) :=
		cursor(Objects over { Name } 
			capabilities { Navigable, Bookmarkable, Searchable });
	try
		LCursor.FindKey(row { Name("System.Integer") Name });
		var LRow : row := LCursor.GetBookmark();
		LCursor.First();
		LCursor.GotoBookmark(LRow);
	finally
		LCursor.Close();
	end;
end;</programlisting></para> 
		  </sect2> 
		  <sect2 id="D4LGUsingGenerators"> 
				<title><indexterm><primary>Using
								Generators</primary></indexterm><indexterm><primary>Programming
								Topics</primary><secondary>Using Generators</secondary></indexterm>Using
					 Generators</title> 
				<para>Several operators in the System Library can be used to help
					 create auto-incrementing defaults. In order to be used, a table must be created
					 to store the generators. The <symbol>SetGenerators</symbol> operator binds the
					 DAE's auto-incrementing operator support to a given table. The following
					 example illustrates the use of this operator: 
					 <programlisting>create table Generators
{
	ID : String,
	NextKey : Integer,
	key { ID }
};

SetGenerators(Name("Generators"));</programlisting> </para> 
				<para>To have the system construct a generators table if one is not
					 already present, use the operator <symbol>EnsureGenerators</symbol>. The
					 following example illustrates the use of this operator: 
					 <programlisting>/*
  checks if a generators table exists and 
  creates System.Generators if one does not
*/
EnsureGenerators();</programlisting></para> 
				<para>The generators table must have the same structure as shown
					 above. Auto-incremented values can then be obtained using the
					 <symbol>GetNextGenerator</symbol> operator. The following example illustrates
					 the use of this operator in a default definition: 
					 <programlisting>create table Test
{
	ID : Integer { default GetNextGenerator("Test_ID") },
	Name : String,
	key { ID }
}; </programlisting> </para> 
		  </sect2> 
		  <sect2 id="D4LGUsingDevices"> 
				<title><indexterm><primary>Using
								Devices</primary></indexterm><indexterm><primary>Programming
								Topics</primary><secondary>Using Devices</secondary></indexterm>Using
					 Devices</title> 
				<para>Devices are central to the data integration capabilities of
					 the DAE. Devices provide the abstraction layer through which the DAE
					 communicates with other database management systems. The device layer describes
					 the functionality necessary for this abstraction to take place.</para> 
				<sect3 id="D4LGStorageIntegrationArchitecture"> 
					 <title><indexterm><primary>Storage Integration
									 Architecture</primary></indexterm><indexterm><primary>Using
									 Devices</primary><secondary>Storage Integration
									 Architecture</secondary></indexterm>Storage Integration Architecture</title> 
					 <para>The DAE uses devices as a central component of the
						  Storage Integration Architecture (SIA) which allows disparate data sources to
						  be accessed as a single relational store. In order to accomplish this, the
						  query processor of the DAE enlists the help of devices to process queries as
						  appropriate. The DAE asks each device involved in a given query whether it is
						  capable of processing portions of the query. If the device indicates it is
						  capable of handling a particular portion of the query, the DAE hands off query
						  processing at that point. The device is then responsible for producing the
						  results of that portion of the query. If the entire query can be handed off in
						  this manner, the DAE does no processing. Otherwise, the DAE takes over wherever
						  each device leaves off and performs the required processing to produce the
						  result set. If multiple devices are involved, clearly, the DAE must take over
						  processing.</para> 
					 <para>This process of determining which device should process
						  each portion of a query is called <emphasis>chunking</emphasis>. In order to
						  fulfill a certain request, the device must be able to produce the result set in
						  a manner the DAE can consume. Therefore, each device is responsible for
						  translating the values it retrieves into a format suitable for use in the DAE.
						  In order to accomplish this, each device has a mapping from the data types in
						  the DAE to the appropriate data type in the storage system the device is
						  abstracting. These mappings are called <emphasis>domain maps</emphasis> and are
						  invoked by the device to perform the translation for values of the given
						  type.</para> 
					 <para>Additionally, chunking involves determining whether a
						  given operator is supported against the device. Each device must support basic
						  retrieval of base table variables. Support for additional operators is
						  indicated by providing a mapping to operators in the DAE. Each operator that is
						  supported in the DAE has an associated <emphasis>operator map</emphasis> which
						  is invoked to perform language translation services for the device.</para> 
				</sect3> 
				<sect3 id="D4LGReconciliation"> 
					 <title><indexterm><primary>Reconciliation</primary></indexterm><indexterm><primary>Using
									 Devices</primary><secondary>Reconciliation</secondary></indexterm>Reconciliation</title>
					 
					 <para>Each Device has its own internal catalog, and to achieve
						  the goal of centralizing the business model, this catalog must be synchronized
						  with the master catalog in the DAE. To accomplish this, the device interface
						  provides facilities for schema reconciliation. Through this process, catalog
						  information can be imported from, exported to, or reconciled with the catalog
						  of each individual Device.</para> 
					 <para>Reconciliation is the process of synchronization of
						  structure between the dataphor catalog and the device catalogs. The process can
						  be automatic, or user initiated. Each device has two settings which determine
						  how and when reconciliation occurs, a reconciliation mode and reconciliation
						  master.</para> 
					 <para>The reconciliation mode can be either
						  <symbol>none</symbol>, or any combination of <symbol>startup</symbol>,
						  <symbol>command</symbol>, and <symbol>automatic</symbol>. </para> 
					 <para>The reconciliation modes have the following
						  meaning.</para> 
					 <para> 
						  <itemizedlist mark="bullet"> 
								<listitem> 
									 <para> Startup indicates that the device should be
										  reconciled on DAE startup, as well as when the create device statement is
										  executed.</para> 
								</listitem> 
								<listitem> 
									 <para>Command indicates that Data Definition
										  Language (DDL) commands (Create, Alter, Drop) executed against the DAE should
										  be passed through to the device as well</para> 
								</listitem> 
								<listitem> 
									 <para>Automatic indicates that tables should be
										  verified and updated appropriately as they are encountered in Data Manipulation
										  Language (DML) statements (Select, Insert, Update, and Delete) executed against
										  the DAE.</para> 
								</listitem> 
						  </itemizedlist> </para> 
					 <para>In addition to these reconciliation modes, the
						  reconciliation process can be user initiated with a call to the
						  <symbol>Reconcile</symbol> operator. This operator takes a single
						  <symbol>System.Name</symbol> argument that is the name of the device to be
						  reconciled. The following example illustrates the use of this operator: 
						  <programlisting>Reconcile(Name("MyDevice"));</programlisting></para> 
					 <para>The reconciliation master can be <symbol>server</symbol>,
						  <symbol>device</symbol>, or <symbol>both</symbol>. Server indicates that the
						  DAE contains the master copy of the catalog. Device indicates that the device
						  is considered the master catalog, and both indicates that the catalogs should
						  be reconciled from both directions.</para> 
					 <para>Reconciliation for a device proceeds as follows: 
						  <orderedlist> 
								<listitem> 
									 <para>If the reconciliation master setting is
										  <symbol>server</symbol> or <symbol>both</symbol>, each table in the DAE catalog
										  is reconciled against the device. If a table does not exist in the device, it
										  is created; otherwise, it is updated to match the DAE.</para> 
								</listitem> 
								<listitem> 
									 <para>If the reconciliation master setting is
										  <symbol>device</symbol> or <symbol>both</symbol>, each table in the device
										  catalog is reconciled against the DAE. If it does not exist in the DAE, it is
										  created; otherwise, it is updated to match the device.</para> 
								</listitem> 
						  </orderedlist></para> 
					 <para>Beyond this basic process, each device may provide
						  specific reconciliation functionality.</para> 
					 <para>Catalog reconciliation for a table proceeds as follows: 
						  <orderedlist> 
								<listitem> 
									 <para>If the DAE table is master, the columns in
										  the device table must be a superset of the columns in the DAE table. </para> 
								</listitem> 
								<listitem> 
									 <para>If the device table is master, the columns in
										  the DAE table must be a superset of the columns in the device table.</para> 
								</listitem> 
						  </orderedlist></para> 
					 <para>Tables imported into the DAE by this process will be
						  named with the name of the table in the target system, namespace qualified with
						  the name of the device. For example, if a device called <symbol>Pubs</symbol>
						  is reconciled against the pubs sample database that ships with Microsoft SQL
						  Server, the DAE will include a table called
						  <symbol>Pubs.authors</symbol>.</para> 
					 <para>Data types of imported tables will be matched as closely
						  as possible to the DAE system library data types. If a data type cannot be
						  reconciled, an appropriate error will be given.</para> 
				</sect3> 
				<sect3 id="D4LGAvailableDevices"> 
					 <title><indexterm><primary>Available
									 Devices</primary></indexterm><indexterm><primary>Using
									 Devices</primary><secondary>Available Devices</secondary></indexterm>Available
						  Devices</title> 
					 <para>The Dataphor DAE provides several Devices as shown in the
						  following list:</para> 
					 <para> 
						  <itemizedlist mark="bullet"> 
								<listitem> 
									 <para>Memory</para> 
									 <para>The memory device provides in-memory storage.
										  Data stored in this device is not persisted to disk.</para> 
								</listitem> 
								<listitem> 
									 <para>Microsoft SQL Server</para> 
									 <para>This device provides full integration with
										  Microsoft SQL Server.</para> 
								</listitem> 
								<listitem> 
									 <para>Oracle</para> 
									 <para>This device provides full integration with
										  the Oracle database system.</para> 
								</listitem> 
								<listitem> 
									 <para>DB2</para> 
									 <para>This device provides full integration with
										  the IBM DB2 Universal DBMS.</para> 
								</listitem> 
								<listitem> 
									 <para>Linter</para> 
									 <para>This device provides full integration with
										  the Relexus Linter DBMS.</para> 
								</listitem> 
								<listitem> 
									 <para>Generic SQL</para> 
									 <para>This device provides a starting point for
										  building Device interfaces to other SQL based database systems.</para> 
								</listitem> 
						  </itemizedlist> </para> 
					 <para>Additionally, developers can provide custom devices to
						  enable access to any data store. Each device must provide at least forward only
						  cursor access to the data. If the device is updateable, it must also be capable
						  of executing update statements, or of accepting row-level update
						  commands.</para> 
					 <para>Also, as more devices are built, they will be included
						  with the product. Check the Alphora website at www.alphora.com for the latest
						  information on available devices.</para> 
					 <para>More information on each of these devices is provided in
						  the following sections.</para> 
				</sect3> 
				<sect3 id="D4LGSQLDevices"> 
					 <title><indexterm><primary>SQL
									 Devices</primary></indexterm><indexterm><primary>Using
									 Devices</primary><secondary>SQL Devices</secondary></indexterm>SQL
						  Devices</title> 
					 <para>The SQL Devices allow the DAE to connect to systems which
						  use SQL as their primary interface language. Because these systems deal with
						  data similarly, the DAE is able to hand off significant portions of the query
						  processing load. This is accomplished by translating the expressions given in
						  D4 into the equivalent SQL. Most of the work of translating into SQL is done by
						  the generic SQL device, which handles the least common denominator SQL
						  language. We refer to this de facto standard SQL as <emphasis>Common
						  SQL</emphasis>. Each specific device is then responsible only for describing
						  how the dialect it uses differs from this standard. For more information on how
						  to build a custom SQL device, refer to Part II of this manual.</para> 
					 <para>In order to make use of an SQL-based device from the DAE,
						  two main factors must be considered: connectivity, and translation.
						  Connectivity is concerned with basic data access, while translation is
						  concerned with converting expressions of D4 into their equivalent
						  representations in the various dialects of SQL.</para> 
					 <sect4 id="D4LGConnectivity"> 
						  <title><indexterm><primary>Connectivity</primary></indexterm><indexterm><primary>SQL
										  Devices</primary><secondary>Connectivity</secondary></indexterm>Connectivity</title>
						  
						  <para>All the SQL devices use a common connectivity layer
								to facilitate actual communication with the different systems. This
								connectivity layer is represented by a set of .NET classes which are part of
								the DAE. As with other parts of the DAE, these classes can be customized as
								necessary. For more information on the architecture of these connectivity
								classes, and how to customize them, refer to Part II of this manual.</para> 
						  <para>The following table lists the available
								implementations as of the preparation of this document. More may be made
								available in the future as necessary. 
								<informaltable> 
									 <tgroup cols="2"><thead> 
												<row><entry>Data Access
														  Technology</entry><entry>SQL Connectivity Connection Class</entry> 
												</row></thead><tbody> 
												<row><entry>ADO</entry><entry><symbol>ADOConnection</symbol>
														  in the namespace <symbol>Alphora.Dataphor.DAE.Connection.ADO</symbol> in the
														  assembly <symbol>Alphora.Dataphor.DAE.Connection.ADO</symbol></entry> 
												</row> 
												<row><entry>ADO.NET Provider for Microsoft
														  SQL Server</entry><entry><symbol>MSSQLConnection</symbol> in the namespace
														  <symbol>Alphora.Dataphor.DAE.Connection</symbol> in the assembly
														  <symbol>Alphora.Dataphor.DAE.Connection</symbol></entry> 
												</row> 
												<row><entry>ADO.NET Provider for OLE
														  DB</entry><entry><symbol>OLEDBConnection</symbol> in the namespace
														  <symbol>Alphora.Dataphor.DAE.Connection</symbol> in the assembly
														  <symbol>Alphora.Dataphor.DAE.Connection</symbol></entry> 
												</row> 
												<row><entry>ADO.NET Provider for
														  ODBC</entry><entry><symbol>ODBCConnection</symbol> in the namespace
														  <symbol>Alphora.Dataphor.DAE.Connection.ODBC</symbol> in the assembly
														  <symbol>Alphora.Dataphor.DAE.Connection.ODBC</symbol></entry> 
												</row> 
												<row><entry>Microsoft ADO.NET Provider for
														  Oracle</entry><entry><symbol>OracleConnection</symbol> in the namespace
														  <symbol>Alphora.Dataphor.DAE.Connection.Oracle</symbol> in the assembly
														  <symbol>Alphora.Dataphor.DAE.Connection.Oracle</symbol></entry> 
												</row></tbody> 
									 </tgroup> 
								</informaltable></para> 
						  <para>Each of these data access layers uses a
								<emphasis>connection string</emphasis> to provide connection information to the
								target system. Connection strings are a set of name-value pairs called
								<emphasis>parameters</emphasis>. Each device builds a connection string by
								assembling a list of parameters, and then converting it into a string suitable
								for passing to the connectivity implementations. This is done through a class
								called the <symbol>ConnectionStringBuilder</symbol>. Each style of connection
								string has an associated connection string builder class. Refer to the
								documentation for each specific device for a list of the connection string
								builder classes available.</para> 
					 </sect4> 
					 <sect4 id="D4LGTranslation"> 
						  <title><indexterm><primary>Translation</primary></indexterm><indexterm><primary>SQL
										  Devices</primary><secondary>Translation</secondary></indexterm>Translation</title>
						  
						  <para>There are two basic functions which must be performed
								by the devices to implement complete translation. The first is value
								translation, which is concerned with converting the data from the device
								representation as it comes in from the connectivity layer into a format
								suitable for use in the DAE. The second is language translation which is
								concerned with the actual translation of a given D4 expression into the
								equivalent SQL.</para> 
						  <sect5 id="D4LGValueTranslation"> 
								<title><indexterm><primary>Value
												Translation</primary></indexterm><indexterm><primary>Translation</primary><secondary>Value
												Translation</secondary></indexterm>Value Translation</title> 
								<para>Value translation is handled by <emphasis>domain
									 maps</emphasis>. The base SQL device does not map any domains by default, but
									 does provide a set of translation handlers for the specific SQL devices to use.
									 The following table lists the default mapping for data types from the DAE to
									 Common SQL, and the translation handler responsible for the mapping: 
									 <informaltable> 
										  <tgroup cols="3"><thead> 
													 <row><entry>D4 Data
																Type</entry><entry>Common SQL Data Type</entry><entry>Translation Class</entry>
														  
													 </row></thead><tbody> 
													 <row><entry><symbol>System.Boolean</symbol></entry><entry>INTEGER
																(0 or 1)</entry><entry><symbol>SQLBoolean</symbol></entry> 
													 </row> 
													 <row><entry><symbol>System.Byte</symbol></entry><entry>SMALLINT</entry><entry><symbol>SQLByte</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>System.Short</symbol></entry><entry>SMALLINT</entry><entry><symbol>SQLShort</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>System.Integer</symbol></entry><entry>INTEGER</entry><entry><symbol>SQLInteger</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>System.Long</symbol></entry><entry>BIGINT</entry><entry><symbol>SQLLong</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>System.Decimal</symbol></entry><entry>DECIMAL(<symbol>P</symbol>,
																<symbol>S</symbol>)</entry><entry><symbol>SQLDecimal</symbol></entry> 
													 </row> 
													 <row><entry><symbol>System.DateTime</symbol></entry><entry>DATETIME</entry><entry><symbol>SQLDateTime</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>System.TimeSpan</symbol></entry><entry>BIGINT</entry><entry><symbol>SQLTimeSpan</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>System.Money</symbol></entry><entry>DECIMAL(28,
																8)</entry><entry><symbol>SQLMoney</symbol></entry> 
													 </row> 
													 <row><entry><symbol>System.Guid</symbol></entry><entry>CHAR(24)</entry><entry><symbol>SQLGuid</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>System.String</symbol>,
																<symbol>System.IString</symbol></entry><entry>VARCHAR(<symbol>L</symbol>) or
																CLOB</entry><entry><symbol>SQLString</symbol></entry> 
													 </row> 
													 <row><entry><symbol>System.Image</symbol></entry><entry>BLOB</entry><entry><symbol>SQLImage</symbol></entry>
														  
													 </row></tbody> 
										  </tgroup> 
									 </informaltable></para> 
								<para>All the translation classes listed above are
									 declared in the namespace <symbol>Alphora.Dataphor.DAE.Device.SQL</symbol> and
									 assembly <symbol>Alphora.Dataphor.DAE.Device.SQL</symbol>.</para> 
								<para>The following table lists meta data tags that can
									 be used to control reconciliation and value translation in the SQL devices: 
									 <informaltable> 
										  <tgroup cols="2"><thead> 
													 <row><entry>Tag
																Name</entry><entry>Meaning</entry> 
													 </row></thead><tbody> 
													 <row><entry><symbol>Storage.Name</symbol></entry><entry>Indicates
																that the object on which it appears should be identified by the value of the
																tag when referenced within the device.</entry> 
													 </row> 
													 <row><entry><symbol>Storage.Length</symbol></entry><entry>Indicates
																the storage length for translated domains. This tag is only used for the string
																domains (<symbol>System.String</symbol> and <symbol>System.IString</symbol>) to
																indicate the length of the VARCHAR data type to be used. If the value of this
																tag is <symbol>unlimited</symbol>, the SQL column will use a CLOB, or
																equivalent text storage data type.</entry> 
													 </row> 
													 <row><entry><symbol>Storage.Precision</symbol></entry><entry>Indicates
																the storage precision for exact numeric data in translated domains. This tag is
																only used for the <symbol>System.Decimal</symbol> domain to indicate the
																precision of the DECIMAL data type to be used.</entry> 
													 </row> 
													 <row><entry><symbol>Storage.Scale</symbol></entry><entry>Indicates
																the storage scale for exact numeric data in translated domains. This tag is
																only used for the <symbol>System.Decimal</symbol> domain to indicate the scale
																of the DECIMAL data type to be used.</entry> 
													 </row> 
													 <row><entry><symbol>Storage.Deferred</symbol></entry><entry>Indicates
																that the values for the column or domain on which it appears should be read
																entirely as overflow. If the value of this tag is <symbol>true</symbol>, the
																system will not retrieve values from this column when the table is selected,
																rather, the device will defer reading of the value for this column until it is
																actually read by the client application. At that point, a separate stream is
																used to read data for the column.</entry> 
													 </row></tbody> 
										  </tgroup> 
									 </informaltable></para> 
								<para>In addition to the translation handlers described
									 above, developers may define custom value translation by providing the
									 appropriate .NET classes. For more information on this process, refer to Part
									 II of this manual.</para> 
						  </sect5> 
						  <sect5 id="D4LGLanguageTranslation"> 
								<title><indexterm><primary>Language
												Translation</primary></indexterm><indexterm><primary>Translation</primary><secondary>Language
												Translation</secondary></indexterm>Language Translation</title> 
								<para>Language translation is handled by
									 <emphasis>operator maps</emphasis>. The base SQL device assumes that support
									 for all the system data types is provided, and maps most of the system library
									 operators for these types by default. The translation handlers are responsible
									 for transforming an expression of the operator they map into an equivalent
									 expression in SQL. For most of the operators, this functionality can be
									 accomplished in terms of Common SQL, but each specific device also has specific
									 handlers to accomodate variations in the SQL.</para> 
								<para>The following table lists the default operator
									 mappings for all SQL devices and the associated translation handlers: 
									 <informaltable> 
										  <tgroup cols="3"><thead> 
													 <row><entry>D4
																Operator</entry><entry>SQL Equivalent</entry><entry>Translation Handler</entry>
														  
													 </row></thead><tbody> 
													 <row><entry><symbol>iEqual</symbol>(<symbol>=</symbol>),
																all
																overloads</entry><entry><symbol>=</symbol></entry><entry><symbol>SQLEqual</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>iNotEqual</symbol>(<symbol>&lt;&gt;</symbol>),
																all
																overloads</entry><entry><symbol>&lt;&gt;</symbol></entry><entry><symbol>SQLNotEqual</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>iInclusiveLess</symbol>(<symbol>&lt;=</symbol>),
																all
																overloads</entry><entry><symbol>&lt;=</symbol></entry><entry><symbol>SQLInclusiveLess</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>iLess</symbol>(<symbol>&lt;</symbol>),
																all
																overloads</entry><entry><symbol>&lt;</symbol></entry><entry><symbol>SQLLess</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>iInclusiveGreater</symbol>(<symbol>&gt;=</symbol>),
																all
																overloads</entry><entry><symbol>&gt;=</symbol></entry><entry><symbol>SQLInclusiveGreater</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>iGreater</symbol>(<symbol>&gt;</symbol>),
																all
																overloads</entry><entry><symbol>&gt;</symbol></entry><entry><symbol>SQLGreater</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>iCompare</symbol>(<symbol>?=</symbol>),
																all overloads</entry><entry><symbol>case when X = Y then 0 else case when X
																&lt; Y then - 1 else 1 end
																end</symbol></entry><entry><symbol>SQLCompare</symbol></entry> 
													 </row> 
													 <row><entry><symbol>iBitwiseNot</symbol>(<symbol>~</symbol>),
																all
																overloads</entry><entry><symbol>~</symbol></entry><entry><symbol>SQLBitwiseNot</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>iBitwiseAnd</symbol>(<symbol>&amp;</symbol>),
																all
																overloads</entry><entry><symbol>&amp;</symbol></entry><entry><symbol>SQLBitwiseAnd</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>iBitwiseOr</symbol>(<symbol>|</symbol>),
																all
																overloads</entry><entry><symbol>|</symbol></entry><entry><symbol>SQLBitwiseOr</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>iBitwiseXor</symbol>(<symbol>^</symbol>),
																all
																overloads</entry><entry><symbol>^</symbol></entry><entry><symbol>SQLBitwiseXor</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>iLeftShift</symbol>(<symbol>&lt;&lt;</symbol>),
																all
																overloads</entry><entry><symbol>&lt;&lt;</symbol></entry><entry><symbol>SQLLeftShift</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>iRightShift</symbol>(<symbol>&gt;&gt;</symbol>),
																all
																overloads</entry><entry><symbol>&gt;&gt;</symbol></entry><entry><symbol>SQLRightShift</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>iNegate</symbol>(unary
																<symbol>-</symbol>), all
																overloads</entry><entry><symbol>-</symbol></entry><entry><symbol>SQLNegate</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>iAddition</symbol>(<symbol>+</symbol>),
																all overloads except for
																<symbol>String</symbol></entry><entry><symbol>+</symbol></entry><entry><symbol>SQLAddition</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>iSubtraction</symbol>(<symbol>-</symbol>),
																all
																overloads</entry><entry><symbol>-</symbol></entry><entry><symbol>SQLSubtraction</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>iMultiplication</symbol>(<symbol>*</symbol>),
																all
																overloads</entry><entry><symbol>*</symbol></entry><entry><symbol>SQLMultiplication</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>iDivision</symbol>(<symbol>/</symbol>),
																all integer types and <symbol>TimeSpan</symbol></entry><entry><symbol>cast(X as
																decimal(28, 8) / cast(Y as decimal(28,
																8)</symbol></entry><entry><symbol>SQLIntegerDivision</symbol></entry> 
													 </row> 
													 <row><entry><symbol>iDivision</symbol>(<symbol>/</symbol>),
																<symbol>Decimal</symbol> and
																<symbol>Money</symbol></entry><entry><symbol>/</symbol></entry><entry><symbol>SQLDivision</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>iDiv</symbol>(<symbol>div</symbol>),
																all integer
																types</entry><entry><symbol>/</symbol></entry><entry><symbol>SQLDivision</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>iMod</symbol>(<symbol>mod</symbol>),
																all integer
																types</entry><entry><symbol>%</symbol></entry><entry><symbol>SQLMod</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>iNot</symbol>(<symbol>not</symbol>),
																<symbol>Boolean</symbol></entry><entry><symbol>not</symbol></entry><entry><symbol>SQLNot</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>iAnd</symbol>(<symbol>and</symbol>),
																<symbol>Boolean</symbol></entry><entry><symbol>and</symbol></entry><entry><symbol>SQLAnd</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>iOr</symbol>(<symbol>or</symbol>),
																<symbol>Boolean</symbol></entry><entry><symbol>or</symbol></entry><entry><symbol>SQLOr</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>iXor</symbol>(<symbol>xor</symbol>),
																<symbol>Boolean</symbol></entry><entry><symbol>(X or Y) and not (X and
																Y)</symbol></entry><entry><symbol>SQLXor</symbol></entry> 
													 </row> 
													 <row><entry><symbol>IsNull(Alpha)</symbol></entry><entry><symbol>X
																is null</symbol></entry><entry><symbol>SQLIsNull</symbol></entry> 
													 </row> 
													 <row><entry><symbol>IfNull(Alpha,
																Alpha)</symbol></entry><entry><symbol>IsNull(X, Y)</symbol> 
																<para>Note that this
																	 translation, as with the others may be affected by the actual language emitter
																	 used by each device. The output shown here is typical of the MSSQL device,
																	 whereas the Oracle device would use a different construct. In either case, the
																	 translation handler remains the
																	 same.</para></entry><entry><symbol>SQLIfNull</symbol></entry> 
													 </row> 
													 <row><entry><symbol>iExists</symbol>(<symbol>exists</symbol>)</entry><entry><symbol>exists</symbol></entry><entry><symbol>SQLExists</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>iIn(Scalar,
																List)</symbol>, <symbol>iIn(Scalar,
																Table)</symbol>(<symbol>in</symbol>)</entry><entry><symbol>in</symbol></entry><entry><symbol>SQLIn</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>Count()</symbol></entry><entry><symbol>Count(*)</symbol></entry><entry><symbol>SQLAggregateOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>Count(Scalar)</symbol></entry><entry><symbol>Count(X)</symbol></entry><entry><symbol>SQLAggregateOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>Sum</symbol>, all
																overloads</entry><entry><symbol>Sum(X)</symbol></entry><entry><symbol>SQLAggregateOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>Min</symbol>, all
																overloads</entry><entry><symbol>Min(X)</symbol></entry><entry><symbol>SQLAggregateOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>Max</symbol>, all
																overloads</entry><entry><symbol>Max(X)</symbol></entry><entry><symbol>SQLAggregateOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>Avg</symbol>, all
																overloads</entry><entry><symbol>Avg(X)</symbol></entry><entry><symbol>SQLAggregateOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan.Milliseconds</symbol></entry><entry><symbol>X
																*
																TicksPerMillisecond</symbol></entry><entry><symbol>SQLTimeSpanMilliseconds</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan.Days</symbol></entry><entry><symbol>X
																* TicksPerDay</symbol></entry><entry><symbol>SQLTimeSpanDays</symbol></entry> 
													 </row> 
													 <row><entry><symbol>TimeSpan.Seconds</symbol></entry><entry><symbol>X
																*
																TicksPerSecond</symbol></entry><entry><symbol>SQLTimeSpanSeconds</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan.Minutes</symbol></entry><entry><symbol>X
																*
																TicksPerMinute</symbol></entry><entry><symbol>SQLTimeSpanMinutes</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan.Hours</symbol></entry><entry><symbol>X
																* TicksPerHour</symbol></entry><entry><symbol>SQLTimeSpanHours</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan.Ticks</symbol></entry><entry><symbol>X</symbol></entry><entry><symbol>SQLScalarSelector</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan</symbol>,
																1 operand</entry><entry><symbol>X1 *
																TicksPerDay</symbol></entry><entry><symbol>SQLTimeSpan1Operand</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan</symbol>,
																2 operands</entry><entry><symbol>X1 * TicksPerDay + X2 *
																TicksPerHour</symbol></entry><entry><symbol>SQLTimeSpan2Operands</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan</symbol>,
																3 operands</entry><entry><symbol>X1 * TicksPerDay + X2 * TicksPerHour + X3 *
																TicksPerMinute</symbol></entry><entry><symbol>SQLTimeSpan3Operands</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan</symbol>,
																4 operands</entry><entry><symbol>X1 * TicksPerDay + X2 * TicksPerHour + X3
																*TicksPerMinute + X4 *
																TicksPerSecond</symbol></entry><entry><symbol>SQLTimeSpan4Operands</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan</symbol>,
																5 operands</entry><entry><symbol>X1 * TicksPerDay + X2 * TicksPerHour + X3
																*TicksPerMinute + X4 * TicksPerSecond + X5 *
																TicksPerMillisecond</symbol></entry><entry><symbol>SQLTimeSpan5Operands</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>AddTicks(TimeSpan,
																Long)</symbol></entry><entry><symbol>X +
																Y</symbol></entry><entry><symbol>SQLTimeSpanAddTicks</symbol></entry> 
													 </row> 
													 <row><entry><symbol>Duration(TimeSpan)</symbol></entry><entry><symbol>Abs(X)</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan.Time</symbol>,
																1 operand</entry><entry><symbol>X1 *
																TicksPerHour</symbol></entry><entry><symbol>SQLTimeSpanTime1Operand</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan.Time</symbol>,
																2 operands</entry><entry><symbol>X1 * TicksPerHour + X2 *
																TicksPerMinute</symbol></entry><entry><symbol>SQLTimeSpanTime2Operands</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan.Time</symbol>,
																3 operands</entry><entry><symbol>X1 * TicksPerHour + X2 * TicksPerMinute + X3 *
																TicksPerSecond</symbol></entry><entry><symbol>SQLTimeSpanTime3Operands</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan.Time</symbol>,
																4 operands</entry><entry><symbol>X1 * TicksPerHour + X2 * TicksPerMinute + X3 *
																TicksPerSecond + X4 *
																TicksPerMillisecond</symbol></entry><entry><symbol>SQLTimeSpanTime4Operands</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan.ReadMilliseconds</symbol></entry><entry><symbol>X
																/
																TicksPerMillisecond</symbol></entry><entry><symbol>SQLTimeSpanReadMilliseconds</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan.WriteMilliseconds</symbol></entry><entry><symbol>Y
																*
																TicksPerMillisecond</symbol></entry><entry><symbol>SQLTimeSpanWriteMilliseconds</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan.ReadTicks</symbol></entry><entry><symbol>X</symbol></entry><entry><symbol>SQLScalarReadAccessor</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan.WriteTicks</symbol></entry><entry><symbol>Y</symbol></entry><entry><symbol>SQLScalarWriteAccessor</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan.ReadMinutes</symbol></entry><entry><symbol>X
																/
																TicksPerMinute</symbol></entry><entry><symbol>SQLScalarReadMinutes</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan.WriteMinutes</symbol></entry><entry><symbol>Y
																*
																TicksPerMinute</symbol></entry><entry><symbol>SQLTimeSpanWriteMinutes</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan.ReadHours</symbol></entry><entry><symbol>X
																/
																TicksPerHour</symbol></entry><entry><symbol>SQLTimeSpanReadHours</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan.WriteHours</symbol></entry><entry><symbol>Y
																*
																TicksPerHour</symbol></entry><entry><symbol>SQLTimeSpanWriteHours</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan.ReadSeconds</symbol></entry><entry><symbol>X
																/
																TicksPerSecond</symbol></entry><entry><symbol>SQLTimeSpanReadSeconds</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan.WriteSeconds</symbol></entry><entry><symbol>Y
																*
																TicksPerSecond</symbol></entry><entry><symbol>SQLTimeSpanWriteSeconds</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan.ReadDays</symbol></entry><entry><symbol>X
																/
																TicksPerDay</symbol></entry><entry><symbol>SQLTimeSpanReadDays</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan.WriteDays</symbol></entry><entry><symbol>Y
																*
																TicksPerDay</symbol></entry><entry><symbol>SQLTimeSpanWriteDays</symbol></entry>
														  
													 </row> 
												</tbody> 
										  </tgroup> 
									 </informaltable>All the translation handlers listed
									 above are declared in the namespace
									 <symbol>Alphora.Dataphor.DAE.Device.SQL</symbol> in assembly
									 <symbol>Alphora.Dataphor.DAE.Device.SQL</symbol>.</para> 
								<para>In addition to the specific translators for
									 system operators, the base SQL device introduces several general purpose
									 translators that can be used without modification to handle most programming
									 tasks. The following table details the available handlers: 
									 <informaltable> 
										  <tgroup cols="2"><thead> 
													 <row><entry>Translation
																Handler</entry><entry>Functionality Provided</entry> 
													 </row></thead><tbody> 
													 <row><entry><symbol>SQLScalarSelector</symbol></entry><entry>Provides
																a basic passthrough implementation, in other words, the operator mapped to this
																handler is skipped in the translation output. This is useful when the device
																representation for a particular data type is known to be the same as the device
																representation for the data type of the single scalar component of the
																representation for a given selector. For example, the domain <symbol>ID {
																representation ID { Value : String } }</symbol> would have the same device
																representation as <symbol>String</symbol>, and so a selector invocation
																<symbol>ID("001")</symbol> would effectively be translated to just the string
																literal <symbol>"001"</symbol>.</entry> 
													 </row> 
													 <row><entry><symbol>SQLScalarReadAccessor</symbol></entry><entry>Provides
																a basic passthrough implementation for read accessors. To continue with the
																above example, the invocation in D4 <symbol>ID.Value</symbol> could be
																translated by simply ignoring the read accessor.</entry> 
													 </row> 
													 <row><entry><symbol>SQLScalarWriteAccessor</symbol></entry><entry>Provides
																a basic passthrough implementation for write accessors. The D4 assignment to
																<symbol>ID.Value</symbol> can be translated to SQL by a replacement of the
																value if the representation has a single scalar component with the same device
																representation as the type itself.</entry> 
													 </row> 
													 <row><entry><symbol>SQLScalarIsSpecialOperator</symbol></entry><entry>Provides
																a basic implementation for the <symbol>IsSpecial</symbol> operators created for
																each domain. If a domain has no specials, this handler is appropriate, as it
																always emits <symbol>0 = 1</symbol> or false, in SQL.</entry> 
													 </row> 
													 <row><entry><symbol>SQLCallOperator</symbol></entry><entry>Provides
																a generic handler that is capable of invoking an operator in SQL. This handler
																has an attribute called <symbol>OperatorName</symbol>, set through the
																attributes in the class definition, which is used to construct the output. For
																example, if the operator name of the handler is <symbol>Rand</symbol>, and the
																handler is mapped to the D4 operator <symbol>Random</symbol>, the result of
																translating the D4 expression <symbol>Random(5)</symbol> is
																<symbol>Rand(5)</symbol>. The call operator works with any number of operands
																for the operator being mapped. This is useful when the implementation for a
																specific operator in D4 is provided by a user-defined function in the target
																system.</entry> 
													 </row></tbody> 
										  </tgroup> 
									 </informaltable></para> 
								<para>In addition to these translation handlers,
									 developers may build custom translation handlers to accomodate new operators
									 built in D4. For more information on this process, refer to Part II of this
									 manual.</para> 
						  </sect5> 
						  <sect5 id="D4LGCaseSensitivity"> 
								<title><indexterm><primary>Case
												Sensitivity</primary></indexterm><indexterm><primary>Translation</primary><secondary>Case
												Sensitivity</secondary></indexterm>Case Sensitivity</title> 
								<para>For both of these translation functions to be
									 effective, they must utilize the case of the target system appropriately. For
									 this purpose, the base SQL device has an <symbol>IsCaseSensitive</symbol>
									 property which can be set using the attributes in the class definition section
									 for the device. This flag indicates whether the underlying SQL system is
									 case-sensitive or not. If this property is set to true, the target system is
									 considered case-sensitive, and the default mapping for the device will use
									 <symbol>String</symbol>, the case-sensitive string domain in the DAE.
									 Otherwise, the target system is considered case-insensitive, and the default
									 mapping for the device will use <symbol>IString</symbol>, the case-insensitive
									 string domain in the DAE. It is very important that the right case sensitivity
									 setting be selected, as incorrect settings could lead to unpredicatable
									 behavior by the device.</para> 
						  </sect5> 
					 </sect4> 
				</sect3> 
				<sect3 id="D4LGMicrosoftSQLServerDevice"> 
					 <title><indexterm><primary>Microsoft SQL Server
									 Device</primary></indexterm><indexterm><primary>Using
									 Devices</primary><secondary>Microsoft SQL Server
									 Device</secondary></indexterm>Microsoft SQL Server Device</title> 
					 <para>Dataphor provides a device for communicating with
						  Microsoft SQL Server, versions 7.0 and 2000. The device is also capable of
						  communicating with the Microsoft Desktop Engine (MSDE).</para> 
					 <sect4 id="D4LGSettings"> 
						  <title><indexterm><primary>Settings</primary></indexterm><indexterm><primary>Microsoft
										  SQL Server
										  Device</primary><secondary>Settings</secondary></indexterm>Settings</title> 
						  <para>The following table lists the settings available for
								the MSSQL device. These settings are configured using the attributes of the
								class definition: 
								<informaltable> 
									 <tgroup cols="2"><thead> 
												<row><entry>Attribute
														  Name</entry><entry>Possible Values</entry><entry>Meaning</entry> 
												</row></thead><tbody> 
												<row><entry><symbol>ConnectionClass</symbol></entry><entry>
														  
														  <programlisting>&lt;assembly qualified class name&gt;</programlisting></entry><entry>Determines the class which will be used to
														  implement the connectivity layer for this device. See the connectivity section
														  for a discussion of the possible settings for this attribute. The default value
														  for this attribute is
														  <symbol>Alphora.Dataphor.DAE.Connection.ADO.ADOConnection,
														  Alphora.Dataphor.DAE.Connection.ADO</symbol>.</entry> 
												</row> 
												<row><entry><symbol>ConnectionStringBuilderClass</symbol></entry><entry>
														  
														  <programlisting>&lt;assembly qualified class name&gt;</programlisting></entry><entry>Determines the class which will be used to
														  construct connection strings for this device. See the connectivity section for
														  a discussion of the possible settings for this attribute. The default value for
														  this attribute is
														  <symbol>Alphora.Dataphor.DAE.Device.MSSQL.MSSQLOLEDBConnectionStringBuilder,
														  AlphoraMSSQLDevice</symbol>.</entry> 
												</row> 
												<row><entry><symbol>ConnectionParameters</symbol></entry><entry>
														  
														  <programlisting>&lt;parameter&gt;{;&lt;parameter&gt;}

&lt;parameter&gt; ::=
	&lt;parameter name&gt;=&lt;parameter value&gt;</programlisting></entry><entry>Specifies additional connection parameters to
														  be used in building the connection string. For more information on how the
														  MSSQL device buils a connection string, refer to the connectivity
														  section.</entry> 
												</row> 
												<row><entry><symbol>ConnectionBufferSize</symbol></entry><entry>
														  
														  <programlisting>&lt;integer&gt;</programlisting></entry><entry>Specifies the number of rows to fetch at a time
														  from the target system. The default value for this attribute is 20. A value of
														  0 for this attribute indicates that the entire result set should be read
														  immediately, i.e., the result set should be
														  <emphasis>disconnected</emphasis>.</entry> 
												</row> 
												<row><entry><symbol>IsCaseSensitive</symbol></entry><entry>
														  
														  <programlisting>true | false</programlisting></entry><entry>Determines whether the target system is
														  case-sensitive for the purposes of identifier resolution and string comparison.
														  This setting determines whether the device will map the
														  <symbol>System.String</symbol> domain (case-sensitive) or the
														  <symbol>System.IString</symbol> domain (case-insensitive) by default. The
														  default value for this attribute is false.</entry> 
												</row> 
												<row><entry><symbol>IsMSSQL70</symbol></entry><entry>
														  
														  <programlisting>true | false</programlisting></entry><entry>Determines whether the target system is version
														  7.0. If this value is false, the system is considered version 2000. Version
														  2000 mappings will use user-defined functions in the target system to support
														  many of the operators in the DAE. For a version 7.0 system, these operators
														  must be translated as expressions inline. The default value for this attribute
														  is false.</entry> 
												</row> 
												<row><entry><symbol>ShouldEnsureDatabase</symbol></entry><entry>
														  
														  <programlisting>true | false</programlisting></entry><entry>Determines whether the database name given by
														  the <symbol>DatabaseName</symbol> attribute should be created on the target
														  system if it does not exist. The default value for this attribute is
														  true.</entry> 
												</row> 
												<row><entry><symbol>ShoudEnsureOperators</symbol></entry><entry>
														  
														  <programlisting>true | false</programlisting></entry><entry>Determines whether the device should ensure
														  that the user-defined functions used to support operator mapping exist in the
														  target system. This setting has no effect if the value of the
														  <symbol>IsMSSQL70</symbol> attribute is true. The default value for this
														  attribute is true. All the user-defined functions created by the MSSQL device
														  are prefixed by <symbol>DAE_</symbol>.</entry> 
												</row> 
												<row><entry><symbol>ServerName</symbol></entry><entry>
														  
														  <programlisting>&lt;server name&gt;</programlisting></entry><entry>Indicates the name of the Microsoft SQL Server
														  instance to use. This attribute has no default value.</entry> 
												</row> 
												<row><entry><symbol>DatabaseName</symbol></entry><entry>
														  
														  <programlisting>&lt;database name&gt;</programlisting></entry><entry>Indicates the name of the database to be used
														  within the specified server instance. This attribute has no default
														  value.</entry> 
												</row> 
												<row><entry><symbol>UseIntegratedSecurity</symbol></entry><entry>
														  
														  <programlisting>true | false</programlisting></entry><entry>Indicates whether integrated security should be
														  used to connect to the Microsoft SQL Server Instance. If the value of this
														  attribute is true, the device will connect to the specified server instance
														  using windows authentication. For more information on security configuration in
														  Microsoft SQL Server, see the Microsoft SQL Server Books Online.</entry> 
												</row></tbody> 
									 </tgroup> 
								</informaltable></para> 
					 </sect4> 
					 <sect4 id="D4LGConnectivity1"> 
						  <title><indexterm><primary>Connectivity</primary></indexterm><indexterm><primary>Microsoft
										  SQL Server
										  Device</primary><secondary>Connectivity</secondary></indexterm>Connectivity</title>
						  
						  <para>Connectivity for the MSSQL device begins by
								determining the connectivity implementation to be used. This is specified by
								the <symbol>ConnectionClass</symbol> attribute of the device. The following
								connection classes are available for use by this device: 
								<itemizedlist> 
									 <listitem> 
										  <para><symbol>ADOConnection</symbol></para> 
										  <para>This class is located in the
												<symbol>Alphora.Dataphor.DAE.Connection.ADO</symbol> namespace in the
												<symbol>Alphora.Dataphor.DAE.Connection.ADO</symbol> assembly. This
												connectivity implementation uses Microsoft Active Data Objects (ADO) to
												communicate with the specified server instance. This is the default
												connectivity implementation for the MSSQL device. This is also the only fully
												supported connectivity implementation due to some issues with the various
												ADO.NET data providers.</para> 
									 </listitem> 
									 <listitem> 
										  <para><symbol>OLEDBConnection</symbol></para> 
										  <para>This class is located in the
												<symbol>Alphora.Dataphor.DAE.Connection</symbol> namespace in the
												<symbol>Alphora.Dataphor.DAE.Connection</symbol> assembly. This connectivity
												implementation uses the Microsoft ADO.NET OLEDB data provider to communicate
												with the specified server instance.</para> 
									 </listitem> 
									 <listitem> 
										  <para><symbol>MSSQLConnection</symbol></para> 
										  <para>This class is located in the
												<symbol>Alphora.Dataphor.DAE.Connection</symbol> namespace in the
												<symbol>Alphora.Dataphor.DAE.Connection</symbol> assembly. This connectivity
												implementation uses the Microsoft ADO.NET native SQL Server data provider to
												communicate with the specified server instance.</para> 
									 </listitem> 
									 <listitem> 
										  <para><symbol>ODBCConnection</symbol></para> 
										  <para>This class is located in the
												<symbol>Alphora.Dataphor.DAE.Connection.ODBC</symbol> namespace in the
												<symbol>Alphora.Dataphor.DAE.Connection.ODBC</symbol> assembly. This
												connectivity implementation uses the Microsoft ADO.NET ODBC data provider to
												communicate with the specified server instance.</para> 
									 </listitem> 
								</itemizedlist></para> 
						  <para>The next step in establishing connectivity for the
								MSSQL device involves building the connection string to be used. The device
								creates an instance of the class specified by the
								<symbol>ConnectionStringBuilder</symbol> attribute. The following connection
								string builder classes are available for use by this device: 
								<itemizedlist> 
									 <listitem> 
										  <para><symbol>MSSQLOLEDBConnectionStringBuilder</symbol></para>
										  
										  <para>This class is defined in the
												<symbol>Alphora.Dataphor.DAE.Device.MSSQL</symbol> namespace in the
												<symbol>AlphoraMSSQLDevice</symbol> assembly. This class is capable of building
												connection strings for the <symbol>ADOConnection</symbol> and
												<symbol>OLEDBConnection</symbol> connectivity implementations. This is the
												default connection string builder class for the MSSQL device.</para> 
									 </listitem> 
									 <listitem> 
										  <para><symbol>MSSQLADODotNetConnectionStringBuilder</symbol></para>
										  
										  <para>This class is defined in the
												<symbol>Alphora.Dataphor.DAE.Device.MSSQL</symbol> namespace in the
												<symbol>AlphoraMSSQLDevice</symbol> assembly. This class is capable of building
												a connection string for the <symbol>MSSQLConnection</symbol> connectivity
												implementation.</para> 
									 </listitem> 
									 <listitem> 
										  <para><symbol>MSSQLODBCConnectionStringBuilder</symbol></para>
										  
										  <para>This class is defined in the
												<symbol>Alphora.Dataphor.DAE.Device.MSSQL</symbol> namespace in the
												<symbol>AlphoraMSSQLDevice</symbol> assembly. This class is capable of building
												a connection string for the <symbol>ODBCConnection</symbol> connectivity
												implementation.</para> 
									 </listitem> 
								</itemizedlist></para> 
						  <para>Once the connection string builder class is created,
								the server name, database name, and authentication information are given as
								parameters to the connection string builder. The connection string builder then
								makes any necessary mappings between parameter names. For example the ODBC
								connection string builder maps the <symbol>ServerName</symbol> parameter to the
								<symbol>DSN</symbol> parameter. If any parameters are specified in the
								<symbol>ConnectionParameters</symbol> attribute, they are included in the
								parameter set. If any parameter named in the
								<symbol>ConnectionParameters</symbol> is already in the parameter set, the
								parameter is replaced. In this way, the device can override specific connection
								parameters. Next, any connection parameters for the <symbol>DeviceUser</symbol>
								associated with this session are applied in the same way, with duplicates
								effectively replacing the value for the parameter. The full connection string
								is then assembled from the parameter list and passed to the connectivity
								implementation specified by the <symbol>ConnectionClass</symbol>
								attribute.</para> 
					 </sect4> 
					 <sect4 id="D4LGTranslation1"> 
						  <title><indexterm><primary>Translation</primary></indexterm><indexterm><primary>Microsoft
										  SQL Server
										  Device</primary><secondary>Translation</secondary></indexterm>Translation</title>
						  
						  <para>Value translation in the MSSQL device uses the
								following domain mappings: 
								<informaltable> 
									 <tgroup cols="3"><thead> 
												<row><entry>D4 Data
														  Type</entry><entry>Transact SQL Data Type</entry><entry>Translation
														  Class</entry> 
												</row></thead><tbody> 
												<row><entry><symbol>System.Boolean</symbol></entry><entry>BIT</entry><entry><symbol>MSSQLBoolean</symbol></entry>
													 
												</row> 
												<row><entry><symbol>System.Byte</symbol></entry><entry>TINYINT</entry><entry><symbol>MSSQLByte</symbol></entry>
													 
												</row> 
												<row><entry><symbol>System.Short</symbol></entry><entry>SMALLINT</entry><entry><symbol>SQLShort</symbol></entry>
													 
												</row> 
												<row><entry><symbol>System.Integer</symbol></entry><entry>INTEGER</entry><entry><symbol>SQLInteger</symbol></entry>
													 
												</row> 
												<row><entry><symbol>System.Long</symbol></entry><entry>BIGINT</entry><entry><symbol>SQLLong</symbol></entry>
													 
												</row> 
												<row><entry><symbol>System.Decimal</symbol></entry><entry>DECIMAL(<symbol>P</symbol>,
														  <symbol>S</symbol>)</entry><entry><symbol>SQLDecimal</symbol></entry> 
												</row> 
												<row><entry><symbol>System.DateTime</symbol></entry><entry>DATETIME</entry><entry><symbol>SQLDateTime</symbol></entry>
													 
												</row> 
												<row><entry><symbol>System.TimeSpan</symbol></entry><entry>BIGINT</entry><entry><symbol>SQLTimeSpan</symbol></entry>
													 
												</row> 
												<row><entry><symbol>System.Money</symbol></entry><entry>MONEY</entry><entry><symbol>MSSQLMoney</symbol></entry>
													 
												</row> 
												<row><entry><symbol>System.Guid</symbol></entry><entry>UNIQUEIDENTIFIER</entry><entry><symbol>MSSQLGuid</symbol></entry>
													 
												</row> 
												<row><entry><symbol>System.String</symbol>,
														  <symbol>System.IString</symbol></entry><entry>VARCHAR(<symbol>L</symbol>) or
														  TEXT</entry><entry><symbol>MSSQLString</symbol></entry> 
												</row> 
												<row><entry><symbol>System.Image</symbol></entry><entry>IMAGE</entry><entry><symbol>MSSQLImage</symbol></entry>
													 
												</row></tbody> 
									 </tgroup> 
								</informaltable></para> 
						  <para>Operator translation in the MSSQL device uses the
								following operator mappings: 
								<informaltable> 
									 <tgroup cols="3"><thead> 
												<row><entry>D4
														  Operator</entry><entry>Transact-SQL Equivalent</entry><entry>Translation
														  Handler</entry> 
												</row></thead><tbody> 
												<row><entry><symbol>iAddition(String,
														  String)</symbol>(<symbol>+</symbol>)</entry><entry><symbol>+</symbol></entry><entry><symbol>SQLAddition</symbol></entry>
													 
												</row> 
												<row><entry><symbol>Length(String)</symbol></entry><entry><symbol>Len</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>Copy(String, Integer,
														  Integer)</symbol></entry><entry><symbol>Substring(X, Y + 1,
														  Z)</symbol></entry><entry><symbol>MSSQLCopy</symbol></entry> 
												</row> 
												<row><entry><symbol>Pos(String,
														  String)</symbol></entry><entry><symbol>case when X = '' then 1 else
														  CharIndex(X, Y) end -
														  1</symbol></entry><entry><symbol>MSSQLPos</symbol></entry> 
												</row> 
												<row><entry><symbol>IndexOf(String,
														  String)</symbol></entry><entry><symbol>case when Y = '' then 1 else
														  CharIndex(Y, X) end -
														  1</symbol></entry><entry><symbol>MSSQLIndexOf</symbol></entry> 
												</row> 
												<row><entry><symbol>Upper(String)</symbol></entry><entry><symbol>Upper(X)</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>Lower(String)</symbol></entry><entry><symbol>Lower(X)</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>CompareText(String,
														  String)</symbol></entry><entry><symbol>case when Upper(X) = Upper(Y) then 0
														  when Upper(X) &lt; Upper(Y) then -1 else 1
														  end</symbol></entry><entry><symbol>MSSQLCompareText</symbol> 
														  <para>Note that this translation is
																only used if <symbol>IsCaseSensitive</symbol> is true for this device,
																otherwise <symbol>SQLCompare</symbol> is used to perform the
																translation.</para></entry> 
												</row> 
												<row><entry><symbol>IsSpecial</symbol>, all
														  overloads</entry><entry><symbol>1 =
														  0</symbol></entry><entry><symbol>SQLScalarIsSpecialOperator</symbol></entry> 
												</row> 
												<row><entry><symbol>iPower</symbol>(<symbol>**</symbol>)</entry><entry><symbol>Power(X,
														  Y)</symbol></entry><entry><symbol>MSSQLPower</symbol></entry> 
												</row> 
												<row><entry><symbol>Abs</symbol>, all
														  overloads</entry><entry><symbol>Abs</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>Round</symbol></entry><entry><symbol>Round</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>Ceiling</symbol></entry><entry><symbol>Ceiling</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>Floor</symbol></entry><entry><symbol>Floor</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>Ln</symbol></entry><entry><symbol>Log</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>Log10</symbol></entry><entry><symbol>Log10</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>Exp</symbol></entry><entry><symbol>Exp</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>Random</symbol></entry><entry><symbol>Rand</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>Now</symbol></entry><entry><symbol>GetDate</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DayOfMonth</symbol></entry><entry><symbol>Day</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DaysInMonth</symbol></entry><entry><symbol>DAE_DaysInMonth</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>IsLeapYear</symbol></entry><entry><symbol>DAE_IsLeapYear</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime(TimeSpan)</symbol></entry><entry><symbol>DAE_TSDateTime</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>TimeSpan(DateTime)</symbol></entry><entry><symbol>DAE_DTTimeSpan</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime.ReadMonthsPart</symbol></entry><entry><symbol>Month</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime.ReadDaysPart</symbol></entry><entry><symbol>Day</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime.ReadYearsPart</symbol></entry><entry><symbol>Year</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>Today</symbol></entry><entry><symbol>Round(GetDate())</symbol></entry><entry><symbol>MSSQLToday</symbol></entry>
													 
												</row> 
												<row><entry><symbol>ToBoolean</symbol>, all
														  overloads</entry><entry><symbol>convert(bit,
														  X)</symbol></entry><entry><symbol>MSSQLToBit</symbol></entry> 
												</row> 
												<row><entry><symbol>ToString(Boolean)</symbol></entry><entry><symbol>case
														  when X = 0 then 'False' else 'True'
														  end</symbol></entry><entry><symbol>SQLBooleanToString</symbol></entry> 
												</row> 
												<row><entry><symbol>ToString</symbol>, all
														  overloads except
														  <symbol>Boolean</symbol></entry><entry><symbol>convert(varchar,
														  X)</symbol></entry><entry><symbol>MSSQLToString</symbol></entry> 
												</row> 
												<row><entry><symbol>ToByte</symbol>,
														  <symbol>Boolean</symbol>, <symbol>String</symbol>, and
														  <symbol>IString</symbol></entry><entry><symbol>convert(tinyint,
														  X)</symbol></entry><entry><symbol>MSSQLToTinyInt</symbol></entry> 
												</row> 
												<row><entry><symbol>ToByte</symbol>, all
														  overloads except <symbol>Boolean</symbol>, <symbol>String</symbol>, and
														  <symbol>IString</symbol></entry><entry><symbol>convert(tinyint, X &amp;
														  (power(2, 8) - 1)) </symbol></entry><entry><symbol>MSSQLToByte</symbol></entry>
													 
												</row> 
												<row><entry><symbol>ToShort(Boolean)</symbol>,
														  <symbol>ToShort(String)</symbol>, <symbol>ToShort(IString)</symbol>,
														  <symbol>ToShort(Byte)</symbol></entry><entry><symbol>convert(smallint,
														  X)</symbol></entry><entry><symbol>MSSQLToSmallInt</symbol></entry> 
												</row> 
												<row><entry><symbol>ToShort(Integer)</symbol>,
														  <symbol>ToShort(Long)</symbol></entry><entry><symbol>convert(smallint, ((X
														  &amp; (power(2, 16) - 1) &amp; ~power(2, 15)) - (power(2, 15) &amp;
														  X)))</symbol></entry><entry><symbol>MSSQLToShort</symbol></entry> 
												</row> 
												<row><entry><symbol>ToInteger(Boolean)</symbol>,
														  <symbol>ToInteger(String)</symbol>, <symbol>ToInteger(IString)</symbol>,
														  <symbol>ToInteger(Byte)</symbol>, <symbol>ToInteger(Short)</symbol>,
														  <symbol>ToInteger(Decimal)</symbol>,
														  <symbol>ToInteger(Money)</symbol></entry><entry><symbol>convert(int,
														  X)</symbol></entry><entry><symbol>MSSQLToInt</symbol></entry> 
												</row> 
												<row><entry><symbol>ToInteger(Long)</symbol></entry><entry><symbol>convert(int,
														  ((X &amp; ((power(convert(bigint, 2), 32) - 1) &amp; ~(power(convert(bigint,
														  2), 31)) - (power(convert(bigint, 2), 31) &amp;
														  X)))</symbol></entry><entry><symbol>MSSQLToInteger</symbol></entry> 
												</row> 
												<row><entry><symbol>ToLong</symbol>, all
														  overloads</entry><entry><symbol>convert(bigint,
														  X)</symbol></entry><entry><symbol>MSSQLToBigInt</symbol></entry> 
												</row> 
												<row><entry><symbol>ToDecimal(Integer)</symbol>,
														  <symbol>ToDecimal(Long)</symbol>,
														  <symbol>ToDecimal(Money)</symbol></entry><entry><symbol>convert(decimal(28, 8)
														  X)</symbol></entry><entry><symbol>MSSQLToDecimal288</symbol></entry> 
												</row> 
												<row><entry><symbol>ToMoney(Integer)</symbol>,
														  <symbol>ToMoney(Long)</symbol>,
														  <symbol>ToMoney(Decimal)</symbol></entry><entry><symbol>convert(money,
														  X)</symbol></entry><entry><symbol>MSSQLToMoney</symbol></entry> 
												</row> 
												<row><entry><symbol>ToGuid(String)</symbol>,
														  <symbol>ToGuid(IString)</symbol></entry><entry><symbol>convert(uniqueidentifier,
														  X)</symbol></entry><entry><symbol>MSSQLToUniqueIdentifier</symbol></entry> 
												</row> 
												<row><entry><symbol>Frac</symbol></entry><entry><symbol>DAE_Frac</symbol></entry><entry><symbol>MSSQLFrac</symbol></entry>
													 
												</row> 
												<row><entry><symbol>Log</symbol></entry><entry><symbol>DAE_LogB</symbol></entry><entry><symbol>MSSQLLogB</symbol></entry>
													 
												</row> 
												<row><entry><symbol>Truncate</symbol></entry><entry><symbol>DAE_Trunc</symbol></entry><entry><symbol>MSSQLTruncate</symbol></entry>
													 
												</row> 
												<row><entry><symbol>TimeSpan.ReadDaysPart</symbol></entry><entry><symbol>DAE_TSReadDaysPart</symbol></entry><entry><symbol>MSSQLTimeSpanReadDaysPart</symbol></entry>
													 
												</row> 
												<row><entry><symbol>TimeSpan.ReadHoursPart</symbol></entry><entry><symbol>DAE_TSReadHoursPart</symbol></entry><entry><symbol>MSSQLTimeSpanReadHoursPart</symbol></entry>
													 
												</row> 
												<row><entry><symbol>TimeSpan.ReadMinutesPart</symbol></entry><entry><symbol>DAE_TSReadMinutesPart</symbol></entry><entry><symbol>MSSQLTimeSpanReadMinutesPart</symbol></entry>
													 
												</row> 
												<row><entry><symbol>TimeSpan.ReadSecondsPart</symbol></entry><entry><symbol>DAE_TSReadSecondsPart</symbol></entry><entry><symbol>MSSQLTimeSpanReadSecondsPart</symbol></entry>
													 
												</row> 
												<row><entry><symbol>TimeSpan.ReadMillisecondsPart</symbol></entry><entry><symbol>DAE_TSReadMillisecondsPart</symbol></entry><entry><symbol>MSSQLTimeSpanReadMillisecondsPart</symbol></entry>
													 
												</row> 
												<row><entry><symbol>TimeSpan.WriteDaysPart</symbol></entry><entry><symbol>DAE_TSWriteDaysPart</symbol></entry><entry><symbol>MSSQLTimeSpanWriteDaysPart</symbol></entry>
													 
												</row> 
												<row><entry><symbol>TimeSpan.WriteHoursPart</symbol></entry><entry><symbol>DAE_TSWriteHoursPart</symbol></entry><entry><symbol>MSSQLTimeSpanWriteHoursPart</symbol></entry>
													 
												</row> 
												<row><entry><symbol>TimeSpan.WriteMinutesPart</symbol></entry><entry><symbol>DAE_TSWriteMinutesPart</symbol></entry><entry><symbol>MSSQLTimeSpanWriteMinutesPart</symbol></entry>
													 
												</row> 
												<row><entry><symbol>TimeSpan.WriteSecondsPart</symbol></entry><entry><symbol>DAE_TSWriteSecondsPart</symbol></entry><entry><symbol>MSSQLTimeSpanWriteSecondsPart</symbol></entry>
													 
												</row> 
												<row><entry><symbol>TimeSpan.WriteMillisecondsPart</symbol></entry><entry><symbol>DAE_TSWriteMillisecondsPart</symbol></entry><entry><symbol>MSSQLTimeSpanWriteMillisecondsPart</symbol></entry>
													 
												</row> 
												<row><entry><symbol>AddYears</symbol></entry><entry><symbol>DAE_AddYears</symbol></entry><entry><symbol>MSSQLAddYears</symbol></entry>
													 
												</row> 
												<row><entry><symbol>AddMonths</symbol></entry><entry><symbol>DAE_AddMonths</symbol></entry><entry><symbol>MSSQLAddMonths</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DayOfWeek</symbol></entry><entry><symbol>DAE_DayOfWeek</symbol></entry><entry><symbol>MSSQLDayOfWeek</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DayOfYear</symbol></entry><entry><symbol>DAE_DayOfYear</symbol></entry><entry><symbol>MSSQLDayOfYear</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime.ReadHoursPart</symbol></entry><entry><symbol>DAE_DTReadHoursPart</symbol></entry><entry><symbol>MSSQLDateTimeReadHoursPart</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime.ReadMinutesPart</symbol></entry><entry><symbol>DAE_DTReadMinutesPart</symbol></entry><entry><symbol>MSSQLDateTimeReadMinutesPart</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime.ReadSecondsPart</symbol></entry><entry><symbol>DAE_DTReadSecondsPart</symbol></entry><entry><symbol>MSSQLDateTimeReadSecondsPart</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime.ReadMillisecondsPart</symbol></entry><entry><symbol>DAE_DTReadMillisecondsPart</symbol></entry><entry><symbol>MSSQLDateTimeReadMillisecondsPart</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime.WriteYearsPart</symbol></entry><entry><symbol>DAE_DTWriteYearsPart</symbol></entry><entry><symbol>MSSQLDateTimeWriteYearsPart</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime.WriteMonthsPart</symbol></entry><entry><symbol>DAE_DTWriteMonthsPart</symbol></entry><entry><symbol>MSSQLDateTimeWriteMonthsPart</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime.WriteDaysPart</symbol></entry><entry><symbol>DAE_DTWriteDaysPart</symbol></entry><entry><symbol>MSSQLDateTimeWriteDaysPart</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime.WriteHoursPart</symbol></entry><entry><symbol>DAE_DTWriteHoursPart</symbol></entry><entry><symbol>MSSQLDateTimeWriteHoursPart</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime.WriteMinutesPart</symbol></entry><entry><symbol>DAE_DTWriteMinutesPart</symbol></entry><entry><symbol>MSSQLDateTimeWriteMinutesPart</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime.WriteSecondsPart</symbol></entry><entry><symbol>DAE_DTWriteSecondsPart</symbol></entry><entry><symbol>MSSQLDateTimeWriteSecondsPart</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime.WriteMillisecondsPart</symbol></entry><entry><symbol>DAE_DTWriteMillisecondsPart</symbol></entry><entry><symbol>MSSQLDateTimeWriteMillisecondsPart</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DatePart</symbol></entry><entry><symbol>DAE_DTDatePart</symbol></entry><entry><symbol>MSSQLDateTimeDatePart</symbol></entry>
													 
												</row> 
												<row><entry><symbol>TimePart</symbol></entry><entry><symbol>DAE_DTTimePart</symbol></entry><entry><symbol>MSSQLDateTimeTimePart</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime</symbol>, all
														  overloads</entry><entry><symbol>DAE_DTDateTimeSelector</symbol></entry><entry><symbol>MSSQLDateTimeSelector</symbol></entry>
													 
												</row></tbody> 
									 </tgroup> 
								</informaltable></para> 
						  <para>Translation classes beginning with
								<symbol>MSSQL</symbol> are defined in the
								<symbol>Alphora.Dataphor.DAE.Device.MSSQL</symbol> namespace in the
								<symbol>AlphoraMSSQLDevice</symbol> assembly. The other translation classes are
								used from the basic SQL device.</para> 
					 </sect4> 
					 <sect4 id="D4LGExamples2"> 
						  <title><indexterm><primary>Examples</primary></indexterm><indexterm><primary>Microsoft
										  SQL Server
										  Device</primary><secondary>Examples</secondary></indexterm>Examples</title> 
						  <para>The following example illustrates the creation of an
								MSSQL device against the Pubs sample database. Be sure to set the
								<symbol>ServerName</symbol> and authentication information appropriately: 
								<programlisting>create device MSSQL
	reconciliation { mode = { command }, master = device }
	class "Alphora.Dataphor.DAE.Device.MSSQL.MSSQLDevice,AlphoraMSSQLDevice"
		attributes
		{
			"ConnectionClass" = 
				"Alphora.Dataphor.DAE.Connection.ADO.ADOConnection,
				Alphora.Dataphor.DAE.Connection.ADO",
			"ConnectionStringBuilderClass" = 
				"Alphora.Dataphor.DAE.Device.MSSQL.MSSQLOLEDBConnectionStringBuilder,
				AlphoraMSSQLDevice",
			"ServerName" = ".",
			"DatabaseName" = "pubs",
			"UseIntegratedSecurity" = "false"		
		};

CreateDeviceUser("Admin", Name("MSSQL"), "sa", "");
CreateDeviceUser("System", Name("MSSQL"), "sa", "");

Reconcile(Name("MSSQL"));

select authors;</programlisting> 
								<programlisting>au_id            au_lname     au_fname    phone        address              city           state zip   contract 
-----------          --------------      -----------        ------------ -------------------- -------------- ----- ----- -------- 
172-32-1176 White          Johnson      408 496-7223 10932 Bigge Rd.      Menlo Park     CA    94025 True     
213-46-8915 Green          Marjorie      415 986-7020 309 63rd St. #411    Oakland        CA    94618 True     
238-95-7766 Carson         Cheryl        415 548-7723 589 Darwin Ln.       Berkeley       CA    94705 True     
267-41-2394 O'Leary        Michael     408 286-2428 22 Cleveland Av. #14 San Jose       CA    95128 True     
274-80-9391 Straight        Dean         415 834-2919 5420 College Av.     Oakland        CA    94609 True     
341-22-1782 Smith           Meander    913 843-0462 10 Mississippi Dr.   Lawrence       KS    66044 False    
409-56-7008 Bennet         Abraham   415 658-9932 6223 Bateman St.     Berkeley       CA    94705 True     
427-17-2319 Dull              Ann           415 836-7128 3410 Blonde St.      Palo Alto      CA    94301 True     
472-27-2349 Gringlesby    Burt           707 938-6445 PO Box 792           Covelo         CA    95428 True     
486-29-1786 Locksley      Charlene    415 585-4620 18 Broadway Av.      San Francisco  CA    94130 True     
527-72-3246 Greene         Morningstar 615 297-2723 22 Graybar House Rd. Nashville      TN    37215 False    
648-92-1872 Blotchet-Halls Reginald 503 745-6402 55 Hillsdale Bl.     Corvallis      OR    97330 True     
672-71-3249 Yokomoto     Akiko        415 935-4228 3 Silver Ct.         Walnut Creek   CA    94595 True     
712-45-1867 del Castillo    Innes         615 996-8275 2286 Cram Pl. #86    Ann Arbor      MI    48105 True     
722-51-5454 DeFrance     Michel       219 547-9982 4 Balding Pl.        Gary           IN    46403 True     
724-08-9931 Stringer         Dirk           415 843-2991 5420 Telegraph Av.   Oakland        CA    94609 False    
724-80-9391 MacFeather  Stearns     415 354-7128 44 Upland Hts.       Oakland        CA    94612 True     
756-30-7391 Karsen          Livia          415 534-9219 5720 McAuley St.     Oakland        CA    94609 True     
807-91-6654 Panteley       Sylvia        301 946-8853 1956 Arlington Pl.   Rockville      MD    20853 True     
846-92-7186 Hunter          Sheryl        415 836-7128 3410 Blonde St.      Palo Alto      CA    94301 True     
893-72-1158 McBadden   Heather     707 448-4982 301 Putnam           Vacaville      CA    95688 False    
899-46-2035 Ringer          Anne         801 826-0752 67 Seventh Av.       Salt Lake City UT    84152 True     
998-72-3567 Ringer          Albert        801 826-0752 67 Seventh Av.       Salt Lake City UT    84152 True     </programlisting></para> 
						  <para>The following example illustrates the creation of an
								MSSQL device using a new database. Note the ommission of the default
								attributes: 
								<programlisting>create device MSSQL	reconciliation { mode = { command }, master = server }
	class "Alphora.Dataphor.DAE.Device.MSSQL.MSSQLDevice,AlphoraMSSQLDevice"
		attributes
		{
			"ServerName" = ".",
			"DatabaseName" = "SP",
			"IsCaseSensitive" = "true"
		};

CreateDeviceUser("Admin", Name("MSSQL"), "sa", "");
CreateDeviceUser("System", Name("MSSQL"), "sa", "");

SetDefaultDeviceName(Name("MSSQL"));

create domain SID { representation SID { Value : String } } 
	tags { Storage.Length = "2" };

alter device MSSQL
{
	create domain SID class 
		"Alphora.Dataphor.DAE.Device.MSSQL.MSSQLString,
		AlphoraMSSQLDevice",
	create operator SID(String) class 
		"Alphora.Dataphor.DAE.Device.SQL.SQLScalarSelector,
		Alphora.Dataphor.DAE.Device.SQL",
	create operator SID.ReadValue(SID) class 
		"Alphora.Dataphor.DAE.Device.SQL.SQLScalarReadAccessor,
		Alphora.Dataphor.DAE.Device.SQL",
	create operator SID.WriteValue(SID, String) class 
		"Alphora.Dataphor.DAE.Device.SQL.SQLScalarWriteAccessor,
		Alphora.Dataphor.DAE.Device.SQL",
	create operator iCompare(SID, SID) class 
		"Alphora.Dataphor.DAE.Device.SQL.SQLCompare,
		 Alphora.Dataphor.DAE.Device.SQL"
};

create domain PID { representation PID { Value : String } } 
   tags { Storage.Length = "2" };

alter device MSSQL
{
	create domain PID class 
		"Alphora.Dataphor.DAE.Device.MSSQL.MSSQLString,
		AlphoraMSSQLDevice",
	create operator PID(String) class 
		"Alphora.Dataphor.DAE.Device.SQL.SQLScalarSelector,
		Alphora.Dataphor.DAE.Device.SQL",
	create operator PID.ReadValue(PID) class 
		"Alphora.Dataphor.DAE.Device.SQL.SQLScalarReadAccessor,
		Alphora.Dataphor.DAE.Device.SQL",
	create operator PID.WriteValue(PID, String) class 
		"Alphora.Dataphor.DAE.Device.SQL.SQLScalarWriteAccessor,
		Alphora.Dataphor.DAE.Device.SQL",
	create operator iCompare(PID, PID) class 
		"Alphora.Dataphor.DAE.Device.SQL.SQLCompare,
		Alphora.Dataphor.DAE.Device.SQL"
};

create table S
{
	SID : SID,
	SName : String,
	Status : Integer,
	City : String,
	key { SID }
};

create table P
{
	PID : PID,
	PName : String,
	Color : String,
	Weight : Decimal,
	City : String,
	key { PID }
};

create table SP
{
	SID : SID,
	PID : PID,
	Qty : Integer,
	key { SID, PID },
	reference SP_S { SID } references S { SID },
	reference SP_P { PID } references P { PID }
};

// sample data
insert
	table
	{
		row { SID("S1") SID, "Smith" SName, 20 Status, "London" City },
		row { SID("S2") SID, "Jones" SName, 10 Status, "Paris" City },
		row { SID("S3") SID, "Blake" SName, 30 Status, "Paris" City },
		row { SID("S4") SID, "Clark" SName, 20 Status, "London" City },
		row { SID("S5") SID, "Adams" SName, 30 Status, "Athens" City }
	}
	into S;

insert
	table
	{
		row { PID("P1") PID, "Nut" PName, "Red" Color, 12d Weight, "London" City },
		row { PID("P2") PID, "Bolt" PName, "Green" Color, 17d Weight, "Paris" City },
		row { PID("P3") PID, "Screw" PName, "Blue" Color, 17d Weight, "Rome" City },
		row { PID("P4") PID, "Screw" PName, "Red" Color, 14d Weight, "London" City },
		row { PID("P5") PID, "Cam" PName, "Blue" Color, 12d Weight, "Paris" City },
		row { PID("P6") PID, "Cog" PName, "Red" Color, 19d Weight, "London" City }
	}
	into P;

insert
	table
	{
		row { SID("S1") SID, PID("P1") PID, 300 Qty },
		row { SID("S1") SID, PID("P2") PID, 200 Qty },
		row { SID("S1") SID, PID("P3") PID, 400 Qty },
		row { SID("S1") SID, PID("P4") PID, 200 Qty },
		row { SID("S1") SID, PID("P5") PID, 100 Qty },
		row { SID("S1") SID, PID("P6") PID, 100 Qty },
		row { SID("S2") SID, PID("P1") PID, 300 Qty },
		row { SID("S2") SID, PID("P2") PID, 400 Qty },
		row { SID("S3") SID, PID("P2") PID, 200 Qty },
		row { SID("S4") SID, PID("P2") PID, 200 Qty },
		row { SID("S4") SID, PID("P4") PID, 300 Qty },
		row { SID("S4") SID, PID("P5") PID, 400 Qty }
	}
	into SP;</programlisting></para> 
					 </sect4> 
				</sect3> 
				<sect3 id="D4LGOracleServerDevice"> 
					 <title><indexterm><primary>Oracle Server
									 Device</primary></indexterm><indexterm><primary>Using
									 Devices</primary><secondary>Oracle Server Device</secondary></indexterm>Oracle
						  Server Device</title> 
					 <para>Dataphor provides a device for communicating with Oracle
						  Server, versions 8i, and 9i.</para> 
					 <sect4 id="D4LGSettings1"> 
						  <title><indexterm><primary>Settings</primary></indexterm><indexterm><primary>Oracle
										  Server
										  Device</primary><secondary>Settings</secondary></indexterm>Settings</title> 
						  <para>The following table lists the settings available for
								the Oracle device. These settings are configured using the attributes of the
								class definition: 
								<informaltable> 
									 <tgroup cols="2"><thead> 
												<row><entry>Attribute
														  Name</entry><entry>Possible Values</entry><entry>Meaning</entry> 
												</row></thead><tbody> 
												<row><entry><symbol>ConnectionClass</symbol></entry><entry>
														  
														  <programlisting>&lt;assembly qualified class name&gt;</programlisting></entry><entry>Determines the class which will be used to
														  implement the connectivity layer for this device. See the connectivity section
														  for a discussion of the possible settings for this attribute. The default value
														  for this attribute is
														  <symbol>Alphora.Dataphor.DAE.Connection.ADO.ADOConnection,
														  Alphora.Dataphor.DAE.Connection.ADO</symbol>.</entry> 
												</row> 
												<row><entry><symbol>ConnectionStringBuilderClass</symbol></entry><entry>
														  
														  <programlisting>&lt;assembly qualified class name&gt;</programlisting></entry><entry>Determines the class which will be used to
														  construct connection strings for this device. See the connectivity section for
														  a discussion of the possible settings for this attribute. The default value for
														  this attribute is
														  <symbol>Alphora.Dataphor.DAE.Device.Oracle.OracleOLEDBConnectionStringBuilder,
														  AlphoraOracleDevice</symbol>.</entry> 
												</row> 
												<row><entry><symbol>ConnectionParameters</symbol></entry><entry>
														  
														  <programlisting>&lt;parameter&gt;{;&lt;parameter&gt;}

&lt;parameter&gt; ::=
	&lt;parameter name&gt;=&lt;parameter value&gt;</programlisting></entry><entry>Specifies additional connection parameters to
														  be used in building the connection string. For more information on how the
														  MSSQL device buils a connection string, refer to the connectivity
														  section.</entry> 
												</row> 
												<row><entry><symbol>ConnectionBufferSize</symbol></entry><entry>
														  
														  <programlisting>&lt;integer&gt;</programlisting></entry><entry>Specifies the number of rows to fetch at a time
														  from the target system. The default value for this attribute is 20. A value of
														  0 for this attribute indicates that the entire result set should be read
														  immediately, i.e., the result set should be
														  <emphasis>disconnected</emphasis>.</entry> 
												</row> 
												<row><entry><symbol>IsCaseSensitive</symbol></entry><entry>
														  
														  <programlisting>true | false</programlisting></entry><entry>Determines whether the target system is
														  case-sensitive for the purposes of identifier resolution and string comparison.
														  This setting determines whether the device will map the
														  <symbol>System.String</symbol> domain (case-sensitive) or the
														  <symbol>System.IString</symbol> domain (case-insensitive) by default. The
														  default value for this attribute is false.</entry> 
												</row> 
												<row><entry><symbol>HostName</symbol></entry><entry>
														  
														  <programlisting>&lt;host name&gt;</programlisting></entry><entry>Indicates the name of the Oracle instance to
														  use. This attribute has no default value.</entry> 
												</row> 
										  </tbody> 
									 </tgroup> 
								</informaltable></para> 
					 </sect4> 
					 <sect4 id="D4LGConnectivity2"> 
						  <title><indexterm><primary>Connectivity</primary></indexterm><indexterm><primary>Oracle
										  Server
										  Device</primary><secondary>Connectivity</secondary></indexterm>Connectivity</title>
						  
						  <para>Connectivity for the Oracle device begins by
								determining the connectivity implementation to be used. This is specified by
								the <symbol>ConnectionClass</symbol> attribute of the device. The following
								connection classes are available for use by this device: 
								<itemizedlist> 
									 <listitem> 
										  <para><symbol>ADOConnection</symbol></para> 
										  <para>This class is located in the
												<symbol>Alphora.Dataphor.DAE.Connection.ADO</symbol> namespace in the
												<symbol>Alphora.Dataphor.DAE.Connection.ADO</symbol> assembly. This
												connectivity implementation uses Microsoft Active Data Objects (ADO) to
												communicate with the specified server instance. This is the default
												connectivity implementation for the Oracle device. This is also the only fully
												supported connectivity implementation due to some issues with the various
												ADO.NET data providers.</para> 
									 </listitem> 
									 <listitem> 
										  <para><symbol>OLEDBConnection</symbol></para> 
										  <para>This class is located in the
												<symbol>Alphora.Dataphor.DAE.Connection</symbol> namespace in the
												<symbol>Alphora.Dataphor.DAE.Connection</symbol> assembly. This connectivity
												implementation uses the Microsoft ADO.NET OLEDB data provider to communicate
												with the specified server instance.</para> 
									 </listitem> 
									 <listitem> 
										  <para><symbol>OracleConnection</symbol></para> 
										  <para>This class is located in the
												<symbol>Alphora.Dataphor.DAE.Connection.Oracle</symbol> namespace in the
												<symbol>Alphora.Dataphor.DAE.Connection.Oracle</symbol> assembly. This
												connectivity implementation uses the Microsoft ADO.NET Oracle data provider to
												communicate with the specified server instance.</para> 
									 </listitem> 
									 <listitem> 
										  <para><symbol>ODBCConnection</symbol></para> 
										  <para>This class is located in the
												<symbol>Alphora.Dataphor.DAE.Connection.ODBC</symbol> namespace in the
												<symbol>Alphora.Dataphor.DAE.Connection.ODBC</symbol> assembly. This
												connectivity implementation uses the Microsoft ADO.NET ODBC data provider to
												communicate with the specified server instance.</para> 
									 </listitem> 
								</itemizedlist></para> 
						  <para>The next step in establishing connectivity for the
								Oracle device involves building the connection string to be used. The device
								creates an instance of the class specified by the
								<symbol>ConnectionStringBuilder</symbol> attribute. The following connection
								string builder classes are available for use by this device: 
								<itemizedlist> 
									 <listitem> 
										  <para><symbol>OracleOLEDBConnectionStringBuilder</symbol></para>
										  
										  <para>This class is defined in the
												<symbol>Alphora.Dataphor.DAE.Device.Oracle</symbol> namespace in the
												<symbol>AlphoraOracleDevice</symbol> assembly. This class is capable of
												building connection strings for the <symbol>ADOConnection</symbol> and
												<symbol>OLEDBConnection</symbol> connectivity implementations. This is the
												default connection string builder class for the Oracle device.</para> 
									 </listitem> 
								</itemizedlist></para> 
						  <para>Once the connection string builder class is created,
								the host name and authentication information are given as parameters to the
								connection string builder. The connection string builder then makes any
								necessary mappings between parameter names. If any parameters are specified in
								the <symbol>ConnectionParameters</symbol> attribute, they are included in the
								parameter set. If any parameter named in the
								<symbol>ConnectionParameters</symbol> is already in the parameter set, the
								parameter is replaced. In this way, the device can override specific connection
								parameters. Next, any connection parameters for the <symbol>DeviceUser</symbol>
								associated with this session are applied in the same way, with duplicates
								effectively replacing the value for the parameter. The full connection string
								is then assembled from the parameter list and passed to the connectivity
								implementation specified by the <symbol>ConnectionClass</symbol>
								attribute.</para> 
					 </sect4> 
					 <sect4 id="D4LGTranslation2"> 
						  <title><indexterm><primary>Translation</primary></indexterm><indexterm><primary>Oracle
										  Server
										  Device</primary><secondary>Translation</secondary></indexterm>Translation</title>
						  
						  <para>Value translation in the Oracle device uses the
								following domain mappings: 
								<informaltable> 
									 <tgroup cols="3"><thead> 
												<row><entry>D4 Data
														  Type</entry><entry>Oracle SQL Data Type</entry><entry>Translation Class</entry>
													 
												</row></thead><tbody> 
												<row><entry><symbol>System.Boolean</symbol></entry><entry>DECIMAL(1,
														  0)</entry><entry><symbol>OracleBoolean</symbol></entry> 
												</row> 
												<row><entry><symbol>System.Byte</symbol></entry><entry>DECIMAL(3,
														  0)</entry><entry><symbol>OracleByte</symbol></entry> 
												</row> 
												<row><entry><symbol>System.Short</symbol></entry><entry>DECIMAL(5,
														  0)</entry><entry><symbol>OracleShort</symbol></entry> 
												</row> 
												<row><entry><symbol>System.Integer</symbol></entry><entry>DECIMAL(10,
														  0)</entry><entry><symbol>OracleInteger</symbol></entry> 
												</row> 
												<row><entry><symbol>System.Long</symbol></entry><entry>DECIMAL(20,
														  0)</entry><entry><symbol>OracleLong</symbol></entry> 
												</row> 
												<row><entry><symbol>System.Decimal</symbol></entry><entry>DECIMAL(<symbol>P</symbol>,
														  <symbol>S</symbol>)</entry><entry><symbol>SQLDecimal</symbol></entry> 
												</row> 
												<row><entry><symbol>System.DateTime</symbol></entry><entry>DATETIME</entry><entry><symbol>SQLDateTime</symbol></entry>
													 
												</row> 
												<row><entry><symbol>System.TimeSpan</symbol></entry><entry>DECIMAL(20,
														  0)</entry><entry><symbol>OracleTimeSpan</symbol></entry> 
												</row> 
												<row><entry><symbol>System.Money</symbol></entry><entry>DECIMAL(28,
														  8)</entry><entry><symbol>SQLMoney</symbol></entry> 
												</row> 
												<row><entry><symbol>System.Guid</symbol></entry><entry>CHAR(24)</entry><entry><symbol>SQLGuid</symbol></entry>
													 
												</row> 
												<row><entry><symbol>System.String</symbol>,
														  <symbol>System.IString</symbol></entry><entry>VARCHAR(<symbol>L</symbol>) or
														  CLOB</entry><entry><symbol>SQLString</symbol></entry> 
												</row> 
												<row><entry><symbol>System.Image</symbol></entry><entry>BLOB</entry><entry><symbol>SQLImage</symbol></entry>
													 
												</row></tbody> 
									 </tgroup> 
								</informaltable></para> 
						  <para>Operator translation in the Oracle device uses the
								following operator mappings: 
								<informaltable> 
									 <tgroup cols="3"><thead> 
												<row><entry>D4
														  Operator</entry><entry>Oracle SQL Equivalent</entry><entry>Translation
														  Handler</entry> 
												</row></thead><tbody> 
												<row><entry><symbol>IsSpecial</symbol>, all
														  overloads</entry><entry><symbol>1 =
														  0</symbol></entry><entry><symbol>SQLScalarIsSpecialOperator</symbol></entry> 
												</row> 
												<row><entry><symbol>iPower</symbol>(<symbol>**</symbol>)</entry><entry><symbol>Power(X,
														  Y)</symbol></entry><entry><symbol>SQLPower</symbol></entry> 
												</row> 
												<row><entry><symbol>Abs</symbol>, all
														  overloads</entry><entry><symbol>Abs</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>Round</symbol></entry><entry><symbol>Round</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>Ceiling</symbol></entry><entry><symbol>Ceil</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>Floor</symbol></entry><entry><symbol>Floor</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>Ln</symbol></entry><entry><symbol>Log</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>Log10</symbol></entry><entry><symbol>Log10</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>Exp</symbol></entry><entry><symbol>Exp</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>Random</symbol></entry><entry><symbol>Rand</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>Frac</symbol></entry><entry><symbol>DAE_Frac</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>Log</symbol></entry><entry><symbol>DAE_LogB</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>Truncate</symbol></entry><entry><symbol>Trunc</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>Now</symbol></entry><entry><symbol>SysDate</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DaysInMonth</symbol></entry><entry><symbol>DAE_DaysInMonth</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>IsLeapYear</symbol></entry><entry><symbol>DAE_IsLeapYear</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DayOfMonth</symbol></entry><entry><symbol>DAE_DTReadDaysPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime(TimeSpan)</symbol></entry><entry><symbol>DAE_TSDateTime</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>TimeSpan(DateTime)</symbol></entry><entry><symbol>DAE_DTTimeSpan</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime.ReadMonthsPart</symbol></entry><entry><symbol>Month</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime.ReadDaysPart</symbol></entry><entry><symbol>Day</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime.ReadYearsPart</symbol></entry><entry><symbol>Year</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>Today</symbol></entry><entry><symbol>DAE_Today</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>TimeSpan.ReadDaysPart</symbol></entry><entry><symbol>DAE_TSReadDaysPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>TimeSpan.ReadHoursPart</symbol></entry><entry><symbol>DAE_TSReadHoursPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>TimeSpan.ReadMinutesPart</symbol></entry><entry><symbol>DAE_TSReadMinutesPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>TimeSpan.ReadSecondsPart</symbol></entry><entry><symbol>DAE_TSReadSecondsPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>TimeSpan.ReadMillisecondsPart</symbol></entry><entry><symbol>DAE_TSReadMillisecondsPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>TimeSpan.WriteDaysPart</symbol></entry><entry><symbol>DAE_TSWriteDaysPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>TimeSpan.WriteHoursPart</symbol></entry><entry><symbol>DAE_TSWriteHoursPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>TimeSpan.WriteMinutesPart</symbol></entry><entry><symbol>DAE_TSWriteMinutesPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>TimeSpan.WriteSecondsPart</symbol></entry><entry><symbol>DAE_TSWriteSecondsPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>TimeSpan.WriteMillisecondsPart</symbol></entry><entry><symbol>DAE_TSWriteMillisecondsPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>AddYears</symbol></entry><entry><symbol>DAE_AddYears</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>AddMonths</symbol></entry><entry><symbol>Add_Months</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DayOfWeek</symbol></entry><entry><symbol>DAE_DayOfWeek</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DayOfYear</symbol></entry><entry><symbol>DAE_DayOfYear</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime.ReadHoursPart</symbol></entry><entry><symbol>DAE_DTReadHoursPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime.ReadMinutesPart</symbol></entry><entry><symbol>DAE_DTReadMinutesPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime.ReadSecondsPart</symbol></entry><entry><symbol>DAE_DTReadSecondsPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime.ReadMillisecondsPart</symbol></entry><entry><symbol>DAE_DTReadMillisecondsPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime.WriteYearsPart</symbol></entry><entry><symbol>DAE_DTWriteYearsPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime.WriteMonthsPart</symbol></entry><entry><symbol>DAE_DTWriteMonthsPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime.WriteDaysPart</symbol></entry><entry><symbol>DAE_DTWriteDaysPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime.WriteHoursPart</symbol></entry><entry><symbol>DAE_DTWriteHoursPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime.WriteMinutesPart</symbol></entry><entry><symbol>DAE_DTWriteMinutesPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime.WriteSecondsPart</symbol></entry><entry><symbol>DAE_DTWriteSecondsPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime.WriteMillisecondsPart</symbol></entry><entry><symbol>DAE_DTWriteMillisecondsPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DatePart</symbol></entry><entry><symbol>Trunc</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>TimePart</symbol></entry><entry><symbol>DAE_Frac</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime</symbol>, 1
														  operand</entry><entry><symbol>DAE_DateTimeSelector1</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime</symbol>, 2
														  operands</entry><entry><symbol>DAE_DateTimeSelector2</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime</symbol>, 3
														  operands</entry><entry><symbol>DAE_DateTimeSelector3</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime</symbol>, 4
														  operands</entry><entry><symbol>DAE_DateTimeSelector4</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime</symbol>, 5
														  operands</entry><entry><symbol>DAE_DateTimeSelector5</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime</symbol>, 6
														  operands</entry><entry><symbol>DAE_DateTimeSelector6</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime</symbol>, 7
														  operands</entry><entry><symbol>DAE_DateTimeSelector7</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row></tbody> 
									 </tgroup> 
								</informaltable></para> 
						  <para>Translation classes beginning with
								<symbol>Oracle</symbol> are defined in the
								<symbol>Alphora.Dataphor.DAE.Device.Oracle</symbol> namespace in the
								<symbol>AlphoraOracleDevice</symbol> assembly. The other translation classes
								are used from the basic SQL device.</para> 
					 </sect4> 
					 <sect4 id="D4LGExamples3"> 
						  <title><indexterm><primary>Examples</primary></indexterm><indexterm><primary>Oracle
										  Server
										  Device</primary><secondary>Examples</secondary></indexterm>Examples</title> 
						  <para>The following example illustrates the creation of an
								Oracle device using a new database. Be sure to set the appropriate connection
								and authentication information: 
								<programlisting>create device Oracle	reconciliation { mode = { command }, master = server }
	class "Alphora.Dataphor.DAE.Device.Oracle.OracleDevice,AlphoraOracleDevice"
		attributes
		{
			"HostName" = "TEST9",
			"IsCaseSensitive" = "true"
		};

CreateDeviceUser("Admin", Name("Oracle"), "SYSTEM", "manager");
CreateDeviceUser("System", Name("Oracle"), "SYSTEM", "manager");

SetDefaultDeviceName(Name("Oracle"));

create domain SID { representation SID { Value : String } } 
  tags { Storage.Length = "2" };

alter device Oracle
{
	create domain SID class 
		"Alphora.Dataphor.DAE.Device.SQL.SQLString,
		Alphora.Dataphor.DAE.Device.SQL",
	create operator SID(String) class 
		"Alphora.Dataphor.DAE.Device.SQL.SQLScalarSelector,
		Alphora.Dataphor.DAE.Device.SQL",
	create operator SID.ReadValue(SID) class 
		"Alphora.Dataphor.DAE.Device.SQL.SQLScalarReadAccessor,
		Alphora.Dataphor.DAE.Device.SQL",
	create operator SID.WriteValue(SID, String) class 
		"Alphora.Dataphor.DAE.Device.SQL.SQLScalarWriteAccessor,
		Alphora.Dataphor.DAE.Device.SQL",
	create operator iCompare(SID, SID) class 
		"Alphora.Dataphor.DAE.Device.SQL.SQLCompare,
		Alphora.Dataphor.DAE.Device.SQL"
};

create domain PID { representation PID { Value : String } } 
	tags { Storage.Length = "2" };

alter device Oracle
{
	create domain PID class 
		"Alphora.Dataphor.DAE.Device.SQL.SQLString,
		Alphora.Dataphor.DAE.Device.SQL",
	create operator PID(String) class
		"Alphora.Dataphor.DAE.Device.SQL.SQLScalarSelector,
		Alphora.Dataphor.DAE.Device.SQL",
	create operator PID.ReadValue(PID) class
		"Alphora.Dataphor.DAE.Device.SQL.SQLScalarReadAccessor,
		Alphora.Dataphor.DAE.Device.SQL",
	create operator PID.WriteValue(PID, String) class 
		"Alphora.Dataphor.DAE.Device.SQL.SQLScalarWriteAccessor,
		Alphora.Dataphor.DAE.Device.SQL",
	create operator iCompare(PID, PID) class 
		"Alphora.Dataphor.DAE.Device.SQL.SQLCompare,
		Alphora.Dataphor.DAE.Device.SQL"
};

create table S
{
	SID : SID,
	SName : String,
	Status : Integer,
	City : String,
	key { SID }
};

create table P
{
	PID : PID,
	PName : String,
	Color : String,
	Weight : Decimal,
	City : String,
	key { PID }
};

create table SP
{
	SID : SID,
	PID : PID,
	Qty : Integer,
	key { SID, PID },
	reference SP_S { SID } references S { SID },
	reference SP_P { PID } references P { PID }
};

// sample data
insert
	table
	{
		row { SID("S1") SID, "Smith" SName, 20 Status, "London" City },
		row { SID("S2") SID, "Jones" SName, 10 Status, "Paris" City },
		row { SID("S3") SID, "Blake" SName, 30 Status, "Paris" City },
		row { SID("S4") SID, "Clark" SName, 20 Status, "London" City },
		row { SID("S5") SID, "Adams" SName, 30 Status, "Athens" City }
	}
	into S;

insert
	table
	{
		row { PID("P1") PID, "Nut" PName, "Red" Color, 12d Weight, "London" City },
		row { PID("P2") PID, "Bolt" PName, "Green" Color, 17d Weight, "Paris" City },
		row { PID("P3") PID, "Screw" PName, "Blue" Color, 17d Weight, "Rome" City },
		row { PID("P4") PID, "Screw" PName, "Red" Color, 14d Weight, "London" City },
		row { PID("P5") PID, "Cam" PName, "Blue" Color, 12d Weight, "Paris" City },
		row { PID("P6") PID, "Cog" PName, "Red" Color, 19d Weight, "London" City }
	}
	into P;

insert
	table
	{
		row { SID("S1") SID, PID("P1") PID, 300 Qty },
		row { SID("S1") SID, PID("P2") PID, 200 Qty },
		row { SID("S1") SID, PID("P3") PID, 400 Qty },
		row { SID("S1") SID, PID("P4") PID, 200 Qty },
		row { SID("S1") SID, PID("P5") PID, 100 Qty },
		row { SID("S1") SID, PID("P6") PID, 100 Qty },
		row { SID("S2") SID, PID("P1") PID, 300 Qty },
		row { SID("S2") SID, PID("P2") PID, 400 Qty },
		row { SID("S3") SID, PID("P2") PID, 200 Qty },
		row { SID("S4") SID, PID("P2") PID, 200 Qty },
		row { SID("S4") SID, PID("P4") PID, 300 Qty },
		row { SID("S4") SID, PID("P5") PID, 400 Qty }
	}
	into SP;</programlisting></para> 
					 </sect4> 
				</sect3> 
				<sect3 id="D4LGIBMDB2ServerDevice"> 
					 <title><indexterm><primary>IBM DB2 Server
									 Device</primary></indexterm><indexterm><primary>Using
									 Devices</primary><secondary>IBM DB2 Server Device</secondary></indexterm>IBM
						  DB2 Server Device</title> 
					 <para>Dataphor provides a device for communicating with IBM DB2
						  Universal Database Server Version 7.</para> 
					 <sect4 id="D4LGSettings2"> 
						  <title><indexterm><primary>Settings</primary></indexterm><indexterm><primary>IBM
										  DB2 Server
										  Device</primary><secondary>Settings</secondary></indexterm>Settings</title> 
						  <para>The following table lists the settings available for
								the DB2 device. These settings are configured using the attributes of the class
								definition: 
								<informaltable> 
									 <tgroup cols="2"><thead> 
												<row><entry>Attribute
														  Name</entry><entry>Possible Values</entry><entry>Meaning</entry> 
												</row></thead><tbody> 
												<row><entry><symbol>ConnectionClass</symbol></entry><entry>
														  
														  <programlisting>&lt;assembly qualified class name&gt;</programlisting></entry><entry>Determines the class which will be used to
														  implement the connectivity layer for this device. See the connectivity section
														  for a discussion of the possible settings for this attribute. The default value
														  for this attribute is
														  <symbol>Alphora.Dataphor.DAE.Connection.ODBC.ODBCConnection,
														  Alphora.Dataphor.DAE.Connection.ODBC</symbol>.</entry> 
												</row> 
												<row><entry><symbol>ConnectionStringBuilderClass</symbol></entry><entry>
														  
														  <programlisting>&lt;assembly qualified class name&gt;</programlisting></entry><entry>Determines the class which will be used to
														  construct connection strings for this device. See the connectivity section for
														  a discussion of the possible settings for this attribute. The default value for
														  this attribute is
														  <symbol>Alphora.Dataphor.DAE.Device.DB2.DB2ODBCConnectionStringBuilder,
														  AlphoraDB2Device</symbol>.</entry> 
												</row> 
												<row><entry><symbol>ConnectionParameters</symbol></entry><entry>
														  
														  <programlisting>&lt;parameter&gt;{;&lt;parameter&gt;}

&lt;parameter&gt; ::=
	&lt;parameter name&gt;=&lt;parameter value&gt;</programlisting></entry><entry>Specifies additional connection parameters to
														  be used in building the connection string. For more information on how the
														  MSSQL device buils a connection string, refer to the connectivity
														  section.</entry> 
												</row> 
												<row><entry><symbol>ConnectionBufferSize</symbol></entry><entry>
														  
														  <programlisting>&lt;integer&gt;</programlisting></entry><entry>Specifies the number of rows to fetch at a time
														  from the target system. The default value for this attribute is 20. A value of
														  0 for this attribute indicates that the entire result set should be read
														  immediately, i.e., the result set should be
														  <emphasis>disconnected</emphasis>.</entry> 
												</row> 
												<row><entry><symbol>IsCaseSensitive</symbol></entry><entry>
														  
														  <programlisting>true | false</programlisting></entry><entry>Determines whether the target system is
														  case-sensitive for the purposes of identifier resolution and string comparison.
														  This setting determines whether the device will map the
														  <symbol>System.String</symbol> domain (case-sensitive) or the
														  <symbol>System.IString</symbol> domain (case-insensitive) by default. The
														  default value for this attribute is false.</entry> 
												</row> 
												<row><entry><symbol>Data
														  Source</symbol></entry><entry> 
														  <programlisting>&lt;data source name&gt;</programlisting></entry><entry>Indicates the name of the DB2 instance to use.
														  This attribute has no default value.</entry> 
												</row> 
										  </tbody> 
									 </tgroup> 
								</informaltable></para> 
					 </sect4> 
					 <sect4 id="D4LGConnectivity3"> 
						  <title><indexterm><primary>Connectivity</primary></indexterm><indexterm><primary>IBM
										  DB2 Server
										  Device</primary><secondary>Connectivity</secondary></indexterm>Connectivity</title>
						  
						  <para>Connectivity for the DB2 device begins by determining
								the connectivity implementation to be used. This is specified by the
								<symbol>ConnectionClass</symbol> attribute of the device. The following
								connection classes are available for use by this device: 
								<itemizedlist> 
									 <listitem> 
										  <para><symbol>ADOConnection</symbol></para> 
										  <para>This class is located in the
												<symbol>Alphora.Dataphor.DAE.Connection.ADO</symbol> namespace in the
												<symbol>Alphora.Dataphor.DAE.Connection.ADO</symbol> assembly. This
												connectivity implementation uses Microsoft Active Data Objects (ADO) to
												communicate with the specified server instance.</para> 
									 </listitem> 
									 <listitem> 
										  <para><symbol>OLEDBConnection</symbol></para> 
										  <para>This class is located in the
												<symbol>Alphora.Dataphor.DAE.Connection</symbol> namespace in the
												<symbol>Alphora.Dataphor.DAE.Connection</symbol> assembly. This connectivity
												implementation uses the Microsoft ADO.NET OLEDB data provider to communicate
												with the specified server instance.</para> 
									 </listitem> 
									 <listitem> 
										  <para><symbol>ODBCConnection</symbol></para> 
										  <para>This class is located in the
												<symbol>Alphora.Dataphor.DAE.Connection.ODBC</symbol> namespace in the
												<symbol>Alphora.Dataphor.DAE.Connection.ODBC</symbol> assembly. This
												connectivity implementation uses the Microsoft ADO.NET ODBC data provider to
												communicate with the specified server instance. This is the default
												connectivity implementation for the DB2 device.</para> 
									 </listitem> 
								</itemizedlist></para> 
						  <para>The next step in establishing connectivity for the
								DB2 device involves building the connection string to be used. The device
								creates an instance of the class specified by the
								<symbol>ConnectionStringBuilder</symbol> attribute. The following connection
								string builder classes are available for use by this device: 
								<itemizedlist> 
									 <listitem> 
										  <para><symbol>DB2ODBCConnectionStringBuilder</symbol></para>
										  
										  <para>This class is defined in the
												<symbol>Alphora.Dataphor.DAE.Device.DB2</symbol> namespace in the
												<symbol>AlphoraDB2Device</symbol> assembly. This class is capable of building
												connection strings for the <symbol>ODBCConnection</symbol> connectivity
												implementation. This is the default connection string builder class for the DB2
												device.</para> 
									 </listitem> 
								</itemizedlist></para> 
						  <para>Once the connection string builder class is created,
								the data source name and authentication information are given as parameters to
								the connection string builder. The connection string builder then makes any
								necessary mappings between parameter names. If any parameters are specified in
								the <symbol>ConnectionParameters</symbol> attribute, they are included in the
								parameter set. If any parameter named in the
								<symbol>ConnectionParameters</symbol> is already in the parameter set, the
								parameter is replaced. In this way, the device can override specific connection
								parameters. Next, any connection parameters for the <symbol>DeviceUser</symbol>
								associated with this session are applied in the same way, with duplicates
								effectively replacing the value for the parameter. The full connection string
								is then assembled from the parameter list and passed to the connectivity
								implementation specified by the <symbol>ConnectionClass</symbol>
								attribute.</para> 
					 </sect4> 
					 <sect4 id="D4LGTranslation3"> 
						  <title><indexterm><primary>Translation</primary></indexterm><indexterm><primary>IBM
										  DB2 Server
										  Device</primary><secondary>Translation</secondary></indexterm>Translation</title>
						  
						  <para>Value translation in the DB2 device uses the
								following domain mappings: 
								<informaltable> 
									 <tgroup cols="3"><thead> 
												<row><entry>D4 Data Type</entry><entry>DB2
														  SQL Data Type</entry><entry>Translation Class</entry> 
												</row></thead><tbody> 
												<row><entry><symbol>System.Boolean</symbol></entry><entry>INTEGER</entry><entry><symbol>SQLBoolean</symbol></entry>
													 
												</row> 
												<row><entry><symbol>System.Byte</symbol></entry><entry>SMALLINT</entry><entry><symbol>SQLByte</symbol></entry>
													 
												</row> 
												<row><entry><symbol>System.Short</symbol></entry><entry>SMALLINT</entry><entry><symbol>SQLShort</symbol></entry>
													 
												</row> 
												<row><entry><symbol>System.Integer</symbol></entry><entry>INTEGER</entry><entry><symbol>SQLInteger</symbol></entry>
													 
												</row> 
												<row><entry><symbol>System.Long</symbol></entry><entry>BIGINT</entry><entry><symbol>SQLLong</symbol></entry>
													 
												</row> 
												<row><entry><symbol>System.Decimal</symbol></entry><entry>DECIMAL(<symbol>P</symbol>,
														  <symbol>S</symbol>)</entry><entry><symbol>SQLDecimal</symbol></entry> 
												</row> 
												<row><entry><symbol>System.DateTime</symbol></entry><entry>TIMESTAMP</entry><entry><symbol>SQLDateTime</symbol></entry>
													 
												</row> 
												<row><entry><symbol>System.TimeSpan</symbol></entry><entry>BIGINT</entry><entry><symbol>SQLTimeSpan</symbol></entry>
													 
												</row> 
												<row><entry><symbol>System.Money</symbol></entry><entry>DECIMAL(28,
														  8)</entry><entry><symbol>SQLMoney</symbol></entry> 
												</row> 
												<row><entry><symbol>System.Guid</symbol></entry><entry>CHAR(24)</entry><entry><symbol>SQLGuid</symbol></entry>
													 
												</row> 
												<row><entry><symbol>System.String</symbol>,
														  <symbol>System.IString</symbol></entry><entry>VARCHAR(<symbol>L</symbol>) or
														  CLOB</entry><entry><symbol>SQLString</symbol></entry> 
												</row> 
												<row><entry><symbol>System.Image</symbol></entry><entry>BLOB</entry><entry><symbol>SQLImage</symbol></entry>
													 
												</row></tbody> 
									 </tgroup> 
								</informaltable></para> 
						  <para>Operator translation in the DB2 device uses the
								following operator mappings: 
								<informaltable> 
									 <tgroup cols="3"><thead> 
												<row><entry>D4 Operator</entry><entry>DB2
														  SQL Equivalent</entry><entry>Translation Handler</entry> 
												</row></thead><tbody> 
												<row><entry><symbol>IsSpecial</symbol>, all
														  overloads</entry><entry><symbol>1 =
														  0</symbol></entry><entry><symbol>SQLScalarIsSpecialOperator</symbol></entry> 
												</row> 
												<row><entry><symbol>iPower</symbol>(<symbol>**</symbol>),
														  all overloads</entry><entry><symbol>Power(X,
														  Y)</symbol></entry><entry><symbol>SQLPower</symbol></entry> 
												</row> 
												<row><entry><symbol>Abs</symbol>, all
														  overloads</entry><entry><symbol>Abs</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>Round</symbol></entry><entry><symbol>Round</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>Ceiling</symbol></entry><entry><symbol>Ceil</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>Floor</symbol></entry><entry><symbol>Floor</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>Ln</symbol></entry><entry><symbol>Ln</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>Log10</symbol></entry><entry><symbol>Log10</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>Exp</symbol></entry><entry><symbol>Exp</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>Random</symbol></entry><entry><symbol>Rand</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>Frac</symbol></entry><entry><symbol>DAE_Frac</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>Log</symbol></entry><entry><symbol>LogB</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>Truncate</symbol></entry><entry><symbol>DAE_Trunc</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>Now</symbol></entry><entry><symbol>DAE_Now</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DaysInMonth</symbol></entry><entry><symbol>DAE_DaysInMonth</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>IsLeapYear</symbol></entry><entry><symbol>DAE_IsLeapYear</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DayOfMonth</symbol></entry><entry><symbol>DAE_DayOfMonth</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime(TimeSpan)</symbol></entry><entry><symbol>DAE_DateTime</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>TimeSpan(DateTime)</symbol></entry><entry><symbol>DAE_TimeSpan</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime.ReadMonthsPart</symbol></entry><entry><symbol>DAE_DTReadMonthsPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime.ReadDaysPart</symbol></entry><entry><symbol>DAE_DTReadDaysPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime.ReadYearsPart</symbol></entry><entry><symbol>DAE_DTReadYearsPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>Today</symbol></entry><entry><symbol>DAE_Today</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>TimeSpan.ReadDaysPart</symbol></entry><entry><symbol>DAE_TSReadDaysPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>TimeSpan.ReadHoursPart</symbol></entry><entry><symbol>DAE_TSReadHoursPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>TimeSpan.ReadMinutesPart</symbol></entry><entry><symbol>DAE_TSReadMinutesPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>TimeSpan.ReadSecondsPart</symbol></entry><entry><symbol>DAE_TSReadSecondsPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>TimeSpan.ReadMillisecondsPart</symbol></entry><entry><symbol>DAE_TSReadMillisecondsPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>TimeSpan.WriteDaysPart</symbol></entry><entry><symbol>DAE_TSWriteDaysPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>TimeSpan.WriteHoursPart</symbol></entry><entry><symbol>DAE_TSWriteHoursPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>TimeSpan.WriteMinutesPart</symbol></entry><entry><symbol>DAE_TSWriteMinutesPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>TimeSpan.WriteSecondsPart</symbol></entry><entry><symbol>DAE_TSWriteSecondsPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>TimeSpan.WriteMillisecondsPart</symbol></entry><entry><symbol>DAE_TSWriteMillisecondsPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>AddYears</symbol></entry><entry><symbol>DAE_AddYears</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>AddMonths</symbol></entry><entry><symbol>DAE_AddMonths</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DayOfWeek</symbol></entry><entry><symbol>DAE_DayOfWeek</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DayOfYear</symbol></entry><entry><symbol>DAE_DayOfYear</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime.ReadHoursPart</symbol></entry><entry><symbol>DAE_DTReadHoursPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime.ReadMinutesPart</symbol></entry><entry><symbol>DAE_DTReadMinutesPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime.ReadSecondsPart</symbol></entry><entry><symbol>DAE_DTReadSecondsPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime.ReadMillisecondsPart</symbol></entry><entry><symbol>DAE_DTReadMillisecondsPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime.WriteYearsPart</symbol></entry><entry><symbol>DAE_DTWriteYearsPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime.WriteMonthsPart</symbol></entry><entry><symbol>DAE_DTWriteMonthsPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime.WriteDaysPart</symbol></entry><entry><symbol>DAE_DTWriteDaysPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime.WriteHoursPart</symbol></entry><entry><symbol>DAE_DTWriteHoursPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime.WriteMinutesPart</symbol></entry><entry><symbol>DAE_DTWriteMinutesPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime.WriteSecondsPart</symbol></entry><entry><symbol>DAE_DTWriteSecondsPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime.WriteMillisecondsPart</symbol></entry><entry><symbol>DAE_DTWriteMillisecondsPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DatePart</symbol></entry><entry><symbol>DAE_DatePart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>TimePart</symbol></entry><entry><symbol>DAE_TimePart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime</symbol>, 1
														  operand</entry><entry><symbol>DAE_DateTimeSelector1</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime</symbol>, 2
														  operands</entry><entry><symbol>DAE_DateTimeSelector2</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime</symbol>, 3
														  operands</entry><entry><symbol>DAE_DateTimeSelector3</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime</symbol>, 4
														  operands</entry><entry><symbol>DAE_DateTimeSelector4</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime</symbol>, 5
														  operands</entry><entry><symbol>DAE_DateTimeSelector5</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime</symbol>, 6
														  operands</entry><entry><symbol>DAE_DateTimeSelector6</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>DateTime</symbol>, 7
														  operands</entry><entry><symbol>DAE_DateTimeSelector7</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row></tbody> 
									 </tgroup> 
								</informaltable></para> 
						  <para>Translation classes beginning with
								<symbol>DB2</symbol> are defined in the
								<symbol>Alphora.Dataphor.DAE.Device.DB2</symbol> namespace in the
								<symbol>AlphoraDB2Device</symbol> assembly. The other translation classes are
								used from the basic SQL device.</para> 
					 </sect4> 
					 <sect4 id="D4LGExamples4"> 
						  <title><indexterm><primary>Examples</primary></indexterm><indexterm><primary>IBM
										  DB2 Server
										  Device</primary><secondary>Examples</secondary></indexterm>Examples</title> 
						  <para>The following example illustrates the creation of a
								DB2 device using a new database. Be sure to set the appropriate connection and
								authentication information: 
								<programlisting>create device DB2 reconciliation { mode = { command }, master = server }
	class "Alphora.Dataphor.DAE.Device.DB2.DB2Device,AlphoraDB2Device"
		attributes
		{
			"DataSource" = "DB2TEST",
			"IsCaseSensitive" = "true"
		};

CreateDeviceUser("Admin", Name("DB2"), "DB2ADMIN", "DB2ADMIN");
CreateDeviceUser("System", Name("DB2"), "DB2ADMIN", "DB2ADMIN");

SetDefaultDeviceName(Name("DB2"));

create domain SID { representation SID { Value : String } }
	tags { Storage.Length = "2" };

alter device DB2
{
	create domain SID class
		"Alphora.Dataphor.DAE.Device.SQL.SQLString,
		Alphora.Dataphor.DAE.Device.SQL",
	create operator SID(String) class
		"Alphora.Dataphor.DAE.Device.SQL.SQLScalarSelector,
		Alphora.Dataphor.DAE.Device.SQL",
	create operator SID.ReadValue(SID) class
		"Alphora.Dataphor.DAE.Device.SQL.SQLScalarReadAccessor,
		Alphora.Dataphor.DAE.Device.SQL",
	create operator SID.WriteValue(SID, String) class
		"Alphora.Dataphor.DAE.Device.SQL.SQLScalarWriteAccessor,
		Alphora.Dataphor.DAE.Device.SQL",
	create operator iCompare(SID, SID) class
		"Alphora.Dataphor.DAE.Device.SQL.SQLCompare,
		Alphora.Dataphor.DAE.Device.SQL"
};

create domain PID { representation PID { Value : String } }
	tags { Storage.Length = "2" };

alter device DB2
{
	create domain PID class
		"Alphora.Dataphor.DAE.Device.SQL.SQLString,
		Alphora.Dataphor.DAE.Device.SQL",
	create operator PID(String) class
		"Alphora.Dataphor.DAE.Device.SQL.SQLScalarSelector,
		Alphora.Dataphor.DAE.Device.SQL",
	create operator PID.ReadValue(PID) class
		"Alphora.Dataphor.DAE.Device.SQL.SQLScalarReadAccessor,
		Alphora.Dataphor.DAE.Device.SQL",
	create operator PID.WriteValue(PID, String) class
		"Alphora.Dataphor.DAE.Device.SQL.SQLScalarWriteAccessor,
		Alphora.Dataphor.DAE.Device.SQL",
	create operator iCompare(PID, PID) class
		"Alphora.Dataphor.DAE.Device.SQL.SQLCompare,
		Alphora.Dataphor.DAE.Device.SQL"
};

create table S
{
	SID : SID,
	SName : String,
	Status : Integer,
	City : String,
	key { SID }
};

create table P
{
	PID : PID,
	PName : String,
	Color : String,
	Weight : Decimal,
	City : String,
	key { PID }
};

create table SP
{
	SID : SID,
	PID : PID,
	Qty : Integer,
	key { SID, PID },
	reference SP_S { SID } references S { SID },
	reference SP_P { PID } references P { PID }
};

// sample data
insert
	table
	{
		row { SID("S1") SID, "Smith" SName, 20 Status, "London" City },
		row { SID("S2") SID, "Jones" SName, 10 Status, "Paris" City },
		row { SID("S3") SID, "Blake" SName, 30 Status, "Paris" City },
		row { SID("S4") SID, "Clark" SName, 20 Status, "London" City },
		row { SID("S5") SID, "Adams" SName, 30 Status, "Athens" City }
	}
	into S;

insert
	table
	{
		row { PID("P1") PID, "Nut" PName, "Red" Color, 12d Weight, "London" City },
		row { PID("P2") PID, "Bolt" PName, "Green" Color, 17d Weight, "Paris" City },
		row { PID("P3") PID, "Screw" PName, "Blue" Color, 17d Weight, "Rome" City },
		row { PID("P4") PID, "Screw" PName, "Red" Color, 14d Weight, "London" City },
		row { PID("P5") PID, "Cam" PName, "Blue" Color, 12d Weight, "Paris" City },
		row { PID("P6") PID, "Cog" PName, "Red" Color, 19d Weight, "London" City }
	}
	into P;

insert
	table
	{
		row { SID("S1") SID, PID("P1") PID, 300 Qty },
		row { SID("S1") SID, PID("P2") PID, 200 Qty },
		row { SID("S1") SID, PID("P3") PID, 400 Qty },
		row { SID("S1") SID, PID("P4") PID, 200 Qty },
		row { SID("S1") SID, PID("P5") PID, 100 Qty },
		row { SID("S1") SID, PID("P6") PID, 100 Qty },
		row { SID("S2") SID, PID("P1") PID, 300 Qty },
		row { SID("S2") SID, PID("P2") PID, 400 Qty },
		row { SID("S3") SID, PID("P2") PID, 200 Qty },
		row { SID("S4") SID, PID("P2") PID, 200 Qty },
		row { SID("S4") SID, PID("P4") PID, 300 Qty },
		row { SID("S4") SID, PID("P5") PID, 400 Qty }
	}
	into SP;</programlisting></para> 
					 </sect4> 
				</sect3> 
				<sect3 id="D4LGRelexusLinterDevice"> 
					 <title><indexterm><primary>Relexus Linter
									 Device</primary></indexterm><indexterm><primary>Using
									 Devices</primary><secondary>Relexus Linter
									 Device</secondary></indexterm>Relexus Linter Device</title> 
					 <para>Dataphor provides a device for communicating with Relexus
						  Linter versions 5.9 and 6.0. The Relexus Linter DBMS is available in evaluation
						  form on the Dataphor product CD, and is an excellent choice for a fast,
						  lightweight full-featured DBMS, and tight integration with Dataphor.</para> 
					 <sect4 id="D4LGSettings3"> 
						  <title><indexterm><primary>Settings</primary></indexterm><indexterm><primary>Relexus
										  Linter
										  Device</primary><secondary>Settings</secondary></indexterm>Settings</title> 
						  <para>The following table lists the settings available for
								the Linter device. These settings are configured using the attributes of the
								class definition: 
								<informaltable> 
									 <tgroup cols="2"><thead> 
												<row><entry>Attribute
														  Name</entry><entry>Possible Values</entry><entry>Meaning</entry> 
												</row></thead><tbody> 
												<row><entry><symbol>ConnectionClass</symbol></entry><entry>
														  
														  <programlisting>&lt;assembly qualified class name&gt;</programlisting></entry><entry>Determines the class which will be used to
														  implement the connectivity layer for this device. See the connectivity section
														  for a discussion of the possible settings for this attribute. The default value
														  for this attribute is
														  <symbol>Alphora.Dataphor.DAE.Connection.ODBC.ODBCConnection,
														  Alphora.Dataphor.DAE.Connection.ODBC</symbol>.</entry> 
												</row> 
												<row><entry><symbol>ConnectionStringBuilderClass</symbol></entry><entry>
														  
														  <programlisting>&lt;assembly qualified class name&gt;</programlisting></entry><entry>Determines the class which will be used to
														  construct connection strings for this device. See the connectivity section for
														  a discussion of the possible settings for this attribute. The default value for
														  this attribute is
														  <symbol>Alphora.Dataphor.DAE.Device.Linter.LinterODBCConnectionStringBuilder,
														  AlphoraLinterDevice</symbol>.</entry> 
												</row> 
												<row><entry><symbol>ConnectionParameters</symbol></entry><entry>
														  
														  <programlisting>&lt;parameter&gt;{;&lt;parameter&gt;}

&lt;parameter&gt; ::=
	&lt;parameter name&gt;=&lt;parameter value&gt;</programlisting></entry><entry>Specifies additional connection parameters to
														  be used in building the connection string. For more information on how the
														  MSSQL device buils a connection string, refer to the connectivity
														  section.</entry> 
												</row> 
												<row><entry><symbol>ConnectionBufferSize</symbol></entry><entry>
														  
														  <programlisting>&lt;integer&gt;</programlisting></entry><entry>Specifies the number of rows to fetch at a time
														  from the target system. The default value for this attribute is 20. A value of
														  0 for this attribute indicates that the entire result set should be read
														  immediately, i.e., the result set should be
														  <emphasis>disconnected</emphasis>.</entry> 
												</row> 
												<row><entry><symbol>IsCaseSensitive</symbol></entry><entry>
														  
														  <programlisting>true | false</programlisting></entry><entry>Determines whether the target system is
														  case-sensitive for the purposes of identifier resolution and string comparison.
														  This setting determines whether the device will map the
														  <symbol>System.String</symbol> domain (case-sensitive) or the
														  <symbol>System.IString</symbol> domain (case-insensitive) by default. The
														  default value for this attribute is false.</entry> 
												</row> 
												<row><entry><symbol>Data
														  Source</symbol></entry><entry> 
														  <programlisting>&lt;data source name&gt;</programlisting></entry><entry>Indicates the name of the Linter instance to
														  use. This attribute has no default value.</entry> 
												</row> 
										  </tbody> 
									 </tgroup> 
								</informaltable></para> 
					 </sect4> 
					 <sect4 id="D4LGConnectivity4"> 
						  <title><indexterm><primary>Connectivity</primary></indexterm><indexterm><primary>Relexus
										  Linter
										  Device</primary><secondary>Connectivity</secondary></indexterm>Connectivity</title>
						  
						  <para>Connectivity for the Linter device begins by
								determining the connectivity implementation to be used. This is specified by
								the <symbol>ConnectionClass</symbol> attribute of the device. The following
								connection classes are available for use by this device: 
								<itemizedlist> 
									 <listitem> 
										  <para><symbol>ADOConnection</symbol></para> 
										  <para>This class is located in the
												<symbol>Alphora.Dataphor.DAE.Connection.ADO</symbol> namespace in the
												<symbol>Alphora.Dataphor.DAE.Connection.ADO</symbol> assembly. This
												connectivity implementation uses Microsoft Active Data Objects (ADO) to
												communicate with the specified server instance.</para> 
									 </listitem> 
									 <listitem> 
										  <para><symbol>OLEDBConnection</symbol></para> 
										  <para>This class is located in the
												<symbol>Alphora.Dataphor.DAE.Connection</symbol> namespace in the
												<symbol>Alphora.Dataphor.DAE.Connection</symbol> assembly. This connectivity
												implementation uses the Microsoft ADO.NET OLEDB data provider to communicate
												with the specified server instance.</para> 
									 </listitem> 
									 <listitem> 
										  <para><symbol>ODBCConnection</symbol></para> 
										  <para>This class is located in the
												<symbol>Alphora.Dataphor.DAE.Connection.ODBC</symbol> namespace in the
												<symbol>Alphora.Dataphor.DAE.Connection.ODBC</symbol> assembly. This
												connectivity implementation uses the Microsoft ADO.NET ODBC data provider to
												communicate with the specified server instance. This is the default
												connectivity implementation for the Linter device.</para> 
									 </listitem> 
								</itemizedlist></para> 
						  <para>The next step in establishing connectivity for the
								Linter device involves building the connection string to be used. The device
								creates an instance of the class specified by the
								<symbol>ConnectionStringBuilder</symbol> attribute. The following connection
								string builder classes are available for use by this device: 
								<itemizedlist> 
									 <listitem> 
										  <para><symbol>LinterODBCConnectionStringBuilder</symbol></para>
										  
										  <para>This class is defined in the
												<symbol>Alphora.Dataphor.DAE.Device.Linter</symbol> namespace in the
												<symbol>AlphoraLinterDevice</symbol> assembly. This class is capable of
												building connection strings for the <symbol>ODBCConnection</symbol>
												connectivity implementation. This is the default connection string builder
												class for the Linter device.</para> 
									 </listitem> 
								</itemizedlist></para> 
						  <para>Once the connection string builder class is created,
								the data source name and authentication information are given as parameters to
								the connection string builder. The connection string builder then makes any
								necessary mappings between parameter names. If any parameters are specified in
								the <symbol>ConnectionParameters</symbol> attribute, they are included in the
								parameter set. If any parameter named in the
								<symbol>ConnectionParameters</symbol> is already in the parameter set, the
								parameter is replaced. In this way, the device can override specific connection
								parameters. Next, any connection parameters for the <symbol>DeviceUser</symbol>
								associated with this session are applied in the same way, with duplicates
								effectively replacing the value for the parameter. The full connection string
								is then assembled from the parameter list and passed to the connectivity
								implementation specified by the <symbol>ConnectionClass</symbol>
								attribute.</para> 
					 </sect4> 
					 <sect4 id="D4LGTranslation4"> 
						  <title><indexterm><primary>Translation</primary></indexterm><indexterm><primary>Relexus
										  Linter
										  Device</primary><secondary>Translation</secondary></indexterm>Translation</title>
						  
						  <para>Value translation in the Linter device uses the
								following domain mappings: 
								<informaltable> 
									 <tgroup cols="3"><thead> 
												<row><entry>D4 Data
														  Type</entry><entry>Linter SQL Data Type</entry><entry>Translation Class</entry>
													 
												</row></thead><tbody> 
												<row><entry><symbol>System.Boolean</symbol></entry><entry>INTEGER</entry><entry><symbol>SQLBoolean</symbol></entry>
													 
												</row> 
												<row><entry><symbol>System.Byte</symbol></entry><entry>SMALLINT</entry><entry><symbol>SQLByte</symbol></entry>
													 
												</row> 
												<row><entry><symbol>System.Short</symbol></entry><entry>SMALLINT</entry><entry><symbol>SQLShort</symbol></entry>
													 
												</row> 
												<row><entry><symbol>System.Integer</symbol></entry><entry>INTEGER</entry><entry><symbol>SQLInteger</symbol></entry>
													 
												</row> 
												<row><entry><symbol>System.Long</symbol></entry><entry>BIGINT</entry><entry><symbol>SQLLong</symbol></entry>
													 
												</row> 
												<row><entry><symbol>System.Decimal</symbol></entry><entry>DECIMAL(<symbol>P</symbol>,
														  <symbol>S</symbol>)</entry><entry><symbol>SQLDecimal</symbol></entry> 
												</row> 
												<row><entry><symbol>System.DateTime</symbol></entry><entry>DATETIME</entry><entry><symbol>SQLDateTime</symbol></entry>
													 
												</row> 
												<row><entry><symbol>System.TimeSpan</symbol></entry><entry>BIGINT</entry><entry><symbol>SQLTimeSpan</symbol></entry>
													 
												</row> 
												<row><entry><symbol>System.Money</symbol></entry><entry>DECIMAL(28,
														  8)</entry><entry><symbol>SQLMoney</symbol></entry> 
												</row> 
												<row><entry><symbol>System.Guid</symbol></entry><entry>CHAR(24)</entry><entry><symbol>SQLGuid</symbol></entry>
													 
												</row> 
												<row><entry><symbol>System.String</symbol>,
														  <symbol>System.IString</symbol></entry><entry>VARCHAR(<symbol>L</symbol>) or
														  CLOB</entry><entry><symbol>SQLString</symbol></entry> 
												</row> 
												<row><entry><symbol>System.Image</symbol></entry><entry>BLOB</entry><entry><symbol>SQLImage</symbol></entry>
													 
												</row></tbody> 
									 </tgroup> 
								</informaltable></para> 
						  <para>Operator translation in the Linter device uses the
								following operator mappings: 
								<informaltable> 
									 <tgroup cols="3"><thead> 
												<row><entry>D4
														  Operator</entry><entry>Linter SQL Equivalent</entry><entry>Translation
														  Handler</entry> 
												</row></thead><tbody> 
												<row><entry><symbol>IsSpecial</symbol>, all
														  overloads</entry><entry><symbol>1 =
														  0</symbol></entry><entry><symbol>SQLScalarIsSpecialOperator</symbol></entry> 
												</row> 
												<row><entry><symbol>Abs</symbol>, all
														  overloads</entry><entry><symbol>Abs</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>Round</symbol></entry><entry><symbol>Round</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>Ceiling</symbol></entry><entry><symbol>Ceil</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>Floor</symbol></entry><entry><symbol>Floor</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>Ln</symbol></entry><entry><symbol>Ln</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>Log10</symbol></entry><entry><symbol>Log</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
												<row><entry><symbol>Truncate</symbol></entry><entry><symbol>Trunc</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
													 
												</row> 
										  </tbody> 
									 </tgroup> 
								</informaltable></para> 
						  <para>Translation classes beginning with
								<symbol>Linter</symbol> are defined in the
								<symbol>Alphora.Dataphor.DAE.Device.Linter</symbol> namespace in the
								<symbol>AlphoraLinterDevice</symbol> assembly. The other translation classes
								are used from the base SQL device.</para> 
					 </sect4> 
					 <sect4 id="D4LGExamples5"> 
						  <title><indexterm><primary>Examples</primary></indexterm><indexterm><primary>Relexus
										  Linter
										  Device</primary><secondary>Examples</secondary></indexterm>Examples</title> 
						  <para>The following example illustrates the creation of a
								Linter device using a new database. Be sure to set the appropriate connection
								and authentication information: 
								<programlisting>create device Linter reconciliation { mode = { command }, master = server }
	class "Alphora.Dataphor.DAE.Device.Linter.LinterDevice,AlphoraLinterDevice"
		attributes
		{
			"DataSource" = "Linter5.9",
			"IsCaseSensitive" = "true"
		};

CreateDeviceUser("Admin", Name("Linter"), "SYSTEM", "MANAGER");
CreateDeviceUser("System", Name("Linter"), "SYSTEM", "MANAGER");

SetDefaultDeviceName(Name("Linter"));

create domain SID { representation SID { Value : String } } tags { Storage.Length = "2" };

alter device Linter
{
	create domain SID class
		"Alphora.Dataphor.DAE.Device.SQL.SQLString,
		Alphora.Dataphor.DAE.Device.SQL",
	create operator SID(String) class
		"Alphora.Dataphor.DAE.Device.SQL.SQLScalarSelector,
		Alphora.Dataphor.DAE.Device.SQL",
	create operator SID.ReadValue(SID) class
		"Alphora.Dataphor.DAE.Device.SQL.SQLScalarReadAccessor,
		Alphora.Dataphor.DAE.Device.SQL",
	create operator SID.WriteValue(SID, String) class
		"Alphora.Dataphor.DAE.Device.SQL.SQLScalarWriteAccessor,
		Alphora.Dataphor.DAE.Device.SQL",
	create operator iCompare(SID, SID) class
		"Alphora.Dataphor.DAE.Device.SQL.SQLCompare,
		Alphora.Dataphor.DAE.Device.SQL"
};

create domain PID { representation PID { Value : String } } tags { Storage.Length = "2" };

alter device Linter
{
	create domain PID class
		"Alphora.Dataphor.DAE.Device.SQL.SQLString,
		Alphora.Dataphor.DAE.Device.SQL",
	create operator PID(String) class
		"Alphora.Dataphor.DAE.Device.SQL.SQLScalarSelector,
		Alphora.Dataphor.DAE.Device.SQL",
	create operator PID.ReadValue(PID) class
		"Alphora.Dataphor.DAE.Device.SQL.SQLScalarReadAccessor,
		Alphora.Dataphor.DAE.Device.SQL",
	create operator PID.WriteValue(PID, String) class
		"Alphora.Dataphor.DAE.Device.SQL.SQLScalarWriteAccessor,
		Alphora.Dataphor.DAE.Device.SQL",
	create operator iCompare(PID, PID) class
		"Alphora.Dataphor.DAE.Device.SQL.SQLCompare,
		Alphora.Dataphor.DAE.Device.SQL"
};

create table S
{
	SID : SID,
	SName : String,
	Status : Integer,
	City : String,
	key { SID }
};

create table P
{
	PID : PID,
	PName : String,
	Color : String,
	Weight : Decimal,
	City : String,
	key { PID }
};

create table SP
{
	SID : SID,
	PID : PID,
	Qty : Integer,
	key { SID, PID },
	reference SP_S { SID } references S { SID },
	reference SP_P { PID } references P { PID }
};

// sample data
insert
	table
	{
		row { SID("S1") SID, "Smith" SName, 20 Status, "London" City },
		row { SID("S2") SID, "Jones" SName, 10 Status, "Paris" City },
		row { SID("S3") SID, "Blake" SName, 30 Status, "Paris" City },
		row { SID("S4") SID, "Clark" SName, 20 Status, "London" City },
		row { SID("S5") SID, "Adams" SName, 30 Status, "Athens" City }
	}
	into S;

insert
	table
	{
		row { PID("P1") PID, "Nut" PName, "Red" Color, 12d Weight, "London" City },
		row { PID("P2") PID, "Bolt" PName, "Green" Color, 17d Weight, "Paris" City },
		row { PID("P3") PID, "Screw" PName, "Blue" Color, 17d Weight, "Rome" City },
		row { PID("P4") PID, "Screw" PName, "Red" Color, 14d Weight, "London" City },
		row { PID("P5") PID, "Cam" PName, "Blue" Color, 12d Weight, "Paris" City },
		row { PID("P6") PID, "Cog" PName, "Red" Color, 19d Weight, "London" City }
	}
	into P;

insert
	table
	{
		row { SID("S1") SID, PID("P1") PID, 300 Qty },
		row { SID("S1") SID, PID("P2") PID, 200 Qty },
		row { SID("S1") SID, PID("P3") PID, 400 Qty },
		row { SID("S1") SID, PID("P4") PID, 200 Qty },
		row { SID("S1") SID, PID("P5") PID, 100 Qty },
		row { SID("S1") SID, PID("P6") PID, 100 Qty },
		row { SID("S2") SID, PID("P1") PID, 300 Qty },
		row { SID("S2") SID, PID("P2") PID, 400 Qty },
		row { SID("S3") SID, PID("P2") PID, 200 Qty },
		row { SID("S4") SID, PID("P2") PID, 200 Qty },
		row { SID("S4") SID, PID("P4") PID, 300 Qty },
		row { SID("S4") SID, PID("P5") PID, 400 Qty }
	}
	into SP;</programlisting></para> 
					 </sect4> 
				</sect3> 
		  </sect2> 
		  <sect2 id="D4LGUsingEventHandlers"> 
				<title><indexterm><primary>Using Event
								Handlers</primary></indexterm><indexterm><primary>Programming
								Topics</primary><secondary>Using Event Handlers</secondary></indexterm>Using
					 Event Handlers</title> 
				<para>Event handlers allow operators in the DAE to be executed in
					 response to certain events. For a complete description of event handlers, refer
					 to the Event Handlers section of Catalog Elements. The following example
					 illustrates the use of event handlers in D4: 
					 <programlisting>EnsureGenerators();

create table Test
{
	ID : Integer { default GetNextGenerator("Test_ID") }, 
	Name : String, 
	key { ID } 
};

create domain Operation 
{ 
	representation Operation { Value : String }, 
	constraint OperationValues value.Value in {"Insert", "Update", "Delete"} 
};

create table AuditTest
{
	ID : Integer { default GetNextGenerator("AuditTest_ID") }, 
	Operation : Operation, 
	OperationTime : DateTime, 
	Test_ID : Integer, 
	Test_Name : String, 
	key { ID } 
};

create operator Test_Insert(ARow : row { ID : Integer, Name : String })
begin
	insert 
		table 
		{ 
			row 
			{ 
				Operation("Insert") Operation, 
				Now() OperationTime, 
				(ID from ARow) Test_ID, 
				(Name from ARow) Test_Name 
			} 
		}
		into AuditTest;
end;

create operator Test_Update
	(
		AOldRow : row { ID : Integer, Name : String }, 
		ANewRow : row { ID : Integer, Name : String }
	)
begin
	insert 
		table 
		{ 
			row 
			{ 
				Operation("Update") Operation, 
				Now() OperationTime, 
				(ID from ANewRow) Test_ID,
				(Name from ANewRow) Test_Name
			}
		}
		into AuditTest;
end;

create operator Test_Delete(ARow : row { ID : Integer, Name : String })
begin
	insert 
		table 
		{ 
			row 
			{ 
				Operation("Delete") Operation, 
				Now() OperationTime, 
				(ID from ARow) Test_ID, 
				(Name from ARow) Test_Name 
			} 
		}
		into AuditTest;
end;

attach operator 
	Test_Insert(row { ID : Integer, Name : String })
	to Test on { after insert };

attach operator 
	Test_Update
	(
		row { ID : Integer, Name : String },
		row { ID : Integer, Name : String }
	)
	to Test on { after update };

attach operator 
	Test_Delete(row { ID : Integer, Name : String })
	to Test on { after delete };

insert table { row { "Test" Name } } into Test;

if not(exists(AuditTest where Test_Name = "Test")) then
	raise Error("Insert Handler failed");

update Test set { Name := "TestHandler" };

if not(exists(AuditTest where Test_Name = "TestHandler")) then
	raise Error("Update Handler failed");

delete Test;

if not
(
	exists
	(
		AuditTest where Test_Name = "TestHandler" and 
		Operation = Operation("Delete")
	)
) then
	raise Error("Delete Handler failed");</programlisting></para> 
		  </sect2> 
		  <sect2 id="D4LGDynamicExecution"> 
				<title><indexterm><primary>Dynamic
								Execution</primary></indexterm><indexterm><primary>Programming
								Topics</primary><secondary>Dynamic Execution</secondary></indexterm>Dynamic
					 Execution</title> 
				<para>The DAE has system provided operators which allow for the
					 dynamic execution of D4 statements. The <symbol>Execute</symbol> operator
					 allows a given statement to be executed, while the <symbol>Open</symbol>
					 operator allows a dynamic cursor to be declared and opened. The following
					 example illustrates the use of these operators: 
					 <programlisting>create table Data { ID : Integer, key { ID } };

begin
	var LData : Integer := 10;
	Execute("insert table { row { " + LData.ToString() + " ID } } into Data;");
end;

select Data;

begin
	var LSum : Integer := 0;
	var LCursor : cursor(table { ID : Integer }) := 
		Open("Data") as cursor(table { ID : Integer });
	try
		while LCursor.Next() do
			LSum := LSum + ID from LCursor.Select();
	finally
		LCursor.Close();
	end;
end;</programlisting></para> 
		  </sect2> 
	 </sect1> 
	 <sect1 id="D4LGComparisonWithSQL"> 
		  <title><indexterm><primary>Comparison With
						  SQL</primary></indexterm><indexterm><primary>Programming
						  Topics</primary><secondary>Comparison With
						  SQL</secondary></indexterm>Comparison With SQL</title> 
		  <para>This section provides a comparison between the D4 and SQL
				languages. For users familiar with SQL, this section provides a quick-start to
				D4, as it explains how the constructs of SQL are expressed in D4. In addition,
				this section highlights many of the important features of the D4 language which
				are absent from or poorly implemented in SQL. This section has the following
				basic outline: 
				<itemizedlist> 
					 <listitem> 
						  <para>Introduction</para> 
						  <para>This section provides a brief overview of the two
								languages and provides a high-level comparison.</para> 
					 </listitem> 
					 <listitem> 
						  <para>Common SQL</para> 
						  <para>This section introduces a hypothetical SQL dialect
								called Common SQL. This language will provide a concrete syntax that can be
								used to demonstrate and explain the differences between SQL and D4.</para> 
					 </listitem> 
					 <listitem> 
						  <para>Vendor Dialects</para> 
						  <para>This section introduces several of the more popular
								dialects of SQL, and highlights the peculariaties of each.</para> 
					 </listitem> 
					 <listitem> 
						  <para>Mapping an SQL Query Into D4</para> 
						  <para>This section describes how each component of an SQL
								query can be mapped into D4 operators.</para> 
					 </listitem> 
					 <listitem> 
						  <para>Data Management Differences</para> 
						  <para>This section describes some of the fundamental
								differences between the way the two languages deal with data.</para> 
					 </listitem> 
				</itemizedlist></para> 
		  <para>Note: This section is NOT for users who are not familiar with
				SQL. If the reader does not already know SQL fairly well, he or she would do
				better not to read this section, as it will only lead to confusion.</para> 
		  <sect2 id="D4LGIntroduction1"> 
				<title><indexterm><primary>Introduction</primary></indexterm><indexterm><primary>Comparison
								With
								SQL</primary><secondary>Introduction</secondary></indexterm>Introduction</title>
				
				<para>SQL was first developed as a prototype interface for use with
					 the System R project from IBM. As such, it was never intended to be a
					 production language for use in real applications. It was designed to be
					 <emphasis>some</emphasis> interface for a relational prototype that would serve
					 to convince the world that relational database management was a viable
					 technology [6].</para> 
				<para>D4, on the other hand, was built from the very beginning as a
					 solution to everyday data management problems faced by application developers.
					 It is especially significant that the designers of D4 have extensive
					 backgrounds in database application development using SQL-based DBMSs. The
					 entire Dataphor product evolved from a set of in-house software development
					 tools used to develop commercial applications. The logical model for the D4
					 language is based on The Third Manifesto, by C. J. Date and Hugh Darwen. The
					 syntax of D4 is based largely on Pascal and Tutorial D, a hypothetical syntax
					 used in The Third Manifesto as a vehicle for describing the concepts. D4 is an
					 'Industrial D' as described in The Third Manifesto.</para> 
				<para>In addition, SQL was designed as a 'database sublanguage.' It
					 was intended to be used from 3GL programming environments as a means of
					 retrieving and manipulating data in the database. As such, it had no facilities
					 for imperative programming. This implies that application development is done
					 in one language, while data manipulation is done in another. This disparity of
					 language environments is called <emphasis>impedance mismatch</emphasis>.</para>
				
				<para>D4 is really just an imperative programming language where
					 one of the types of data that can be described is relations. As a result,
					 applications can be developed entirely in D4, with no resulting impedance
					 mismatch.</para> 
				<para>The following table briefly lists some of the ways in which
					 D4 differs from SQL (the standard as well as the major implementations of that
					 standard):</para> 
				<para> 
					 <informaltable> 
						  <tgroup cols="2">
								<colspec colwidth="*" colname="col1" colnum="1"/>
								<colspec colwidth="*" colname="col2" colnum="2"/> 
								<thead> 
									 <row> 
										  <entry colname="col1"> 
												<para>D4</para> </entry> 
										  <entry colname="col2"> 
												<para>SQL</para> </entry> 
									 </row> 
								</thead> 
								<tbody> 
									 <row> 
										  <entry colname="col1"> 
												<para>Uses the relational algebra</para>
												</entry> 
										  <entry colname="col2"> 
												<para>Mixed calculus and algebra</para>
												</entry> 
									 </row> 
									 <row> 
										  <entry colname="col1"> 
												<para>Tables are relation variables</para>
												</entry> 
										  <entry colname="col2"> 
												<para>Tables are partly implemented 3vl
													 deviants</para> </entry> 
									 </row> 
									 <row> 
										  <entry colname="col1"> 
												<para>Highly orthogonal (easy to learn and
													 use)</para> </entry> 
										  <entry colname="col2"> 
												<para>Complex rules and exceptions</para>
												</entry> 
									 </row> 
									 <row> 
										  <entry colname="col1"> 
												<para>Intrinsic imperative language</para>
												</entry> 
										  <entry colname="col2"> 
												<para>Proprietary extensions to support
													 imperative programming</para> </entry> 
									 </row> 
								</tbody> 
						  </tgroup> 
					 </informaltable></para> 
				<para>In addition to the syntactic differences between the two
					 languages, there are numerous features of D4 that are not supported by, or
					 poorly implemented in SQL such as user-defined types, user-defined functions,
					 user-defined aggregate functions, exception-handling, user-defined relational
					 operators, updatable views, support for quota queries, etc.,. There are also
					 numerous drawbacks to the SQL language which D4 does not suffer from, mainly
					 that SQL is not a relational language [6]. There are numerous criticisms of SQL
					 in the literature, and we will not endeavour to repeat them here, except as it
					 pertains to the functionality being described. The interested reader is
					 referred to the Recommended Reading section of this manual.</para> 
		  </sect2> 
		  <sect2 id="D4LGCommonSQL"> 
				<title><indexterm><primary>Common
								SQL</primary></indexterm><indexterm><primary>Comparison With
								SQL</primary><secondary>Common SQL</secondary></indexterm>Common SQL</title> 
				<para>In order to illustrate the differences between SQL and D4, we
					 must agree on a common dialect of SQL to perform the comparison. Rather than
					 using the various 'standards' that have been proposed, we chose to use the
					 'lowest common denominator', or that portion of the language that all the
					 various dialects support in some form or another. We call this hypothetical
					 language Common SQL. Note that Common SQL does not exist, even in principle, as
					 even when two dialects support a common feature set, they may have different
					 syntax for the same feature. As such, we make no claim that this dialect is
					 standard in any way, or that it could be used to communicate with any actual
					 DBMS. It is merely a pedagogical tool for use in demonstrating the differences
					 between the de-facto standard SQL and D4.</para> 
				<para>Firstly, we make explicit the fact that we will only be
					 discussing the data manipulation language statements of SQL. In practice, the
					 DAE must also communicate using data definition language (and the syntactic
					 variations here are even more profound than for DML), but here we will only
					 concern ourselves with the data manipulation aspects of each language.</para> 
				<para>Secondly, we assume that we will only be discussing single
					 statements. The rules for grouping statements into execution blocks also differ
					 for each dialect and DBMS, and so we will only be concerned with the effects of
					 a single data manipulation language statement.</para> 
				<para>In order to describe the Common SQL language, we will use a
					 modified version of Extended Backus-Naur Form (EBNF) notation. For a complete
					 description of this notation, refer to the Syntactic Conventions section in the
					 Introduction to this guide.</para> 
				<para>Here then is the syntax for the data manipulation language
					 statement in Common SQL: 
					 <programlisting>&lt;dml statement&gt; ::=
	&lt;select statement&gt; |
	&lt;insert statement&gt; |
	&lt;update statement&gt; |
	&lt;delete statement&gt;</programlisting></para> 
				<sect3 id="D4LGSelectStatement1"> 
					 <title><indexterm><primary>Select
									 Statement</primary></indexterm><indexterm><primary>Common
									 SQL</primary><secondary>Select Statement</secondary></indexterm>Select
						  Statement</title> 
					 <para>The bulk of our discussion will center around the select
						  statement, as the mapping for the modification statements is relatively
						  straightforward.</para> 
					 <para>The select statement in Common SQL has the following
						  syntax: 
						  <programlisting>&lt;select statement&gt; ::=
	&lt;query expression&gt;
	[&lt;order by clause&gt;]

&lt;query expression&gt; ::=
	&lt;select expression&gt; {&lt;table operator clause&gt;}

&lt;select expression&gt; ::=
	select (* | &lt;column expression commalist&gt;)
		&lt;from clause&gt;
		[&lt;where clause&gt;]
		[&lt;group by clause&gt;]
		[&lt;having clause&gt;]

&lt;column expression&gt; ::=
	&lt;expression&gt; [as &lt;column alias&gt;]

&lt;from clause&gt; ::=
	from &lt;table specifier&gt; [&lt;join clause list&gt;]

&lt;where clause&gt; ::=
	where &lt;conditional expression&gt;

&lt;group by clause&gt; ::=
	group by &lt;expression commalist&gt;

&lt;having clause&gt; ::=
	having &lt;conditional expression&gt;

&lt;table specifier&gt; ::=
	&lt;table identifier&gt; | "("&lt;query expression&gt;")" [as &lt;table alias&gt;]

&lt;join clause&gt; ::=
	[cross | inner | ((left | right) [outer])] join 
     &lt;table specifier&gt; [on &lt;conditional expression&gt;]

&lt;table operator clause&gt; ::=
	((union | intersect | except) [all]) &lt;select expression&gt;

&lt;order by clause&gt; ::=
	order by &lt;order column expression commalist&gt;

&lt;order column expression&gt; ::=
	&lt;column identifier&gt; [asc | desc]</programlisting></para> 
					 <para>The syntax is relatively straightforward, and most
						  dialects can be described with only slight modifications. This statement covers
						  all the major operations available in commercial SQL-based DBMSs today. Note
						  that we chose the ANSI standard version of the join clause, rather than the
						  <emphasis>table specifier commalist</emphasis> flavor common in many
						  implementations.</para> 
					 <sect4 id="D4LGQueryExpression"> 
						  <title><indexterm><primary>Query
										  Expression</primary></indexterm><indexterm><primary>Select
										  Statement</primary><secondary>Query Expression</secondary></indexterm>Query
								Expression</title> 
						  <para>The <emphasis>query expression</emphasis> production
								specifies a <emphasis>select expression</emphasis> followed by any number of
								<emphasis>table operator clause</emphasis> productions. These are the so-called
								<emphasis>union-compatible</emphasis> operators, in that both operands for each
								operator are required to have the same number of columns, and the same data
								types for each column, left-to-right.</para> 
					 </sect4> 
					 <sect4 id="D4LGSelectExpression"> 
						  <title><indexterm><primary>Select
										  Expression</primary></indexterm><indexterm><primary>Select
										  Statement</primary><secondary>Select Expression</secondary></indexterm>Select
								Expression</title> 
						  <para>The <emphasis>select expression</emphasis> production
								is the bulk of the SQL syntax. This is the familiar
								<symbol>select...from...where</symbol> construct. The <emphasis>column
								expression commalist</emphasis> specifies the columns to be preserved in the
								result set. The wildcard <symbol>*</symbol> indicates that all columns of the
								result should be preserved. The <emphasis>column expression</emphasis>
								production includes an optional as clause which indicates what the column
								should be named in the final result.</para> 
					 </sect4> 
					 <sect4 id="D4LGFromClause"> 
						  <title><indexterm><primary>From
										  Clause</primary></indexterm><indexterm><primary>Select
										  Statement</primary><secondary>From Clause</secondary></indexterm>From
								Clause</title> 
						  <para>The <emphasis>from clause</emphasis> is required and
								specifies the initial table from which the result should be gathered. Note that
								the <emphasis>table specifier</emphasis> is allowed to be a <emphasis>query
								expression</emphasis> in itself. This is known as a <emphasis>nested
								from</emphasis> and is only supported by some systems. We choose to support it
								in Common SQL because it is a <emphasis>very</emphasis> useful extension to
								SQL.</para> 
					 </sect4> 
					 <sect4 id="D4LGJoinClause"> 
						  <title><indexterm><primary>Join
										  Clause</primary></indexterm><indexterm><primary>Select
										  Statement</primary><secondary>Join Clause</secondary></indexterm>Join
								Clause</title> 
						  <para>The <emphasis>join clause</emphasis> is optional and
								specifies an additional table to bring in to the query. The various qualifiers
								in the join clause specify the type of join to be done, and an optional
								<emphasis>conditional expression</emphasis> is used to indicate how inner and
								outer joins are to be performed. Note here again that the <emphasis>table
								specifier</emphasis> is allowed to be a <emphasis>query expression</emphasis>,
								and that only a handful of systems support this type of nesting. Even among
								those that do, there is inconsistency about the types of expressions that are
								allowed to be nested.</para> 
					 </sect4> 
					 <sect4 id="D4LGWhereClause"> 
						  <title><indexterm><primary>Where
										  Clause</primary></indexterm><indexterm><primary>Select
										  Statement</primary><secondary>Where Clause</secondary></indexterm>Where
								Clause</title> 
						  <para>The <emphasis>where clause</emphasis> is optional and
								specifies a filter that is applied to the rows in the result. Only rows for
								which the expression specified by <emphasis>conditional expression</emphasis>
								evaluates to true appear in the result. Values of columns for the row being
								processed are accessible within the expression by name. Note that references to
								column aliases are not allowed, only columns of actual tables in the query can
								be referenced. This limitation can be worked around using a nested from, which
								is one of the reasons it is so useful.</para> 
					 </sect4> 
					 <sect4 id="D4LGGroupByClause"> 
						  <title><indexterm><primary>Group By
										  Clause</primary></indexterm><indexterm><primary>Select
										  Statement</primary><secondary>Group By Clause</secondary></indexterm>Group By
								Clause</title> 
						  <para>The <emphasis>group by clause</emphasis> is optional,
								so long as the <emphasis>column expression commalist</emphasis> contains no
								aggregate operator invocations, or contains only aggregate operator
								invocations. If there is a mixture of aggregate and non-aggregate expressions,
								the group by clause must specify all the non-aggregate expressions.</para> 
					 </sect4> 
					 <sect4 id="D4LGHavingClause"> 
						  <title><indexterm><primary>Having
										  Clause</primary></indexterm><indexterm><primary>Select
										  Statement</primary><secondary>Having Clause</secondary></indexterm>Having
								Clause</title> 
						  <para>The <emphasis>having clause</emphasis> is optional,
								and specifies a filter that is applied to the rows in the result after any
								aggregation in the query. As with the <emphasis>where clause</emphasis>,
								references to column aliases are not allowed, but references to the aggregate
								operator invocations are.</para> 
					 </sect4> 
					 <sect4 id="D4LGOrderByClause"> 
						  <title><indexterm><primary>Order By
										  Clause</primary></indexterm><indexterm><primary>Select
										  Statement</primary><secondary>Order By Clause</secondary></indexterm>Order By
								Clause</title> 
						  <para>The <emphasis>order by clause</emphasis> is optional,
								and specifies an overall ordering for the result.</para> 
					 </sect4> 
				</sect3> 
				<sect3 id="D4LGInsertStatement1"> 
					 <title><indexterm><primary>Insert
									 Statement</primary></indexterm><indexterm><primary>Common
									 SQL</primary><secondary>Insert Statement</secondary></indexterm>Insert
						  Statement</title> 
					 <para>The insert statement in SQL allows a row or rows to be
						  inserted into a given table variable. The insert statement in Common SQL has
						  the following syntax: 
						  <programlisting>&lt;insert statement&gt; ::=
	insert into &lt;table name&gt;"("&lt;column name commalist&gt;")"
		(&lt;values clause&gt; | &lt;query expression&gt;)

&lt;values clause&gt; ::=
	values "("&lt;expression commalist&gt;")"</programlisting></para> 
				</sect3> 
				<sect3 id="D4LGUpdateStatement1"> 
					 <title><indexterm><primary>Update
									 Statement</primary></indexterm><indexterm><primary>Common
									 SQL</primary><secondary>Update Statement</secondary></indexterm>Update
						  Statement</title> 
					 <para>The update statement in SQL allows the data in a given
						  table variable to be updated. The update statement in Common SQL has the
						  following syntax: 
						  <programlisting>&lt;update statement&gt; ::=
	update &lt;table name&gt; 
		set &lt;update column expression colmmalist&gt;
		[&lt;where clause&gt;]</programlisting></para> 
				</sect3> 
				<sect3 id="D4LGDeleteStatement1"> 
					 <title><indexterm><primary>Delete
									 Statement</primary></indexterm><indexterm><primary>Common
									 SQL</primary><secondary>Delete Statement</secondary></indexterm>Delete
						  Statement</title> 
					 <para>The delete statement in SQL allows the data in a given
						  table variable to be deleted. The delete statement in Common SQL has the
						  following syntax: 
						  <programlisting>&lt;delete statement&gt; ::=
	delete &lt;table name&gt;
		[&lt;where clause&gt;]</programlisting></para> 
				</sect3> 
		  </sect2> 
		  <sect2 id="D4LGVendorDialects"> 
				<title><indexterm><primary>Vendor
								Dialects</primary></indexterm><indexterm><primary>Comparison With
								SQL</primary><secondary>Vendor Dialects</secondary></indexterm>Vendor
					 Dialects</title> 
				<para>There are probably more dialects of SQL than there are
					 programming languages. Each DBMS has its own definition of what the language
					 is, what features it supports, how it manages data, and what the syntax of
					 specific statements is. This section discusses a few of the more pervasive
					 implementations, and how they differ from Common SQL, and from
					 themselves.</para> 
				<para>Note that the differences outlined here are mainly syntactic
					 in nature. When the semantics of the different languages are considered as
					 well, the problems of finding a common language become almost unmanageable. For
					 this comparison we largely ignore these issues, but be aware that the DAE is
					 dealing with them underneath.</para> 
				<sect3 id="D4LGTransact-SQL"> 
					 <title><indexterm><primary>Transact-SQL</primary></indexterm><indexterm><primary>Vendor
									 Dialects</primary><secondary>Transact-SQL</secondary></indexterm>Transact-SQL</title>
					 
					 <para>Microsoft SQL Server uses a dialect of SQL called
						  Transact-SQL or T-SQL. This dialect is very similar to Common SQL except that
						  it supports both flavors of join specification in the from clause, and it has
						  no support for the intersect and except operators. Intersect is not necessary
						  because it is a special case of join, but except is a critical operator, and
						  the lack of support for it is a serious drawback of this dialect.</para> 
					 <para>A peculiarity of this dialect is the way in which outer
						  joins are specified when the <emphasis>table specifier commalist</emphasis>
						  style of from clause is used. The outer join is specified by using a special
						  comparison operator when defining the join in the where clause. The symbol *=
						  is used for left joins, while =* is used for right joins. There are also some
						  associated restrictions with using these operators, but we chose to avoid the
						  syntax entirely and so do not discuss them here.</para> 
					 <para>Another difference is the treatment of the wildcard
						  (<symbol>*</symbol>) in the <emphasis>column expression commalist</emphasis>.
						  T-SQL allows table qualifiers on the wildcard to indicate that all the columns
						  of a particular table are to be included in the result. While this is a useful
						  extension, we did not chose to support in Common SQL, as it is not
						  necessary.</para> 
					 <para>The <emphasis>from clause</emphasis> in T-SQL is
						  optional, in which case the statement is based on the table with one row, and
						  only the columns specified in the <emphasis>column expression
						  commalist</emphasis>. While this is also a useful extension, we found no other
						  dialects in support of it, and so chose not to support it in Common SQL.</para>
					 
					 <para>Nested froms are allowed in T-SQL, but there is a problem
						  with certain constructs in which the nested expression can only reference
						  columns in the outer query to two levels of nesting. Incidentally, Sybase SQL
						  also suffers from this problem, which is not surprising, given the history of
						  the two systems.</para> 
				</sect3> 
				<sect3 id="D4LGOracleSQL"> 
					 <title><indexterm><primary>Oracle
									 SQL</primary></indexterm><indexterm><primary>Vendor
									 Dialects</primary><secondary>Oracle SQL</secondary></indexterm>Oracle
						  SQL</title> 
					 <para>Oracle database systems use a dialect of SQL called
						  Oracle SQL, appropriately enough. This dialect differs mostly in its support
						  for the <emphasis>from clause</emphasis>. The dialect only supports the
						  <emphasis>table specifier commalist</emphasis> flavor, and has some severe
						  limitations on the usage of nested from.</para> 
					 <para>This dialect also has a peculiar way of specifying outer
						  joins. This is done by using the <symbol>(+)</symbol> symbol next to the name
						  of the column within the table which is to be the outer table. While we did not
						  find the same restrictions on usage as T-SQL has, we find the syntax clumsy and
						  counter-intuitive.</para> 
					 <para>Nested froms are allowed in Oracle SQL, but the nested
						  expression may not reference columns in the main query. This is in violation of
						  Core SQL as specified by the ANSI-SQL 1999 standard, and is a major drawback of
						  this dialect.</para> 
				</sect3> 
				<sect3 id="D4LGDB2SQL"> 
					 <title><indexterm><primary>DB2
									 SQL</primary></indexterm><indexterm><primary>Vendor
									 Dialects</primary><secondary>DB2 SQL</secondary></indexterm>DB2 SQL</title> 
					 <para>DB2 database systems use a dialect of SQL which we will
						  call DB2 SQL. This dialect is very similar to Common SQL, and does not require
						  much modification to represent. It is worth noting that the dialect does suffer
						  from a nested from anomaly as well.</para> 
					 <para>Nested froms are allowed in DB2 SQL, but the nested
						  expression may not reference columns in the main query unless the keyword
						  <symbol>TABLE</symbol> is specified as part of the nested from definition. This
						  seems to be a general solution to the problem, and so it is little more than a
						  peculiarity.</para> 
				</sect3> 
		  </sect2> 
		  <sect2 id="D4LGMappinganSQLQueryIntoD4"> 
				<title><indexterm><primary>Mapping an SQL Query Into
								D4</primary></indexterm><indexterm><primary>Comparison With
								SQL</primary><secondary>Mapping an SQL Query Into
								D4</secondary></indexterm>Mapping an SQL Query Into D4</title> 
				<para>In order to show how an arbitrary SQL statement can be
					 expressed in D4, it is useful to have a sample database definition to work
					 with. The sample is given in D4, but the syntax is similar to SQL and the
					 semantics should be clear: 
					 <programlisting>create table Employee
{ 
	ID : Integer,
	Name : String,
	key { ID }
}; 

insert 
	table	
	{
		row { 1 ID, "Joe" Name },
		row { 2, "John" },
		row { 3, "Josh" },
		row { 4, "Jeff" },
		row { 5, "Jake" },
		row { 6, "Jeff" }
	} 
	into Employee;

create table Manager
{
	Employee_ID : Integer,
	Manager_ID : Integer,
	key { Employee_ID },
	reference Manager_Employee { Employee_ID } references Employee { ID },
	reference Manager_Manager { Manager_ID } references Employee { ID }
};

insert 
	table
	{
		row { 2 Employee_ID, 1 Manager_ID },
		row { 3 Employee_ID, 1 Manager_ID },
		row { 4 Employee_ID, 2 Manager_ID },
		row { 6 Employee_ID, 2 Manager_ID },
		row { 5 Employee_ID, 4 Manager_ID }
	}
	into Manager;

create table EmployeePhone 
{
	Employee_ID : Integer,
	Phone : String,
	key { ID, Phone },
	reference EmployeePhone_Employee { Employee_ID } references Employee { ID }
};

EmployeePhone :=
	table
	{
		row { 1 Employee_ID, "555-1234" Phone },
		row { 1 Employee_ID, "555-1000" Phone }, 
		row { 2 Employee_ID, "555-4321" Phone },
		row { 4 Employee_ID, "555-4444" Phone },
		row { 5 Employee_ID, "555-5678" Phone }
	};</programlisting></para> 
				<sect3 id="D4LGDataRetrieval"> 
					 <title><indexterm><primary>Data
									 Retrieval</primary></indexterm><indexterm><primary>Mapping an SQL Query Into
									 D4</primary><secondary>Data Retrieval</secondary></indexterm>Data
						  Retrieval</title> 
					 <para>We begin by mapping basic data retrieval. Suppose we are
						  asked 'Get IDs and Names of all employees.' This simple query can be answered
						  using the SQL statement: 
						  <programlisting>select * from Employee</programlisting></para> 
					 <para>This is the simplest select statement possible in Common
						  SQL and indicates that all the columns and all the rows of the Employee table
						  should be included in the result. Notice that we have not done any manipulation
						  to the result, in other words, no operators have been invoked. We have simply
						  referenced the name of a table variable within an expression.</para> 
					 <para>If this is true, why the '* from' portion of the query?
						  Clearly it is an artifact of the rigid structure required of SQL statements. By
						  contrast, the equivalent D4 statement: 
						  <programlisting>select Employee;</programlisting></para> 
					 <para>This is the simplest select statement possible in D4 and
						  is precisely what we wanted, all the columns and all the rows of the Employee
						  table, without any extra artifacts. The point is, because we invoked no
						  operators, no extra information needs to be specified, the reference to the
						  table variable is enough. While this may not seem like much right now, keep in
						  mind this is the simplest select statement possible. As the statements become
						  more complex, these differences will become more and more apparent.</para> 
					 <para>Also note that unlike SQL, the keyword
						  <symbol>select</symbol> in D4 is only part of the statement, it is not part of
						  the expression.</para> 
				</sect3> 
				<sect3 id="D4LGTheWhereClause"> 
					 <title><indexterm><primary>The Where
									 Clause</primary></indexterm><indexterm><primary>Mapping an SQL Query Into
									 D4</primary><secondary>The Where Clause</secondary></indexterm>The Where
						  Clause</title> 
					 <para>Next, we consider a simple restriction. Suppose we are
						  asked 'Get the IDs and Names of Employees whose ID is greater than 3.' In SQL,
						  we have: 
						  <programlisting>select * from Employee where ID &gt; 3;</programlisting></para> 
					 <para>The where clause applies a filter to the result. Only
						  rows for which the specified conditional expression evaluates to true are
						  included in the result. In D4, the equivalent query is: 
						  <programlisting>select Employee where ID &gt; 3;</programlisting></para> 
					 <para>The where operator in D4 performs the same type of
						  filtering on the result.</para> 
				</sect3> 
				<sect3 id="D4LGUnravelingtheColumnList"> 
					 <title><indexterm><primary>Unraveling the Column
									 List</primary></indexterm><indexterm><primary>Mapping an SQL Query Into
									 D4</primary><secondary>Unraveling the Column
									 List</secondary></indexterm>Unraveling the Column List</title> 
					 <para>The column list in an SQL query is actually performing
						  four distinct operations in the query: projection, extension, renaming, and
						  part of aggregation. In this section, we consider the first of these,
						  projection. Suppose we are asked 'Get the Names of Employees.' In SQL we would
						  write: 
						  <programlisting>select distinct Name from Employee</programlisting></para> 
					 <para>The projection step indicates that only the Name column
						  from the Employee table should appear in the result.</para> 
					 <para>The equivalent statement in D4 is: 
						  <programlisting>select Employee over { Name };</programlisting></para> 
					 <para>Projection in D4 is always done using one of two
						  operators, <symbol>over</symbol> and <symbol>remove</symbol>. Over allows the
						  desired columns to be specified, while remove allows the unwanted columns to be
						  specified. Thus an alternative formulation of the query is: 
						  <programlisting>select Employee remove { ID };</programlisting></para> 
					 <para>There is another important difference between the SQL
						  version of projection, and the projection of D4: the elimination of duplicates.
						  In the SQL version of the query, we had to specify <symbol>distinct</symbol> in
						  order to tell the system that duplicates should be eliminated from the result.
						  In D4, the result is never allowed to contain duplicates, so no distinct
						  keyword is required.</para> 
				</sect3> 
				<sect3 id="D4LGAddingColumns"> 
					 <title><indexterm><primary>Adding
									 Columns</primary></indexterm><indexterm><primary>Mapping an SQL Query Into
									 D4</primary><secondary>Adding Columns</secondary></indexterm>Adding
						  Columns</title> 
					 <para>Next we consider the effect of columns defined in terms
						  of expressions. Suppose we are asked 'Get IDs, and Names of all employees,
						  together with the length of the name for each employee.' In SQL, we would
						  write: 
						  <programlisting>select ID, Name, Length(Name) from Employee</programlisting></para> 
					 <para>This query illustrates the second of the four tasks
						  specified in the column list, that of extension. In SQL, an expression is
						  allowed to define the value for a given column in the result. </para> 
					 <para>The equivalent statement in D4 is: 
						  <programlisting>select Employee add { Length(Name) NameLength };</programlisting></para> 
					 <para>The add operator of D4 allows columns to be added to the
						  result. The values for the new columns are given by the expressions in the add
						  clause.</para> 
					 <para>An important point can be illustrated by asking a simple
						  question about the result of the SQL version of the query: What is the name of
						  the column containing the length of the name of each employee? The answer is,
						  it is undefined. The SQL syntax does not force the column to be named, and
						  without a name, it cannot be referenced by anything else in the query. This
						  fact has severe implications when we attempt to use queries of this type in
						  more complex expressions of SQL. By contrast, in the D4 version, the name is
						  specified as part of the definition of the column, so the problem is completely
						  avoided.</para> 
				</sect3> 
				<sect3 id="D4LGRenamingColumns"> 
					 <title><indexterm><primary>Renaming
									 Columns</primary></indexterm><indexterm><primary>Mapping an SQL Query Into
									 D4</primary><secondary>Renaming Columns</secondary></indexterm>Renaming
						  Columns</title> 
					 <para>Next we discuss the renaming of columns in a result.
						  Suppose we want the Name column in the result to be called LastName. In SQL we
						  write: 
						  <programlisting>select ID, Name as LastName from Employee</programlisting></para> 
					 <para>This query illustrates the third of the four tasks being
						  specified by the column list, that of renaming columns. The optional
						  <symbol>as</symbol> keyword is used to specify a new name for the given
						  column.</para> 
					 <para>In D4, the equivalent query is: 
						  <programlisting>select Employee rename { Name LastName };</programlisting></para> 
					 <para>The rename operator of D4 allows the names of the columns
						  in a result to be changed. This operator has no effect on the values of the
						  columns in the result.</para> 
					 <para>To illustrate a point about the names of columns in the
						  result, consider the following SQL query: 
						  <programlisting>select ID, Name, Name from Employee</programlisting>This query is perfectly legal in SQL, but the result has the
						  same name for two columns. Again, we are faced with the problem that the column
						  cannot be referenced by anything else in the query. In D4, all the columns of a
						  given result must be unique, so again, the problem is completely
						  avoided.</para> 
				</sect3> 
				<sect3 id="D4LGTheGroupByandHavingClauses"> 
					 <title><indexterm><primary>The Group By and Having
									 Clauses</primary></indexterm><indexterm><primary>Mapping an SQL Query Into
									 D4</primary><secondary>The Group By and Having
									 Clauses</secondary></indexterm>The Group By and Having Clauses</title> 
					 <para>Now we consider queries in which columns in the result
						  are defined with aggregate expressions. Suppose we are asked 'Get the number of
						  employees.' In SQL we write: 
						  <programlisting>select Count(*) from Employee</programlisting>This invokes the aggregate operator Count(*) on the Employee
						  table.</para> 
					 <para>In D4, the equivalent query is: 
						  <programlisting>select Employee group add { Count() EmployeeCount };</programlisting></para> 
					 <para>On the surface the SQL version of the query looks very
						  similar to the extend operator, but in reality, the task is completely
						  different, and is the fourth task specified in the column list, that of
						  aggregation. Actually, the task is split between the expressions in the column
						  list, and the group by clause, a fact which serves to complicate matters even
						  further.</para> 
					 <para>By changing the query slightly to 'Get the names of
						  employees together with the number of employees that have that name' we get the
						  new statement: 
						  <programlisting>select Name, Count(*) 
	from Employee 
	group by Name</programlisting></para> 
					 <para>In D4, the equivalent query is: 
						  <programlisting>select Employee 
	group by { Name } add { Count() EmployeeCount };</programlisting></para> 
					 <para>In the SQL version of the query, because the column list
						  includes both aggregate and non-aggregate expressions, we are forced to use the
						  group by clause to express the desired grouping. In SQL, the task of specifying
						  an aggregation is split between the select list where the columns to be
						  computed are specified, and the group by clause, where the grouping columns are
						  specified. In D4, the group operator allows the grouping columns to be
						  specified directly. This is followed immediately by the specification of the
						  aggregates to compute.</para> 
					 <para>Note that the group by in SQL is not allowed to reference
						  aliases. With that in mind, consider the following two equivalent SQL queries: 
						  <programlisting>select ID / 2, Count(*)
	from Employee
	group by ID / 2</programlisting> 
						  <programlisting>select ID / 2, Count(*)
	from Employee
	group by ID * 0.5</programlisting></para> 
					 <para>Clearly, these two queries are equivalent, but one is a
						  legal SQL query, and the other is not. Because the group by clause must contain
						  at least the non-aggregate columns in the select list, we are forced to write
						  out the expression multiple times, and we cannot use what are clearly
						  equivalent formulations of the expression. In D4, this query becomes: 
						  <programlisting>select Employee 
	add { ID / 2 HalfID } 
	group by { HalfID } add { Count() EmployeeCount };</programlisting></para> 
					 <para>Note that the actual task of computing the expression to
						  be grouped on is relegated to the extend operator, rather than intermixed with
						  the group operator. By cleanly separating the tasks involved, the complexity of
						  the language is reduced, while the power is increased.</para> 
					 <para>To pursue this example further, suppose we only want rows
						  in the result for which the EmployeeCount is greater than one. In SQL, the
						  query becomes: 
						  <programlisting>select ID / 2, Count(*)
	from Employee
	group by ID / 2
	having Count(*) &gt; 1</programlisting></para> 
					 <para>The addition of the having clause allows us to filter the
						  result based on the values computed for aggregate expressions in the select
						  list. Again, column aliases cannot be referenced, so we are forced to write out
						  the same aggregate expression (with the same restrictions on usage, namely it
						  must be syntactically the same expression, not semantically) in order to
						  express the desired filter. In D4, the equivalent query is: 
						  <programlisting>select Employee 
	add { ID / 2 HalfID } 
	group by { HalfID } add { Count() EmployeeCount } 
	where EmployeeCount &gt; 1;</programlisting></para> 
					 <para>There is no need to introduce a new concept for
						  filtering, we already have that functionality in the where operator. Because D4
						  is an algebra, the result of any operator can be used as an argument to the
						  next operator. This allows us to simply add another where referencing the
						  EmployeeCount column.</para> 
				</sect3> 
				<sect3 id="D4LGTheFromandJoinClauses"> 
					 <title><indexterm><primary>The From and Join
									 Clauses</primary></indexterm><indexterm><primary>Mapping an SQL Query Into
									 D4</primary><secondary>The From and Join Clauses</secondary></indexterm>The
						  From and Join Clauses</title> 
					 <para>With the column list completely unraveled, we now turn
						  our attention to the from clause. Up till now, we have been using a very simple
						  from clause in all our queries: <symbol>from Employee</symbol>. In SQL, the
						  from clause is allowed to contain any number of references to tables together
						  with the specification of how those tables should be brought together in the
						  result. Suppose we are asked 'Get IDs, Names and Phone Numbers of all
						  Employees.' The information to satisfy this query is in two different tables,
						  Employee and EmployeePhone. In SQL, we use a join and write: 
						  <programlisting>select * 
	from Employee
		join EmployeePhone on ID = Employee_ID</programlisting></para> 
					 <para>This query references the Employee table, then joins it
						  to the EmployeePhone table using the relationship <symbol>ID =
						  Employee_ID</symbol>. This type of join is also called an inner join, and the
						  keyword <symbol>inner</symbol> may even be specified in the join clause. We can
						  further categorize this type of join as an equi-join, meaning that the
						  condition specified to perform the join consists only of equality comparisons
						  between columns in opposite tables of the join, and that all such comparisons
						  are required to be true in order for a match to appear in the result (in other
						  words, only the <symbol>and</symbol> operator is used between column equality
						  comparisons).</para> 
					 <para>In D4, the equivalent query is: 
						  <programlisting>select Employee 
	join EmployeePhone by ID = Employee_ID;</programlisting></para> 
					 <para>Note again the disappearance of the '* from' portion of
						  the query. Because no projection is being performed, it is simply not
						  specified. Note also that in D4 there is no inner keyword.</para> 
					 <para>To illustrate the next kind of join, suppose we are asked
						  'Get all possible combinations of two employees.' In SQL we write: 
						  <programlisting>select * 
	from Employee 
		cross join Employee</programlisting></para> 
					 <para>This is known as the cross-product, or times operator,
						  and specifies that for each row in the left table and each row in the right
						  table a row should appear in the result that is the concatenation of both rows.
						  Note that we now have two of each column in the result, and are faced with
						  another naming problem. In order to solve this problem in SQL, we can make use
						  of the concept of <emphasis>table aliases</emphasis>. By rewriting the query
						  as: 
						  <programlisting>select * 
	from Employee E1 
		cross join Employee E2</programlisting>we can now uniquely reference all the columns in the result.
						  </para> 
					 <para>In D4, the first query would be: 
						  <programlisting>select Employee times Employee;</programlisting>but this would fail with a compile-time error stating that
						  duplicate names exist in the result. In order to express the query, we can make
						  use of the rename operator: 
						  <programlisting>select (Employee rename { ID E1.ID, Name E1.Name }) times
	(Employee rename { ID E2.ID, Name E2.Name });</programlisting></para> 
					 <para>Clearly this involves an excessive amount of renaming, so
						  D4 introduces a variant of the rename operator that works for all the columns
						  in a table. Using this operator we can rewrite the query as: 
						  <programlisting>select (Employee rename E1) times (Employee rename E2);</programlisting>and obtain an equivalent result.</para> 
					 <para>The next kind of join possible in the join clause is
						  called an outer join. There are three different flavors of outer join in SQL:
						  left, right, and full. Suppose we are asked 'Get IDs and Names of all employees
						  toghether with the PhoneNumbers of those employees, if they have one.' In SQL
						  we write: 
						  <programlisting>select *
	from Employee
		left join EmloyeePhone on ID = Employee_ID</programlisting></para> 
					 <para>This query indicates that a join should be performed
						  between Employee and EmployeePhone, but that if a given Employee row has no
						  match, it should be included in the result with nulls for the columns of
						  EmployeePhone.</para> 
					 <para>In D4, the equivalent query is: 
						  <programlisting>select Employee left join EmployeePhone by ID = Employee_ID;</programlisting></para> 
					 <para>Note carefully that the outer joins are not relational
						  operators. Once an outer join is introduced into a query, the result may
						  contain nulls, and is therefore not a relation. For more discussion on this
						  topic, refer to the Outer Joins section of the Table Expressions discussion in
						  this guide.</para> 
					 <para>The right join simply specifies the right table as the
						  one that should have unmatched rows included, and a full join states that both
						  sides should have unmatched rows included. D4 supports the right join, with the
						  <symbol>right join</symbol> operator, but does not support the full join
						  operator, as it is rarely used, and is only shorthand for the union of the left
						  and right joins.</para> 
					 <para>An important difference between the join operators of SQL
						  and D4 is that in D4, all joins are required to be equi-joins. To see why this
						  is so, we must first show that any join can be expressed using a combination of
						  cross-product and restrict: 
						  <programlisting>select Employee join EmployeePhone by ID = Employee_ID</programlisting> is logically equivalent to: 
						  <programlisting>select Employee cross join EmployeePhone where ID = Employee_ID</programlisting>This means that any non-equi join such as: 
						  <programlisting>select Employee join EmployeePhone by ID &gt; Employee_ID</programlisting>can always be expressed using the equivalent cross-product and
						  restriction, so we do not lose any expressive power by restricting joins to be
						  equi-joins. However, we do gain the benefit that the cardinality of any join is
						  always well-defined, which has implications for the key inference mechanism of
						  D4. For this reason, all joins in D4 are required to be equi-joins.</para> 
				</sect3> 
				<sect3 id="D4LGTheTableOperatorClause"> 
					 <title><indexterm><primary>The Table Operator
									 Clause</primary></indexterm><indexterm><primary>Mapping an SQL Query Into
									 D4</primary><secondary>The Table Operator Clause</secondary></indexterm>The
						  Table Operator Clause</title> 
					 <para>Now that we have described the <emphasis>select
						  expression</emphasis>, we discuss the <emphasis>table operator
						  clause</emphasis>, which allows complete select expressions to be used as
						  arguments to the so-called <emphasis>union-compatible</emphasis> binary table
						  operators: union, intersection and difference. Two tables in SQL are
						  union-compatible if they have the same number of columns, and the columns have
						  the same data types, from left to right (i.e. the first column in the left
						  table is the same type as the first column in the right table, and so on).
						  </para> 
					 <para>First, we consider the union operator. Suppose we are
						  asked 'Get the IDs of all employees that have phones or that have managers.' In
						  SQL we write: 
						  <programlisting>select ID 
	from Employee 
		join EmployeePhone by ID = Employee_ID
union
select ID
	from Employee
		join Manager by ID = Employee_ID</programlisting></para> 
					 <para>This query uses the union operator to combine the IDs
						  from each portion of the query into a single result. A row will appear in the
						  result of a union if it appears in the left table or the right table, or
						  both.</para> 
					 <para>The equivalent query in D4 is: 
						  <programlisting>select 
	(Employee join EmployeePhone by ID = Employee_ID) 
	union 
	(Employee join Manager by ID = Employee_ID);</programlisting></para> 
					 <para>There is an important difference between the two
						  operators. In SQL, the union clause is allowed to include an optional
						  <symbol>all</symbol> which indicates that duplicates should not be eliminated
						  from the result. If a given row appears in both the left and right sides of the
						  union, it will appear twice in the result. In D4, duplicates are never allowed,
						  so no such option is available for the union operator.</para> 
					 <para>Next, we consider the intersect operator. If we change
						  our query to 'Get the IDs of all employees that have phones and that have
						  managers' then the SQL becomes: 
						  <programlisting>select ID
	from Employee
		join EmployeePhone by ID = Employee_ID
intersect
select ID
	from Employee
		join Manager by ID = Employee_ID</programlisting></para> 
					 <para>This query uses the intersect operator to compute the
						  desired result. A row will appear in the result of an intersect if it appears
						  in the left table and the right table.</para> 
					 <para>The equivalent query in D4 is: 
						  <programlisting>select
	(Employee join EmployeePhone by ID = Employee_ID)
	intersect
	(Employee join Manager by ID = Employee_ID);</programlisting></para> 
					 <para>Again, note that the SQL version of the operator includes
						  an optional <symbol>all</symbol> which specifies that duplicates should not be
						  eliminated from the result. D4 has no such option for the intersect
						  operator.</para> 
					 <para>Finally, the difference operator. If we change our query
						  to 'Get the IDs of all employees that have phones and do not have managers'
						  then the SQL becomes: 
						  <programlisting>select ID
	from Employee
		join EmployeePhone by ID = Employee_ID
except
select ID
	from Employee
		join Manager by ID = Employee_ID</programlisting></para> 
					 <para>This query uses the difference operator to remove
						  Employee IDs that have manager from the result. A row will only appear in the
						  result of a difference if it appears in the left table and not the right
						  table.</para> 
					 <para>The equivalent query in D4 is: 
						  <programlisting>select
	(Employee join EmployeePhone by ID = Employee_ID)
	minus
	(Employee join Manager by ID = Employee_ID);</programlisting></para> 
					 <para>Once again, the SQL version of the operator includes the
						  <symbol>all</symbol> keyword which specifies that duplicate elimination should
						  not occur. D4 has no counterpart for this version of the difference
						  operator.</para> 
				</sect3> 
				<sect3 id="D4LGTheOrderByClause"> 
					 <title><indexterm><primary>The Order By
									 Clause</primary></indexterm><indexterm><primary>Mapping an SQL Query Into
									 D4</primary><secondary>The Order By Clause</secondary></indexterm>The Order By
						  Clause</title> 
					 <para>The order by clause in D4 maps in a fairly
						  straightforward way into D4. For example, suppose we are asked 'Get the IDs and
						  Names of all Employees ordered by Name alphabetically. In SQL we write: 
						  <programlisting>select ID, Name
	from Employee
	order by Name</programlisting></para> 
					 <para>The equivalent statement in D4 is: 
						  <programlisting>select Employee order by { Name };</programlisting></para> 
					 <para>In both languages, the order by is not part of the
						  expression, rather it is part of the specification of how the result should be
						  returned. In other words, the order by clause in D4 is not an operator, it is
						  part of the select statement.</para> 
				</sect3> 
				<sect3 id="D4LGDataModificationStatements"> 
					 <title><indexterm><primary>Data Modification
									 Statements</primary></indexterm><indexterm><primary>Mapping an SQL Query Into
									 D4</primary><secondary>Data Modification Statements</secondary></indexterm>Data
						  Modification Statements</title> 
					 <para>The syntax for the insert, update, and delete statements
						  in SQL and D4 is very similar, even identical in some respects, so the mapping
						  is relatively straightforward. There are some important logical differences
						  between the semantics of the operators, particularly for the insert and
						  update.</para> 
					 <para>First, we discuss the insert statement. Suppose we want
						  to add a new employee into the list of Employees. In SQL, we have: 
						  <programlisting>insert into Employee(ID, Name) values(7, "Jake")</programlisting></para> 
					 <para>This example illustrates the use of the first variation
						  of the insert statement in SQL, that of inserting a single row. Suppose we want
						  to insert the results of some query. In SQL, we have: 
						  <programlisting>insert into Employee(ID, Name) select ID + 6, Name from Employee</programlisting></para> 
					 <para>In D4, the equivalent statements are: 
						  <programlisting>insert table { row { 7 ID, "Jake" Name } } into Employee;</programlisting>and 
						  <programlisting>insert Employee redefine { ID := ID + 6 } into Employee;</programlisting>Note: the redefine operator is shorthand for an equivalent
						  extend-rename-remove operation.</para> 
					 <para>Several important points should be made about the above
						  statements: 
						  <itemizedlist> 
								<listitem> 
									 <para>Left-to-right ordering</para> 
									 <para>In the SQL versions of the statements, the
										  left-to-right order of the <emphasis>values clause</emphasis> in the single row
										  insert, and the <emphasis>query expression</emphasis> in the multiple row
										  insert is important. By contrast, D4 attaches no significance to the order of
										  the columns in the statement. For example: 
										  <programlisting>insert table { row { "Jake" Name, 7 ID } } into Employee</programlisting>has the same effect because the columns are matched by name,
										  not by position in the result.</para> 
								</listitem> 
								<listitem> 
									 <para>Redundant constructs</para> 
									 <para>In the SQL versions of the statements, the
										  single row insert is clearly a special case of the more general multiple row
										  insert. In D4, the insert is defined more generally, and the special construct
										  is not needed.</para> 
								</listitem> 
								<listitem> 
									 <para>Order of specification</para> 
									 <para>In Common SQL, the insert target is specified
										  first. In english, the insert statement could be rendered 'insert into this
										  table, that data.' In D4, the data to be inserted is specified first, rendering
										  the english equivalent as 'insert this data into that table.'</para> 
								</listitem> 
								<listitem> 
									 <para>Restrictions on target</para> 
									 <para>In Common SQL, the insert target must be a
										  table variable name. In D4, the insert target is allowed to be an arbitrary
										  table-valued expression, i.e. the expression could consist of joins,
										  projections, restrictions, etc.,.</para> 
								</listitem> 
						  </itemizedlist></para> 
					 <para>Next, we discuss the update statement. Suppose we
						  discover that the employee with ID 6 is really named 'John'. In SQL, we would
						  write: 
						  <programlisting>update Employee set Name = 'John' where ID = 6</programlisting></para> 
					 <para>The equivalent statement in D4 is: 
						  <programlisting>update Employee set { Name := 'John' } where ID = 6;</programlisting></para> 
					 <para>While the two statements are very similar in structure,
						  there are some important differences: 
						  <itemizedlist> 
								<listitem> 
									 <para>Assignment operator</para> 
									 <para>The D4 version of the statement uses the
										  assignment operator <symbol>:=</symbol> to indicate that this is indeed an
										  assignment statement. The current value of the variable is being replaced by a
										  new value.</para> 
								</listitem> 
								<listitem> 
									 <para>Restrictions on target</para> 
									 <para>As with the insert statement, the D4 update
										  statement allows the target to be an arbitrary table-valued expression, rather
										  than requiring it to be the name of a table variable as in SQL.</para> 
								</listitem> 
						  </itemizedlist></para> 
					 <para>Finally, the delete statement. Suppose we decide to
						  remove the employee with ID 7 from the list of employees. In SQL, we have: 
						  <programlisting>delete Employee where ID = 7</programlisting></para> 
					 <para>The equivalent statement in D4 is: 
						  <programlisting>delete Employee where ID = 7;</programlisting></para> 
					 <para>The important difference between the two statements lies
						  in the specification of the target. As with the other modification operators in
						  D4, the delete statement is allowed to target an arbitrary table-valued
						  expression. In fact, the where clause is not part of the syntax of the delete
						  statement in D4, rather it is part of the table expression to be
						  deleted.</para> 
				</sect3> 
		  </sect2> 
		  <sect2 id="D4LGDataManagementDifferences"> 
				<title><indexterm><primary>Data Management
								Differences</primary></indexterm><indexterm><primary>Comparison With
								SQL</primary><secondary>Data Management Differences</secondary></indexterm>Data
					 Management Differences</title> 
				<para>This section discusses the main differences in the way that
					 SQL and D4 deal with data. The discussion will focus on two main topics:
					 duplicate rows and missing information. Each of these topics is the subject of
					 much debate in the literature. Suffice it to say that D4 supports relations,
					 and as such it does not support duplicates in relations, nor does it support
					 nulls in relations. We will not attempt to reconstruct the arguments for these
					 positions here, as this has been done, and quite well we might add, time and
					 time again in the literature, without a single convincing counterargument.
					 Again, the interested reader is referred to the Recommended Reading section of
					 this manual.</para> 
				<para>Briefly, we give an informal definition of a relation for
					 reference in the discussions that follow. A relation consists of two portions: 
					 <orderedlist> 
						  <listitem> 
								<para>A <emphasis>heading</emphasis>, consisting of a
									 <emphasis>set</emphasis> of <emphasis>attributes</emphasis> or
									 <emphasis>columns</emphasis> each of which has a name and a data type.</para> 
						  </listitem> 
						  <listitem> 
								<para>A <emphasis>body</emphasis>, consisting of a
									 <emphasis>set</emphasis> of <emphasis>tuples</emphasis> or
									 <emphasis>rows</emphasis>, each of which has a <emphasis>value</emphasis> for
									 each column in the heading of the relation.</para> 
						  </listitem> 
					 </orderedlist></para> 
				<para>A relational database is a database in which all information
					 is perceived as a collection of table (relation) variables, and nothing else.
					 These table variables may be <emphasis>base</emphasis> or
					 <emphasis>derived</emphasis>. A base table variable is defined in terms of its
					 columns, while a derived table variable is defined by a table-valued expression
					 that may reference other table variables in the database.</para> 
				<para>The data management differences discussed in this section
					 have to do with the relational model specifically. Indeed, many of the features
					 available in the DAE such as view updatability are available precisely because
					 D4 is a truly relational language (the term neo-relational has even been
					 suggested to avoid confusion with the often misused and misunderstood term
					 relational [7]).</para> 
				<sect3 id="D4LGDuplicateRows"> 
					 <title><indexterm><primary>Duplicate
									 Rows</primary></indexterm><indexterm><primary>Data Management
									 Differences</primary><secondary>Duplicate Rows</secondary></indexterm>Duplicate
						  Rows</title> 
					 <para>Based on the definition of a relation, duplicate rows,
						  i.e. two rows for which the equality comparison evaluates to true, are not
						  allowed because the definition of a relation body is a <emphasis>set</emphasis>
						  of rows, and sets, by definition, have unique elements. The reason this is so
						  important is that all the relational operators, indeed the entire relational
						  model, are based on this fundamental definition. If we deviate from this
						  definition, we are no longer talking about a relation, and therefore, we have
						  stepped outside the bounds of the relational model. For this reason, duplicate
						  rows are not allowed in D4. This fact has three important consequences for
						  users familiar with SQL-based systems: 
						  <orderedlist> 
								<listitem> 
									 <para>All base table variables are required to have
										  at least one key. Indeed, all table variables, base or derived must have at
										  least one key, but the keys of a derived table are inferred from its
										  definition. If no key is specified as part of the definition of a base table
										  variable, a key is assumed based on all the columns in the table
										  variable.</para> 
								</listitem> 
								<listitem> 
									 <para>The result of a projection will always have
										  duplicates eliminated, therefore there is no <symbol>distinct</symbol> option
										  for projection. If a projection eliminates the keys of the result, the key of
										  the result is made up of all the columns in the result, with duplicates
										  eliminated as necessary.</para> 
								</listitem> 
								<listitem> 
									 <para>The result of a union will always have
										  duplicates eliminated, therefore there is no <symbol>all</symbol> option for
										  union. The key of a union is always made up of all the columns in the result
										  (with some minor exceptions), with duplicates eliminated as necessary.</para> 
								</listitem> 
						  </orderedlist></para> 
					 <para>An interesting point about keys is that a key is allowed
						  to have no columns at all. If a key has no columns, then the table variable on
						  which it is defined may contain at most one row.</para> 
				</sect3> 
				<sect3 id="D4LGMissingInformation"> 
					 <title><indexterm><primary>Missing
									 Information</primary></indexterm><indexterm><primary>Data Management
									 Differences</primary><secondary>Missing
									 Information</secondary></indexterm>Missing Information</title> 
					 <para>Dealing with missing information in a database is a
						  complex problem. The approach taken by SQL-based system is the
						  <emphasis>null</emphasis>. Nulls are not values, they are flags which indicate
						  that a given column has no value. Given the definition of a relation above, it
						  should be clear that if a table is allowed to contain nulls, it is not a
						  relation, since the rows of a relation are required to have a
						  <emphasis>value</emphasis> for each column of the heading. This fact alone
						  should be enough to convince us that nulls are not a good idea, but there are
						  also numerous other reasons having to do with the way in which nulls behave
						  when used in expressions. Rather than reconstruct the arguments against the use
						  of nulls here, we refer the interested reader to the Recommended Reading
						  section, and move on to the solutions to missing information adopted in
						  D4.</para> 
					 <para>D4 provides two mechanisms for dealing with missing
						  information. The first is to use a database design which does not require the
						  storage of missing information. Indeed it is quite obvious when stated thus 'If
						  we do not know the information, we do not attempt to store it.' For example, if
						  we have a table called Employee with a column called PhoneNumber, but we do not
						  want to require a phone number to be entered for each employee, we can simply
						  put the PhoneNumber in a new table, say EmployeePhone, in a one-to-one
						  relationship with the Employee table. In this way, the information about
						  whether a given Employee has a phone is simply whether or not a corresponding
						  row exists in the EmployeePhone table.</para> 
					 <para>The second mechanism for dealing with missing information
						  is <emphasis>special values</emphasis>. A special value is a value of a given
						  domain which is set aside for a specific purpose by the application designer.
						  For example, if we want a domain to represent phone numbers, but we know that
						  we will not always have a phone number in practice, then we define the domain
						  in such a way as to allow the specification of some value outside the normal
						  range of phone numbers to indicate that a phone number is not known. When we
						  define the special value, the system creates special-purpose operators to
						  select the special value, as well as compare a given value of the domain
						  against the special value. Note that these operators are shorthands only.
						  Because the special value is a <emphasis>value</emphasis>, we can always
						  compare it with itself, and with other values of the domain with the expected
						  results. For more information on special values, see the Domains section of the
						  Catalog Elements portion of this guide.</para> 
					 <para>Using these two solutions, the problems of missing
						  information can be handled elegantly, and without stepping outside the bounds
						  of the relational model.</para> 
				</sect3> 
		  </sect2> 
	 </sect1> 
</chapter> 
