<?xml version="1.0"?><xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"                xmlns:doc="http://nwalsh.com/xsl/documentation/1.0"                xmlns:exsl="http://exslt.org/common"                xmlns:set="http://exslt.org/sets"                xmlns:saxon="http://icl.com/saxon"                xmlns:lxslt="http://xml.apache.org/xslt"                xmlns:xalanredirect="org.apache.xalan.xslt.extensions.Redirect"		version="1.1"                exclude-result-prefixes="doc exsl set saxon xalanredirect lxslt">    <xsl:import href="htmlhelp.xsl" />    <xsl:include href="param.xsl" />        <xsl:param name="bookpart" />        <!-- see htmlhelp.xsl for the original -->    <!--<xsl:template match="/">      <xsl:choose>        <xsl:when test="$rootid != ''">          <xsl:choose>            <xsl:when test="count(key('id',$rootid)) = 0">              <xsl:message terminate="yes">                <xsl:text>ID '</xsl:text>                <xsl:value-of select="$rootid"/>                <xsl:text>' not found in document.</xsl:text>              </xsl:message>            </xsl:when>            <xsl:otherwise>              <xsl:message>Formatting from <xsl:value-of select="$rootid"/></xsl:message>              <xsl:apply-templates select="key('id',$rootid)" mode="process.root"/>            </xsl:otherwise>          </xsl:choose>        </xsl:when>        <xsl:otherwise>          <xsl:apply-templates select="/" mode="process.root"/>        </xsl:otherwise>      </xsl:choose>    </xsl:template>-->    <!-- see html/titlepage.xsl for the original        this formats the title according to whether it's parent is a chunk for the Alphora look -->    <xsl:template match="title" mode="titlepage.mode">      <xsl:variable name="id">        <xsl:choose>          <!-- if title is in an *info wrapper, get the grandparent -->          <xsl:when test="contains(local-name(..), 'info')">            <xsl:call-template name="object.id">              <xsl:with-param name="object" select="../.."/>            </xsl:call-template>          </xsl:when>          <xsl:otherwise>            <xsl:call-template name="object.id">              <xsl:with-param name="object" select=".."/>            </xsl:call-template>          </xsl:otherwise>        </xsl:choose>      </xsl:variable>              <xsl:variable name="isChunk">            <xsl:call-template name="chunk">                <xsl:with-param name="node" select=".."/>            </xsl:call-template>        </xsl:variable>              <xsl:choose>        <xsl:when test="$isChunk=1">            <div id="banner">                <div id="header">                    Alphora Dataphor Help Collection                </div>             <h1 class="{name(.)}">                <a name="{$id}"/>                <xsl:choose>                  <xsl:when test="$show.revisionflag != 0 and @revisionflag">                <span class="{@revisionflag}">                  <xsl:apply-templates mode="titlepage.mode"/>                </span>                  </xsl:when>                  <xsl:otherwise>                <xsl:apply-templates mode="titlepage.mode"/>                  </xsl:otherwise>                </xsl:choose>              </h1>            </div>        </xsl:when>        <xsl:otherwise>            <!--<div id="banner">-->             <h3 class="{name(.)}">                <a name="{$id}"/>                <xsl:choose>                  <xsl:when test="$show.revisionflag != 0 and @revisionflag">                <span class="{@revisionflag}">                  <xsl:apply-templates mode="titlepage.mode"/>                </span>                  </xsl:when>                  <xsl:otherwise>                <xsl:apply-templates mode="titlepage.mode"/>                  </xsl:otherwise>                </xsl:choose>              </h3>            <!--</div>-->        </xsl:otherwise>      </xsl:choose>    </xsl:template>    <!-- -->    <xsl:template match="subtitle" mode="titlepage.mode">      <h2 class="{name(.)}">        <xsl:apply-templates mode="titlepage.mode"/>      </h2>    </xsl:template>    <!-- -->    <xsl:template match="*" mode="process.root">      <xsl:variable name="doc" select="self::*"/>      <!-- updates to 1.66.1 10/19/04 -->      <xsl:call-template name="user.preroot"/>      <xsl:call-template name="root.messages"/>        <html>          <head>            <xsl:call-template name="system.head.content">              <xsl:with-param name="node" select="$doc"/>            </xsl:call-template>            <!--<xsl:call-template name="head.content">              <xsl:with-param name="node" select="$doc"/>            </xsl:call-template>-->            <xsl:call-template name="user.head.content">              <xsl:with-param name="node" select="$doc"/>            </xsl:call-template>          </head>          <body>            <xsl:call-template name="body.attributes"/>            <xsl:call-template name="user.header.content">              <xsl:with-param name="node" select="$doc"/>            </xsl:call-template>            <div id="content">                <xsl:apply-templates select="."/>            </div>            <xsl:call-template name="user.footer.content">              <xsl:with-param name="node" select="$doc"/>            </xsl:call-template>          </body>      </html>    </xsl:template>    <!-- -->    <xsl:template match="revhistory">        <!-- do nothing, don't want history showing up -->    </xsl:template>    <!-- -->    <xsl:template match="revhistory" mode="titlepage.mode">        <!-- do nothing, don't want history showing up -->    </xsl:template>    <xsl:template name="escape-space">      <xsl:param name="value"/>          <xsl:call-template name="string.subst">        <xsl:with-param name="string" select="$value"/>        <xsl:with-param name="target" select="' '"/>        <xsl:with-param name="replacement" select="'%20'"/>      </xsl:call-template>          </xsl:template>            <xsl:template name="user.footer.content">      <xsl:variable name="subject" >        <xsl:call-template name="escape-space">          <xsl:with-param name="value" select="./title/text()"></xsl:with-param>        </xsl:call-template>      </xsl:variable>             <div id="footer">          <a>            <xsl:attribute name="href">mailto:docs@alphora.com?subject=<xsl:value-of select="$subject"/></xsl:attribute>					  Submit Feedback</a>            <!--<a href="RequiredNotices.html">-->            <xsl:text> Copyright &#169; 2004 Alphora. All rights reserved.</xsl:text>            <!--</a>-->       </div>    </xsl:template>            <!-- see inline.xsl -->    <!--    <xsl:template name="inline.charseq">      <xsl:param name="content">        <xsl:call-template name="anchor"/>        <xsl:call-template name="simple.xlink">          <xsl:with-param name="content">            <xsl:apply-templates/>          </xsl:with-param>        </xsl:call-template>      </xsl:param>      <xsl:choose>        <xsl:when test="name()='symbol'">            <i class="symbol"><xsl:copy-of select="$content"/></i>        </xsl:when>        <xsl:when test="name()='phrase'"> <!- means inline code ->            <i class="symbol"><xsl:copy-of select="$content"/></i>        </xsl:when>        <xsl:otherwise>            <i><xsl:copy-of select="$content"/></i>        </xsl:otherwise>      </xsl:choose>    </xsl:template>    -->    <!-- see ../htmlhelp/chunker -->    <xsl:template name="make-relative-filename">      <xsl:param name="base.dir" select="'./'"/>      <xsl:param name="base.name" select="''"/>          <xsl:choose>        <!-- put Saxon first to work around a bug in libxslt -->        <xsl:when test="element-available('saxon:output')">          <!-- Saxon doesn't make the chunks relative -->          <xsl:choose>            <xsl:when test="@id">                <xsl:value-of select="concat($base.dir,$base.name)"/>            </xsl:when>            <xsl:otherwise>                <xsl:value-of select="concat($bookpart,$base.dir,$base.name)"/>            </xsl:otherwise>          </xsl:choose>          <!--<xsl:value-of select="concat('S01B02',$base.dir,$base.name)"/>-->        </xsl:when>        <xsl:when test="element-available('exsl:document')">          <!-- EXSL document does make the chunks relative, I think -->          <xsl:choose>            <xsl:when test="count(parent::*) = 0">              <xsl:value-of select="concat($base.dir,$base.name)"/>            </xsl:when>            <xsl:otherwise>              <xsl:value-of select="$base.name"/>            </xsl:otherwise>          </xsl:choose>        </xsl:when>        <xsl:when test="element-available('xalanredirect:write')">          <!-- Xalan doesn't make the chunks relative -->          <xsl:choose>            <xsl:when test="@id">                <xsl:value-of select="concat($base.dir,$base.name)"/>            </xsl:when>            <xsl:otherwise>                <xsl:value-of select="concat($bookpart,$base.dir,$base.name)"/>            </xsl:otherwise>          </xsl:choose>          <!--<xsl:value-of select="concat($base.dir,$base.name)"/>-->        </xsl:when>        <xsl:otherwise>          <xsl:message terminate="yes">            <xsl:text>Don't know how to chunk with </xsl:text>            <xsl:value-of select="system-property('xsl:vendor')"/>          </xsl:message>        </xsl:otherwise>      </xsl:choose>    </xsl:template>    <xsl:template match="abstract" mode="titlepage.mode">      <div class="{name(.)}">        <xsl:call-template name="anchor"/>        <!--        <xsl:call-template name="formal.object.heading">          <xsl:with-param name="title">            <xsl:apply-templates select="." mode="title.markup"/>          </xsl:with-param>        </xsl:call-template>        -->        <xsl:apply-templates mode="titlepage.mode"/>      </div>    </xsl:template>    <!--    <xsl:template match="phrase">      <xsl:call-template name="inline.monoseq"/>    </xsl:template>        -->    <!-- is this necessary?    <xsl:template match="ulink[@role='cref']">            </xsl:template>    -->        <!-- see chunk-common.xsl -->    <!--    <xsl:template name="chunk-element-content">      <xsl:param name="prev"></xsl:param>      <xsl:param name="next"></xsl:param>          <html>        <xsl:call-template name="html.head">          <xsl:with-param name="prev" select="$prev"/>          <xsl:with-param name="next" select="$next"/>        </xsl:call-template>            <body>          <xsl:call-template name="body.attributes"/>          <xsl:call-template name="user.header.navigation"/>              <xsl:call-template name="header.navigation">        <xsl:with-param name="prev" select="$prev"/>        <xsl:with-param name="next" select="$next"/>          </xsl:call-template>              <xsl:call-template name="user.header.content"/>              <xsl:apply-imports/>              <xsl:call-template name="user.footer.content"/>              <xsl:call-template name="footer.navigation">        <xsl:with-param name="prev" select="$prev"/>        <xsl:with-param name="next" select="$next"/>          </xsl:call-template>              <xsl:call-template name="user.footer.navigation"/>        </body>      </html>    </xsl:template>--></xsl:stylesheet>